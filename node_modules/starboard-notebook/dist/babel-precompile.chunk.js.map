{"version":3,"sources":["webpack://starboard-notebook/./node_modules/@babel/helper-validator-identifier/lib/identifier.js","webpack://starboard-notebook/./node_modules/@babel/helper-validator-identifier/lib/index.js","webpack://starboard-notebook/./node_modules/@babel/helper-validator-identifier/lib/keyword.js","webpack://starboard-notebook/./node_modules/@babel/parser/lib/index.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/asserts/assertNode.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/asserts/generated/index.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/builders/builder.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/builders/generated/index.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/builders/generated/uppercase.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/builders/react/buildChildren.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/clone/clone.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/clone/cloneDeep.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/clone/cloneNode.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/comments/addComment.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/comments/addComments.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/comments/inheritInnerComments.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/comments/inheritLeadingComments.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/comments/inheritTrailingComments.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/comments/inheritsComments.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/comments/removeComments.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/constants/generated/index.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/constants/index.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/ensureBlock.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/toBlock.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/toComputedKey.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/toExpression.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/toIdentifier.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/toKeyAlias.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/toSequenceExpression.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/toStatement.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/converters/valueToNode.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/definitions/core.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/definitions/experimental.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/definitions/flow.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/definitions/index.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/definitions/jsx.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/definitions/misc.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/definitions/placeholders.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/definitions/typescript.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/definitions/utils.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/index.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/modifications/inherits.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/modifications/removeProperties.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/traverse/traverse.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/traverse/traverseFast.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/utils/inherit.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/utils/shallowEqual.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/generated/index.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/is.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isBinding.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isBlockScoped.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isImmutable.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isLet.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isNode.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isNodesEquivalent.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isPlaceholderType.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isReferenced.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isScope.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isSpecifierDefault.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isType.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isValidES3Identifier.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isValidIdentifier.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/isVar.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/matchesPattern.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/react/isCompatTag.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/react/isReactComponent.js","webpack://starboard-notebook/./node_modules/@babel/types/lib/validators/validate.js","webpack://starboard-notebook/./node_modules/@babel/types/node_modules/to-fast-properties/index.js","webpack://starboard-notebook/./node_modules/babel-walk/lib/explode.js","webpack://starboard-notebook/./node_modules/babel-walk/lib/index.js","webpack://starboard-notebook/./src/cellTypes/javascript/precompileModule.ts"],"names":[],"mappings":"qMAEA,OAAO,eAAe,EAAS,aAAc,CAC3C,MAAO,KAET,EAAQ,kBAAoB,EAC5B,EAAQ,iBAAmB,EAC3B,EAAQ,iBAAmB,EAC3B,GAAI,GAA+B,+qIAC/B,EAA0B,8jFAC9B,KAAM,GAA0B,GAAI,QAAO,IAAM,EAA+B,KAC1E,EAAqB,GAAI,QAAO,IAAM,EAA+B,EAA0B,KACrG,EAA+B,EAA0B,KACzD,KAAM,GAA6B,CAAC,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,IAAK,GAAI,GAAI,IAAK,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,KAAM,GAAI,GAAI,KAAM,KAAM,IAAK,KAAM,IAAK,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,KAAM,EAAG,KAAM,GAAI,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,KAAM,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,KAAM,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,KAAM,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,GAAI,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,KAAM,MAAO,GAAI,KAAM,EAAG,IAAK,EAAG,KAAM,GAAI,KAAM,KAAM,IAAK,KAAM,MACv7D,EAAwB,CAAC,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,GAAI,GAAI,EAAG,IAAK,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EA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AG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,KAAM,GAAI,GAAI,KAAM,KAAM,IAAK,KAAM,IAAK,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,KAAM,EAAG,KAAM,GAAI,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,KAAM,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,KAAM,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,KAAM,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,GAAI,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,KAAM,MAAO,GAAI,KAAM,EAAG,IAAK,EAAG,KAAM,GAAI,KAAM,KAAM,IAAK,KAAM,MACv7D,GAAwB,CAAC,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,GAAI,GAAI,EAAG,IAAK,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI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","file":"babel-precompile.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isIdentifierStart = isIdentifierStart;\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierName = isIdentifierName;\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nfunction isIdentifierName(name) {\n  let isFirst = true;\n\n  for (let i = 0; i < name.length; i++) {\n    let cp = name.charCodeAt(i);\n\n    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {\n      const trail = name.charCodeAt(++i);\n\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n\n    if (isFirst) {\n      isFirst = false;\n\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n\n  return !isFirst;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"isIdentifierName\", {\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierName;\n  }\n});\nObject.defineProperty(exports, \"isIdentifierChar\", {\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierChar;\n  }\n});\nObject.defineProperty(exports, \"isIdentifierStart\", {\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierStart;\n  }\n});\nObject.defineProperty(exports, \"isReservedWord\", {\n  enumerable: true,\n  get: function () {\n    return _keyword.isReservedWord;\n  }\n});\nObject.defineProperty(exports, \"isStrictBindOnlyReservedWord\", {\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictBindOnlyReservedWord;\n  }\n});\nObject.defineProperty(exports, \"isStrictBindReservedWord\", {\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictBindReservedWord;\n  }\n});\nObject.defineProperty(exports, \"isStrictReservedWord\", {\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictReservedWord;\n  }\n});\nObject.defineProperty(exports, \"isKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _keyword.isKeyword;\n  }\n});\n\nvar _identifier = require(\"./identifier\");\n\nvar _keyword = require(\"./keyword\");","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isReservedWord = isReservedWord;\nexports.isStrictReservedWord = isStrictReservedWord;\nexports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;\nexports.isStrictBindReservedWord = isStrictBindReservedWord;\nexports.isKeyword = isKeyword;\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\n\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\n\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\n\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\n\nfunction isKeyword(word) {\n  return keywords.has(word);\n}","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/y;\nconst skipWhiteSpaceToLineBreak = new RegExp(\"(?=(\" + skipWhiteSpaceInLine.source + \"))\\\\1\" + /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source, \"y\");\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass Position {\n  constructor(line, col) {\n    this.line = void 0;\n    this.column = void 0;\n    this.line = line;\n    this.column = col;\n  }\n\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n\n}\nfunction getLineInfo(input, offset) {\n  let line = 1;\n  let lineStart = 0;\n  let match;\n  lineBreakG.lastIndex = 0;\n\n  while ((match = lineBreakG.exec(input)) && match.index < offset) {\n    line++;\n    lineStart = lineBreakG.lastIndex;\n  }\n\n  return new Position(line, offset - lineStart);\n}\n\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n\n  hasPlugin(name) {\n    return this.plugins.has(name);\n  }\n\n  getPluginOption(plugin, name) {\n    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];\n  }\n\n}\n\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\n\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\n\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\n\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\n\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.comments.push(comment);\n  }\n\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n\n    const {\n      start: nodeStart\n    } = node;\n\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n\n        break;\n      }\n    }\n  }\n\n  finalizeComment(commentWS) {\n    const {\n      comments\n    } = commentWS;\n\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n\n      if (this.input.charCodeAt(commentStart - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n\n          default:\n            {\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n\n    this.state.commentStack = [];\n  }\n\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n\n}\n\nconst ErrorCodes = Object.freeze({\n  SyntaxError: \"BABEL_PARSER_SYNTAX_ERROR\",\n  SourceTypeModuleError: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n});\n\nconst ErrorMessages = makeErrorTemplates({\n  AccessorIsGenerator: \"A %0ter cannot be a generator.\",\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions.\",\n  BadGetterArity: \"A 'get' accesor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accesor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accesor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: \"'%0' require an initialization value.\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: \"`%0` has already been exported. Exported identifiers must be unique.\",\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: \"A string literal cannot be used as an exported binding without `from`.\\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?\",\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: \"'%0' loop variable declaration may not have an initializer.\",\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: \"Unsyntactic %0.\",\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportBindingIsString: 'A string literal cannot be used as an imported binding.\\n- Did you mean `import { \"%0\" as foo }`?',\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments.\",\n  ImportCallArity: \"`import()` requires exactly %0.\",\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: \"Expected number in radix %0.\",\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: \"Escape sequence in keyword %0.\",\n  InvalidIdentifier: \"Invalid identifier %0.\",\n  InvalidLhs: \"Invalid left-hand side in %0.\",\n  InvalidLhsBinding: \"Binding invalid left-hand side in %0.\",\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: \"Unexpected character '%0'.\",\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: \"Private name #%0 is not defined.\",\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: \"Label '%0' is already declared.\",\n  LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: 'Duplicate key \"%0\" is not allowed in module attributes.',\n  ModuleExportNameHasLoneSurrogate: \"An export name cannot include a lone surrogate, found '\\\\u%0'.\",\n  ModuleExportUndefined: \"Export '%0' is not defined.\",\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PipeBodyIsTighter: \"Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"%0\" }.',\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: \"Hack-style pipe body cannot be an unparenthesized %0 expression; please wrap it in parentheses.\",\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PrivateInExpectedIn: \"Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).\",\n  PrivateNameRedeclaration: \"Duplicate private name #%0.\",\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: \"Assigning to '%0' in strict mode.\",\n  StrictEvalArgumentsBinding: \"Binding '%0' in strict mode.\",\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: \"Unexpected keyword '%0'.\",\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",\n  UnexpectedReservedWord: \"Unexpected reserved word '%0'.\",\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: \"Unexpected token '%0'.\",\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: \"The only valid meta property for %0 is %0.%1.\",\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  VarRedeclaration: \"Identifier '%0' has already been declared.\",\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n}, ErrorCodes.SyntaxError);\nconst SourceTypeModuleErrorMessages = makeErrorTemplates({\n  ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: \"module\"'`,\n  ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: \"module\"'`\n}, ErrorCodes.SourceTypeModuleError);\n\nfunction keepReasonCodeCompat(reasonCode, syntaxPlugin) {\n  {\n    if (syntaxPlugin === \"flow\" && reasonCode === \"PatternIsOptional\") {\n      return \"OptionalBindingPattern\";\n    }\n  }\n  return reasonCode;\n}\n\nfunction makeErrorTemplates(messages, code, syntaxPlugin) {\n  const templates = {};\n  Object.keys(messages).forEach(reasonCode => {\n    templates[reasonCode] = Object.freeze({\n      code,\n      reasonCode: keepReasonCodeCompat(reasonCode, syntaxPlugin),\n      template: messages[reasonCode]\n    });\n  });\n  return Object.freeze(templates);\n}\nclass ParserError extends CommentsParser {\n  getLocationForPosition(pos) {\n    let loc;\n    if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);\n    return loc;\n  }\n\n  raise(pos, {\n    code,\n    reasonCode,\n    template\n  }, ...params) {\n    return this.raiseWithData(pos, {\n      code,\n      reasonCode\n    }, template, ...params);\n  }\n\n  raiseOverwrite(pos, {\n    code,\n    template\n  }, ...params) {\n    const loc = this.getLocationForPosition(pos);\n    const message = template.replace(/%(\\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;\n\n    if (this.options.errorRecovery) {\n      const errors = this.state.errors;\n\n      for (let i = errors.length - 1; i >= 0; i--) {\n        const error = errors[i];\n\n        if (error.pos === pos) {\n          return Object.assign(error, {\n            message\n          });\n        } else if (error.pos < pos) {\n          break;\n        }\n      }\n    }\n\n    return this._raise({\n      code,\n      loc,\n      pos\n    }, message);\n  }\n\n  raiseWithData(pos, data, errorTemplate, ...params) {\n    const loc = this.getLocationForPosition(pos);\n    const message = errorTemplate.replace(/%(\\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;\n    return this._raise(Object.assign({\n      loc,\n      pos\n    }, data), message);\n  }\n\n  _raise(errorContext, message) {\n    const err = new SyntaxError(message);\n    Object.assign(err, errorContext);\n\n    if (this.options.errorRecovery) {\n      if (!this.isLookahead) this.state.errors.push(err);\n      return err;\n    } else {\n      throw err;\n    }\n  }\n\n}\n\nvar estree = (superClass => class extends superClass {\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n\n  parseBigIntLiteral(value) {\n    let bigInt;\n\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  directiveToStmt(directive) {\n    const directiveLiteral = directive.value;\n    const stmt = this.startNodeAt(directive.start, directive.loc.start);\n    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n    expression.value = directiveLiteral.extra.expressionValue;\n    expression.raw = directiveLiteral.extra.raw;\n    stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n    return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n  }\n\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n\n  stmtToDirective(stmt) {\n    const value = stmt.expression.value;\n    const directive = super.stmtToDirective(stmt);\n    this.addExtra(directive.value, \"expressionValue\", value);\n    return directive;\n  }\n\n  parseBlockBody(node, ...args) {\n    super.parseBlockBody(node, ...args);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n\n    classBody.body.push(method);\n  }\n\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    node.type = \"PrivateIdentifier\";\n    return node;\n  }\n\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n\n    type = \"MethodDefinition\";\n    return this.finishNode(node, type);\n  }\n\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    return propertyNode;\n  }\n\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") node.kind = \"init\";\n      node.shorthand = false;\n    }\n\n    return node;\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n\n    return node;\n  }\n\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n\n    return super.isAssignable(node, isBinding);\n  }\n\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.toAssignable(node.value, isLHS);\n      return node;\n    }\n\n    return super.toAssignable(node, isLHS);\n  }\n\n  toAssignableObjectExpressionProp(prop, ...args) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);\n    } else if (prop.method) {\n      this.raise(prop.key.start, ErrorMessages.PatternHasMethod);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, ...args);\n    }\n  }\n\n  finishCallExpression(node, optional) {\n    super.finishCallExpression(node, optional);\n\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n\n      if (this.hasPlugin(\"importAssertions\")) {\n        var _node$arguments$;\n\n        node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;\n      }\n\n      delete node.arguments;\n      delete node.callee;\n    }\n\n    return node;\n  }\n\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n\n    super.toReferencedArguments(node);\n  }\n\n  parseExport(node) {\n    super.parseExport(node);\n\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n\n        break;\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);\n\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n\n    return node;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n\n    return super.hasPropertyAsPrivateName(node);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"ChainExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n\n});\n\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  template: new TokContext(\"`\", true)\n};\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n\n}\nconst keywords$1 = new Map();\n\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\n\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\n\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\n\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\n\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\n\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\", {\n    beforeExpr\n  }),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr: true\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr: true\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n  placeholder: createToken(\"%%\", {\n    startsExpr: true\n  })\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 84 && token <= 119;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 49 && token <= 119;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 49 && token <= 123;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 27 && token <= 30;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 116 && token <= 118;\n}\nfunction tokenIsLoop(token) {\n  return token >= 81 && token <= 83;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 49 && token <= 83;\n}\nfunction tokenIsOperator(token) {\n  return token >= 34 && token <= 50;\n}\nfunction tokenIsPostfix(token) {\n  return token === 31;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 108 && token <= 110;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 111 && token <= 117;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 48;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\nfunction isTokenType(obj) {\n  return typeof obj === \"number\";\n}\n{\n  tokenTypes[8].updateContext = context => {\n    context.pop();\n  };\n\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n    context.push(types.brace);\n  };\n\n  tokenTypes[22].updateContext = context => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n\n  tokenTypes[129].updateContext = context => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\n\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\n\nfunction isIteratorStart(current, next) {\n  return current === 64 && next === 64;\n}\nconst reservedWordLikeSet = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\n\nconst SCOPE_OTHER = 0b000000000,\n      SCOPE_PROGRAM = 0b000000001,\n      SCOPE_FUNCTION = 0b000000010,\n      SCOPE_ARROW = 0b000000100,\n      SCOPE_SIMPLE_CATCH = 0b000001000,\n      SCOPE_SUPER = 0b000010000,\n      SCOPE_DIRECT_SUPER = 0b000100000,\n      SCOPE_CLASS = 0b001000000,\n      SCOPE_STATIC_BLOCK = 0b010000000,\n      SCOPE_TS_MODULE = 0b100000000,\n      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\nconst BIND_KIND_VALUE = 0b000000000001,\n      BIND_KIND_TYPE = 0b000000000010,\n      BIND_SCOPE_VAR = 0b000000000100,\n      BIND_SCOPE_LEXICAL = 0b000000001000,\n      BIND_SCOPE_FUNCTION = 0b000000010000,\n      BIND_FLAGS_NONE = 0b000001000000,\n      BIND_FLAGS_CLASS = 0b000010000000,\n      BIND_FLAGS_TS_ENUM = 0b000100000000,\n      BIND_FLAGS_TS_CONST_ENUM = 0b001000000000,\n      BIND_FLAGS_TS_EXPORT_ONLY = 0b010000000000,\n      BIND_FLAGS_FLOW_DECLARE_FN = 0b100000000000;\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;\nconst CLASS_ELEMENT_FLAG_STATIC = 0b100,\n      CLASS_ELEMENT_KIND_GETTER = 0b010,\n      CLASS_ELEMENT_KIND_SETTER = 0b001,\n      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\nconst CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n      CLASS_ELEMENT_OTHER = 0;\n\nclass Scope {\n  constructor(flags) {\n    this.var = new Set();\n    this.lexical = new Set();\n    this.functions = new Set();\n    this.flags = flags;\n  }\n\n}\nclass ScopeHandler {\n  constructor(raise, inModule) {\n    this.scopeStack = [];\n    this.undefinedExports = new Map();\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;\n  }\n\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;\n  }\n\n  get inClass() {\n    return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;\n  }\n\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;\n  }\n\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n\n      if (flags & SCOPE_STATIC_BLOCK) {\n        return true;\n      }\n\n      if (flags & (SCOPE_VAR | SCOPE_CLASS)) {\n        return false;\n      }\n    }\n  }\n\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags) {\n    return new Scope(flags);\n  }\n\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n\n  declareName(name, bindingType, pos) {\n    let scope = this.currentScope();\n\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.add(name);\n      } else {\n        scope.lexical.add(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        scope.var.add(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope, name) {\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(scope, name, bindingType, pos) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.raise(pos, ErrorMessages.VarRedeclaration, name);\n    }\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);\n    }\n\n    return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);\n  }\n\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n\n    if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {\n      this.undefinedExports.set(name, id.start);\n    }\n  }\n\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n\n      if (flags & SCOPE_VAR) {\n        return flags;\n      }\n    }\n  }\n\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n\n      if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {\n        return flags;\n      }\n    }\n  }\n\n}\n\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = new Set();\n  }\n\n}\n\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n\n  declareName(name, bindingType, pos) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(...arguments)) return true;\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));\n    }\n\n    return false;\n  }\n\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nclass State {\n  constructor() {\n    this.strict = void 0;\n    this.curLine = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.maybeInArrowParameters = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.inPropertyName = false;\n    this.hasFlowComment = false;\n    this.isAmbientContext = false;\n    this.inAbstractClass = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.comments = [];\n    this.commentStack = [];\n    this.pos = 0;\n    this.lineStart = 0;\n    this.type = 126;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.lastTokEnd = 0;\n    this.context = [types.brace];\n    this.exprAllowed = true;\n    this.containsEsc = false;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n\n  init(options) {\n    this.strict = options.strictMode === false ? false : options.strictMode === true ? true : options.sourceType === \"module\";\n    this.curLine = options.startLine;\n    this.startLoc = this.endLoc = this.curPosition();\n  }\n\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n\n    return state;\n  }\n\n}\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100]);\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],\n  hex: [46, 88, 95, 120]\n};\nconst allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [48, 49];\nallowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];\nallowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];\nallowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n}\nclass Tokenizer extends ParserError {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  next() {\n    this.checkKeywordEscapes();\n\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  match(type) {\n    return this.state.type === type;\n  }\n\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      lastTokEnd: state.end,\n      context: [this.curContext()],\n      inType: state.inType\n    };\n  }\n\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n\n    return cp;\n  }\n\n  setStrict(strict) {\n    this.state.strict = strict;\n\n    if (strict) {\n      this.state.strictErrors.forEach((message, pos) => this.raise(pos, message));\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  nextToken() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.length) {\n      this.finishToken(126);\n      return;\n    }\n\n    if (curContext === types.template) {\n      this.readTmplToken();\n    } else {\n      this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n    }\n  }\n\n  skipBlockComment() {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", start + 2);\n    if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start + 2;\n\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n\n    if (this.isLookahead) return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + 2,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    if (this.isLookahead) return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = [];\n\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment();\n\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n\n                break;\n              }\n\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n\n                break;\n              }\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule) {\n            const pos = this.state.pos;\n\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule) {\n            const pos = this.state.pos;\n\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n\n      }\n    }\n\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const CommentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(CommentWhitespace);\n    }\n  }\n\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    if (!this.isLookahead) {\n      this.state.endLoc = this.state.curPosition();\n      this.updateContext(prevType);\n    }\n  }\n\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n\n    if (next >= 48 && next <= 57) {\n      throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);\n    }\n\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);\n      }\n\n      this.state.pos += 2;\n\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(125, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(125, this.readWord1());\n    } else {\n      this.finishOp(25, 1);\n    }\n  }\n\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(29, 2);\n    } else {\n      this.finishOp(47, 1);\n    }\n  }\n\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(26, value);\n    return true;\n  }\n\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 46 : 45;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 48;\n    }\n\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 30 : 28;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(28, 3);\n      } else {\n        this.finishOp(code === 124 ? 36 : 37, 2);\n      }\n\n      return;\n    }\n\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(34, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(28, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? 38 : 40, 1);\n  }\n\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(28, 2);\n    } else {\n      this.finishOp(39, 1);\n    }\n  }\n\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      this.finishOp(31, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(28, 2);\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n\n  readToken_lt_gt(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    let size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(this.state.pos + size) === 61) {\n        this.finishOp(28, size + 1);\n        return;\n      }\n\n      this.finishOp(43, size);\n      return;\n    }\n\n    if (next === 61) {\n      size = 2;\n    }\n\n    this.finishOp(42, size);\n  }\n\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(41, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n\n    this.finishOp(code === 61 ? 27 : 32, 1);\n  }\n\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(28, 3);\n      } else {\n        this.finishOp(35, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 96:\n        ++this.state.pos;\n        this.finishToken(22);\n        return;\n\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n      case 62:\n        this.readToken_lt_gt(code);\n        return;\n\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        this.finishOp(33, 1);\n        return;\n\n      case 64:\n        ++this.state.pos;\n        this.finishToken(24);\n        return;\n\n      case 35:\n        this.readToken_numberSign();\n        return;\n\n      case 92:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n\n    }\n\n    throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));\n  }\n\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp() {\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(start, ErrorMessages.UnterminatedRegExp);\n      }\n\n      const ch = this.input.charCodeAt(pos);\n\n      if (isNewLine(ch)) {\n        throw this.raise(start, ErrorMessages.UnterminatedRegExp);\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n\n        escaped = ch === 92;\n      }\n    }\n\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (mods.includes(char)) {\n          this.raise(pos + 1, ErrorMessages.DuplicateRegExpFlags);\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(pos + 1, ErrorMessages.MalformedRegExpFlags);\n      } else {\n        break;\n      }\n\n      ++pos;\n      mods += char;\n    }\n\n    this.state.pos = pos;\n    this.finishToken(124, {\n      pattern: content,\n      flags: mods\n    });\n  }\n\n  readInt(radix, len, forceLen, allowNumSeparator = true) {\n    const start = this.state.pos;\n    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n    const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;\n    let invalid = false;\n    let total = 0;\n\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      const code = this.input.charCodeAt(this.state.pos);\n      let val;\n\n      if (code === 95) {\n        const prev = this.input.charCodeAt(this.state.pos - 1);\n        const next = this.input.charCodeAt(this.state.pos + 1);\n\n        if (allowedSiblings.indexOf(next) === -1) {\n          this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);\n        } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {\n          this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);\n        }\n\n        if (!allowNumSeparator) {\n          this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);\n        }\n\n        ++this.state.pos;\n        continue;\n      }\n\n      if (code >= 97) {\n        val = code - 97 + 10;\n      } else if (code >= 65) {\n        val = code - 65 + 10;\n      } else if (_isDigit(code)) {\n        val = code - 48;\n      } else {\n        val = Infinity;\n      }\n\n      if (val >= radix) {\n        if (this.options.errorRecovery && val <= 9) {\n          val = 0;\n          this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);\n        } else if (forceLen) {\n          val = 0;\n          invalid = true;\n        } else {\n          break;\n        }\n      }\n\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n\n    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {\n      return null;\n    }\n\n    return total;\n  }\n\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);\n    }\n\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(start, ErrorMessages.InvalidDecimal);\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(122, str);\n      return;\n    }\n\n    this.finishToken(121, val);\n  }\n\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, ErrorMessages.InvalidNumber);\n    }\n\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);\n\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n\n        if (underscorePos > 0) {\n          this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);\n        }\n      }\n\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n\n      if (this.readInt(10) === null) {\n        this.raise(start, ErrorMessages.InvalidOrMissingExponent);\n      }\n\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(start, ErrorMessages.InvalidBigIntLiteral);\n      }\n\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.pos);\n\n      if (hasExponent || hasLeadingZero) {\n        this.raise(start, ErrorMessages.InvalidDecimal);\n      }\n\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);\n    }\n\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(122, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(123, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(121, val);\n  }\n\n  readCodePoint(throwOnInvalid) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let code;\n\n    if (ch === 123) {\n      const codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, true, throwOnInvalid);\n      ++this.state.pos;\n\n      if (code !== null && code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, ErrorMessages.InvalidCodePoint);\n        } else {\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, false, throwOnInvalid);\n    }\n\n    return code;\n  }\n\n  readString(quote) {\n    let out = \"\",\n        chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else if (ch === 8232 || ch === 8233) {\n        ++this.state.pos;\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(120, out);\n  }\n\n  readTmplToken() {\n    let out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        if (this.state.pos === this.state.start && this.match(20)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            this.finishToken(23);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(22);\n            return;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(20, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        const escaped = this.readEscapedChar(true);\n\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) {\n              ++this.state.pos;\n            }\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }\n\n  recordStrictModeErrors(pos, message) {\n    if (this.state.strict && !this.state.strictErrors.has(pos)) {\n      this.raise(pos, message);\n    } else {\n      this.state.strictErrors.set(pos, message);\n    }\n  }\n\n  readEscapedChar(inTemplate) {\n    const throwOnInvalid = !inTemplate;\n    const ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n\n      case 114:\n        return \"\\r\";\n\n      case 120:\n        {\n          const code = this.readHexChar(2, false, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n\n      case 117:\n        {\n          const code = this.readCodePoint(throwOnInvalid);\n          return code === null ? null : String.fromCodePoint(code);\n        }\n\n      case 116:\n        return \"\\t\";\n\n      case 98:\n        return \"\\b\";\n\n      case 118:\n        return \"\\u000b\";\n\n      case 102:\n        return \"\\f\";\n\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) {\n          ++this.state.pos;\n        }\n\n      case 10:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n\n      case 8232:\n      case 8233:\n        return \"\";\n\n      case 56:\n      case 57:\n        if (inTemplate) {\n          return null;\n        } else {\n          this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);\n        }\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          const codePos = this.state.pos - 1;\n          const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);\n          let octalStr = match[0];\n          let octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          this.state.pos += octalStr.length - 1;\n          const next = this.input.charCodeAt(this.state.pos);\n\n          if (octalStr !== \"0\" || next === 56 || next === 57) {\n            if (inTemplate) {\n              return null;\n            } else {\n              this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);\n            }\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }\n\n  readHexChar(len, forceLen, throwOnInvalid) {\n    const codePos = this.state.pos;\n    const n = this.readInt(16, len, forceLen, false);\n\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, ErrorMessages.InvalidEscapeSequence);\n      } else {\n        this.state.pos = codePos - 1;\n      }\n    }\n\n    return n;\n  }\n\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.pos;\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(119, word);\n    }\n  }\n\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, tokenLabelName(type));\n    }\n  }\n\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n\n    switch (type) {\n      case 8:\n        context.pop();\n        break;\n\n      case 5:\n      case 7:\n      case 23:\n        context.push(types.brace);\n        break;\n\n      case 22:\n        if (context[context.length - 1] === types.template) {\n          context.pop();\n        } else {\n          context.push(types.template);\n        }\n\n        break;\n    }\n  }\n\n}\n\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n\n}\nclass ClassScopeHandler {\n  constructor(raise) {\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n  }\n\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n\n    for (const [name, pos] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, pos);\n        }\n      } else {\n        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);\n      }\n    }\n  }\n\n  declarePrivateName(name, elementType, pos) {\n    const classScope = this.current();\n    let redefined = classScope.privateNames.has(name);\n\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && classScope.loneAccessors.get(name);\n\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) classScope.loneAccessors.delete(name);\n      } else if (!redefined) {\n        classScope.loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);\n    }\n\n    classScope.privateNames.add(name);\n    classScope.undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name, pos) {\n    let classScope;\n\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, pos);\n    } else {\n      this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);\n    }\n  }\n\n}\n\nconst kExpression = 0,\n      kMaybeArrowParameterDeclaration = 1,\n      kMaybeAsyncArrowParameterDeclaration = 2,\n      kParameterDeclaration = 3;\n\nclass ExpressionScope {\n  constructor(type = kExpression) {\n    this.type = void 0;\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration() {\n    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n\n}\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.errors = new Map();\n  }\n\n  recordDeclarationError(pos, template) {\n    this.errors.set(pos, template);\n  }\n\n  clearDeclarationError(pos) {\n    this.errors.delete(pos);\n  }\n\n  iterateErrors(iterator) {\n    this.errors.forEach(iterator);\n  }\n\n}\n\nclass ExpressionScopeHandler {\n  constructor(raise) {\n    this.stack = [new ExpressionScope()];\n    this.raise = raise;\n  }\n\n  enter(scope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  recordParameterInitializerError(pos, template) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(pos, template);\n      } else {\n        return;\n      }\n\n      scope = stack[--i];\n    }\n\n    this.raise(pos, template);\n  }\n\n  recordParenthesizedIdentifierError(pos, template) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.raise(pos, template);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(pos, template);\n    } else {\n      return;\n    }\n  }\n\n  recordAsyncArrowParametersError(pos, template) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        scope.recordDeclarationError(pos, template);\n      }\n\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors((template, pos) => {\n      this.raise(pos, template);\n      let i = stack.length - 2;\n      let scope = stack[i];\n\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(pos);\n        scope = stack[--i];\n      }\n    });\n  }\n\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\n\nconst PARAM = 0b0000,\n      PARAM_YIELD = 0b0001,\n      PARAM_AWAIT = 0b0010,\n      PARAM_RETURN = 0b0100,\n      PARAM_IN = 0b1000;\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait() {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n\n  get hasYield() {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n\n  get hasReturn() {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n\n  get hasIn() {\n    return (this.currentFlags() & PARAM_IN) > 0;\n  }\n\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, val) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n    extra[key] = val;\n  }\n\n  isRelational(op) {\n    return this.match(42) && this.state.value === op;\n  }\n\n  expectRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n    } else {\n      this.unexpected(null, 42);\n    }\n  }\n\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\n    }\n\n    return false;\n  }\n\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  expectContextual(token, template) {\n    if (!this.eatContextual(token)) this.unexpected(null, template);\n  }\n\n  canInsertSemicolon() {\n    return this.match(126) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n  }\n\n  hasFollowingLineBreak() {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);\n  }\n\n  expect(type, pos) {\n    this.eat(type) || this.unexpected(pos, type);\n  }\n\n  assertNoSpace(message = \"Unexpected space.\") {\n    if (this.state.start > this.state.lastTokEnd) {\n      this.raise(this.state.lastTokEnd, {\n        code: ErrorCodes.SyntaxError,\n        reasonCode: \"UnexpectedSpace\",\n        template: message\n      });\n    }\n  }\n\n  unexpected(pos, messageOrType = {\n    code: ErrorCodes.SyntaxError,\n    reasonCode: \"UnexpectedToken\",\n    template: \"Unexpected token\"\n  }) {\n    if (isTokenType(messageOrType)) {\n      messageOrType = {\n        code: ErrorCodes.SyntaxError,\n        reasonCode: \"UnexpectedToken\",\n        template: `Unexpected token, expected \"${tokenLabelName(messageOrType)}\"`\n      };\n    }\n\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n  }\n\n  expectPlugin(name, pos) {\n    if (!this.hasPlugin(name)) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: [name]\n      }, `This experimental syntax requires enabling the parser plugin: '${name}'`);\n    }\n\n    return true;\n  }\n\n  expectOnePlugin(names, pos) {\n    if (!names.some(n => this.hasPlugin(n))) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: names\n      }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\", \")}'`);\n    }\n  }\n\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssign,\n      doubleProto,\n      optionalParameters\n    } = refExpressionErrors;\n\n    if (!andThrow) {\n      return shorthandAssign >= 0 || doubleProto >= 0 || optionalParameters >= 0;\n    }\n\n    if (shorthandAssign >= 0) {\n      this.unexpected(shorthandAssign);\n    }\n\n    if (doubleProto >= 0) {\n      this.raise(doubleProto, ErrorMessages.DuplicateProto);\n    }\n\n    if (optionalParameters >= 0) {\n      this.unexpected(optionalParameters);\n    }\n  }\n\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this.raise.bind(this));\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n\n  enterInitialScopes() {\n    let paramFlags = PARAM;\n\n    if (this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssign = -1;\n    this.doubleProto = -1;\n    this.optionalParameters = -1;\n  }\n\n}\n\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser != null && parser.options.ranges) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n\n}\n\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function () {\n    const newNode = new Node();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  };\n}\n\nfunction clonePlaceholder(node) {\n  return cloneIdentifier(node);\n}\n\nfunction cloneIdentifier(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra,\n    name\n  } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n\n  return cloned;\n}\nfunction cloneStringLiteral(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra\n  } = node;\n\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n\n  const cloned = Object.create(NodePrototype);\n  cloned.type = \"StringLiteral\";\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.value = node.value;\n  return cloned;\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt(pos, loc) {\n    return new Node(this, pos, loc);\n  }\n\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n  }\n\n  finishNodeAt(node, type, pos, loc) {\n\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    if (this.options.attachComment) this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {\n    node.end = end;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = end;\n  }\n\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n\n}\n\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = makeErrorTemplates({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: \"Cannot overwrite reserved type %0.\",\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: \"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",\n  EnumDuplicateMemberName: \"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",\n  EnumInconsistentMemberValues: \"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",\n  EnumInvalidExplicitType: \"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidExplicitTypeUnknownSupplied: \"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidMemberInitializerPrimaryType: \"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",\n  EnumInvalidMemberInitializerSymbolType: \"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",\n  EnumInvalidMemberInitializerUnknownType: \"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",\n  EnumInvalidMemberName: \"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",\n  EnumNumberMemberNotInitialized: \"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",\n  EnumStringMemberInconsistentlyInitailized: \"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: \"Unexpected reserved type %0.\",\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: \"`declare export %0` is not supported. Use `%1` instead.\",\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n}, ErrorCodes.SyntaxError, \"flow\");\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(type) {\n  return tokenIsKeywordOrIdentifier(type) && type !== 88;\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass => class extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = undefined;\n  }\n\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n\n  finishToken(type, val) {\n    if (type !== 120 && type !== 13 && type !== 26) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n\n    return super.finishToken(type, val);\n  }\n\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n\n      if (!matches) ; else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n\n    return super.addComment(comment);\n  }\n\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloPos = this.state.start;\n    this.next();\n    this.expectContextual(98);\n\n    if (this.state.lastTokStart > moduloPos + 1) {\n      this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);\n    }\n\n    if (this.eat(10)) {\n      node.value = this.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n\n    if (this.match(45)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n\n      if (this.match(45)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n\n    return [type, predicate];\n  }\n\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n\n    if (this.isRelational(\"<\")) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n\n  flowParseDeclare(node, insideModule) {\n    if (this.match(71)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(59)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(65)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(114)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);\n        }\n\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(117)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(118)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(116)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(73)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, BIND_VAR, node.id.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n\n  flowParseDeclareModule(node) {\n    this.scope.enter(SCOPE_OTHER);\n\n    if (this.match(120)) {\n      node.id = this.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n\n    while (!this.match(8)) {\n      let bodyNode = this.startNode();\n\n      if (this.match(74)) {\n        this.next();\n\n        if (!this.isContextual(117) && !this.match(78)) {\n          this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);\n        }\n\n        this.parseImport(bodyNode);\n      } else {\n        this.expectContextual(112, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n\n      body.push(bodyNode);\n    }\n\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n        }\n\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);\n        }\n\n        if (kind === \"ES\") {\n          this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n        }\n\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(73);\n\n    if (this.eat(56)) {\n      if (this.match(59) || this.match(71)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(66) || this.isLet() || (this.isContextual(117) || this.isContextual(116)) && !insideModule) {\n        const label = this.state.value;\n        const suggestion = exportSuggestions[label];\n        throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);\n      }\n\n      if (this.match(65) || this.match(59) || this.match(71) || this.isContextual(118)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(46) || this.match(5) || this.isContextual(116) || this.isContextual(117) || this.isContextual(118)) {\n        node = this.parseExport(node);\n\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.type = \"ExportDeclaration\";\n          node.default = false;\n          delete node.exportKind;\n        }\n\n        node.type = \"Declare\" + node.type;\n        return node;\n      }\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(99);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    this.flowParseTypeAlias(node);\n    node.type = \"DeclareTypeAlias\";\n    return node;\n  }\n\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    this.flowParseOpaqueType(node, true);\n    node.type = \"DeclareOpaqueType\";\n    return node;\n  }\n\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n\n  flowParseInterfaceish(node, isClass = false) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.extends = [];\n    node.implements = [];\n    node.mixins = [];\n\n    if (this.eat(72)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n\n    if (this.isContextual(105)) {\n      this.next();\n\n      do {\n        node.mixins.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n\n    if (this.isContextual(101)) {\n      this.next();\n\n      do {\n        node.implements.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);\n    }\n  }\n\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);\n  }\n\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.start, declaration);\n    return this.parseIdentifier(liberal);\n  }\n\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.right = this.flowParseTypeInitialiser(27);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(117);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.supertype = null;\n\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n\n    node.impltype = null;\n\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(27);\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStart = this.state.start;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n\n    if (this.match(27)) {\n      this.eat(27);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);\n      }\n    }\n\n    return this.finishNode(node, \"TypeParameter\");\n  }\n\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n\n    if (this.isRelational(\"<\") || this.match(129)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    let defaultRequired = false;\n\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n\n      if (!this.isRelational(\">\")) {\n        this.expect(12);\n      }\n    } while (!this.isRelational(\">\"));\n\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expectRelational(\"<\");\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n\n    while (!this.isRelational(\">\")) {\n      node.params.push(this.flowParseType());\n\n      if (!this.isRelational(\">\")) {\n        this.expect(12);\n      }\n    }\n\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expectRelational(\"<\");\n\n    while (!this.isRelational(\">\")) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n\n      if (!this.isRelational(\">\")) {\n        this.expect(12);\n      }\n    }\n\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(116);\n    node.extends = [];\n\n    if (this.eat(72)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n\n  flowParseObjectPropertyKey() {\n    return this.match(121) || this.match(120) ? this.parseExprAtom() : this.parseIdentifier(true);\n  }\n\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n\n    if (this.isRelational(\"<\") || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n    } else {\n      node.method = false;\n\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n\n      node.value = this.flowParseTypeInitialiser();\n    }\n\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    this.expect(10);\n\n    if (this.match(69)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n\n    nodeStart.exact = exact;\n\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStart = null;\n      let inexactStart = null;\n      const node = this.startNode();\n\n      if (allowProto && this.isContextual(106)) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStart = this.state.start;\n          allowStatic = false;\n        }\n      }\n\n      if (allowStatic && this.isContextual(95)) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n\n      const variance = this.flowParseVariance();\n\n      if (this.eat(0)) {\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.isRelational(\"<\")) {\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.unexpected(variance.start);\n        }\n\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n\n        if (this.isContextual(89) || this.isContextual(94)) {\n          const lookahead = this.lookahead();\n\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStart = this.state.lastTokStart;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n\n      this.flowObjectTypeSemicolon();\n\n      if (inexactStart && !this.match(8) && !this.match(9)) {\n        this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);\n      }\n    }\n\n    this.expect(endDelim);\n\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n\n  flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);\n        } else if (!allowInexact) {\n          this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);\n        }\n\n        if (variance) {\n          this.raise(variance.start, FlowErrors.InexactVariance);\n        }\n\n        return null;\n      }\n\n      if (!allowSpread) {\n        this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);\n      }\n\n      if (protoStart != null) {\n        this.unexpected(protoStart);\n      }\n\n      if (variance) {\n        this.raise(variance.start, FlowErrors.SpreadVariance);\n      }\n\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStart != null;\n      node.kind = kind;\n      let optional = false;\n\n      if (this.isRelational(\"<\") || this.match(10)) {\n        node.method = true;\n\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.unexpected(variance.start);\n        }\n\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(node.value.this.start, FlowErrors.ThisParamBannedInConstructor);\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n\n        if (this.eat(17)) {\n          optional = true;\n        }\n\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const start = property.start;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n\n    if (property.value.this) {\n      this.raise(property.value.this.start, property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam);\n    }\n\n    if (length !== paramCount) {\n      if (property.kind === \"get\") {\n        this.raise(start, ErrorMessages.BadGetterArity);\n      } else {\n        this.raise(start, ErrorMessages.BadSetterArity);\n      }\n    }\n\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(start, ErrorMessages.BadSetterRestParameter);\n    }\n  }\n\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n\n  flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startPos, startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n\n    return node;\n  }\n\n  flowParseGenericType(startPos, startLoc, id) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(78);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 69;\n\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(node.start, FlowErrors.ThisParamMustBeFirst);\n      }\n\n      name = this.parseIdentifier(isThis);\n\n      if (this.eat(17)) {\n        optional = true;\n\n        if (isThis) {\n          this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);\n        }\n      }\n\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.start, type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n\n    if (this.match(69)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n\n  flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startPos, startLoc, id);\n    }\n  }\n\n  flowParsePrimaryType() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n\n      case 42:\n        if (this.state.value === \"<\") {\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(10);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n\n        break;\n\n      case 10:\n        this.next();\n\n        if (!this.match(11) && !this.match(21)) {\n          if (tokenIsIdentifier(this.state.type) || this.match(69)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== 17 && token !== 14;\n          } else {\n            isGroupedType = true;\n          }\n        }\n\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n            this.expect(11);\n            return type;\n          } else {\n            this.eat(12);\n          }\n        }\n\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n      case 120:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n      case 76:\n      case 77:\n        node.value = this.match(76);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n      case 44:\n        if (this.state.value === \"-\") {\n          this.next();\n\n          if (this.match(121)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n\n          if (this.match(122)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n\n          throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);\n        }\n\n        throw this.unexpected();\n\n      case 121:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n      case 122:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n\n      case 79:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n\n      case 75:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n      case 69:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n\n      case 46:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n      case 78:\n        return this.flowParseTypeofType();\n\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(116)) {\n            return this.flowParseInterfaceType();\n          }\n\n          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n        }\n\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParsePostfixType() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n\n    return type;\n  }\n\n  flowParsePrefixType() {\n    const node = this.startNode();\n\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.start, param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    return param;\n  }\n\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(40);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n\n    while (this.eat(40)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(38);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n\n    while (this.eat(38)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 119 && this.state.value === \"_\") {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startPos, startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n\n    return ident;\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  flowParseVariance() {\n    let variance = null;\n\n    if (this.match(44)) {\n      variance = this.startNode();\n\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n\n      this.next();\n      this.finishNode(variance, \"Variance\");\n    }\n\n    return variance;\n  }\n\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n    }\n\n    return super.parseFunctionBody(node, false, isMethod);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.state.strict && this.isContextual(116)) {\n      const lookahead = this.lookahead();\n\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.shouldParseEnums() && this.isContextual(113)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n\n    const stmt = super.parseStatement(context, topLevel);\n\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n\n    return stmt;\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(71) || tokenIsIdentifier(this.state.type) || this.match(59) || this.match(65) || this.match(73)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n\n    return super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 113) {\n      return !this.state.containsEsc;\n    }\n\n    return super.shouldParseExportDeclaration();\n  }\n\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 113) {\n      return this.state.containsEsc;\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(113)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseConditional(expr, startPos, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startPos, startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n\n      if (failed && valid.length > 1) {\n        this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);\n      }\n\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n\n    while (stack.length !== 0) {\n      const node = stack.pop();\n\n      if (node.type === \"ArrowFunctionExpression\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n\n  finishArrowValidation(node) {\n    var _node$extra;\n\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n\n    return result;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n\n    super.assertModuleNodeAllowed(node);\n  }\n\n  parseExport(node) {\n    const decl = super.parseExport(node);\n\n    if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n      decl.exportKind = decl.exportKind || \"value\";\n    }\n\n    return decl;\n  }\n\n  parseExportDeclaration(node) {\n    if (this.isContextual(117)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers();\n        this.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(118)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(116)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(113)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n\n  eatExportStar(node) {\n    if (super.eatExportStar(...arguments)) return true;\n\n    if (this.isContextual(117) && this.lookahead().type === 46) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    const pos = this.state.start;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(pos);\n    }\n\n    return hasNamespace;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n\n  parseClassMember(classBody, member, state) {\n    const pos = this.state.start;\n\n    if (this.isContextual(112)) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      member.declare = true;\n    }\n\n    super.parseClassMember(classBody, member, state);\n\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(pos, FlowErrors.DeclareClassElement);\n      } else if (member.value) {\n        this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);\n      }\n    }\n  }\n\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, fullWord);\n    }\n\n    this.finishToken(119, fullWord);\n  }\n\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 123 && next === 124) {\n      return this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(42, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        return this.finishOp(18, 2);\n      }\n\n      return this.finishOp(17, 1);\n    } else if (isIteratorStart(code, next)) {\n      this.state.pos += 2;\n      return this.readIterator();\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n\n  toAssignable(node, isLHS = false) {\n    if (node.type === \"TypeCastExpression\") {\n      return super.toAssignable(this.typeCastToParameter(node), isLHS);\n    } else {\n      return super.toAssignable(node, isLHS);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaPos, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n\n    return super.toAssignableList(exprList, trailingCommaPos, isLHS);\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);\n      }\n    }\n\n    return exprList;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n\n    return node;\n  }\n\n  checkLVal(expr, ...args) {\n    if (expr.type !== \"TypeCastExpression\") {\n      return super.checkLVal(expr, ...args);\n    }\n  }\n\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassPrivateProperty(node);\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.start);\n    }\n\n    delete method.variance;\n\n    if (this.isRelational(\"<\")) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n\n    if (method.params && isConstructor) {\n      const params = method.params;\n\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);\n      }\n    }\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.start);\n    }\n\n    delete method.variance;\n\n    if (this.isRelational(\"<\")) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    if (this.isContextual(101)) {\n      this.next();\n      const implemented = node.implements = [];\n\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    if (params.length > 0) {\n      const param = params[0];\n\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);\n      } else if (this.isThisParam(param)) {\n        this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);\n      }\n    }\n  }\n\n  parsePropertyName(node, isPrivateNameAllowed) {\n    const variance = this.flowParseVariance();\n    const key = super.parsePropertyName(node, isPrivateNameAllowed);\n    node.variance = variance;\n    return key;\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.start);\n    }\n\n    delete prop.variance;\n    let typeParameters;\n\n    if (this.isRelational(\"<\") && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n\n    super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n\n    if (typeParameters) {\n      (prop.value || prop).typeParameters = typeParameters;\n    }\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(param.start, FlowErrors.PatternIsOptional);\n      }\n\n      if (this.isThisParam(param)) {\n        this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);\n      }\n\n      param.optional = true;\n    }\n\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);\n    }\n\n    if (this.match(27) && this.isThisParam(param)) {\n      this.raise(param.start, FlowErrors.ThisParamNoDefault);\n    }\n\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);\n    }\n\n    return node;\n  }\n\n  shouldParseDefaultImport(node) {\n    if (!hasTypeImportKind(node)) {\n      return super.shouldParseDefaultImport(node);\n    }\n\n    return isMaybeDefaultImport(this.state.type);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    node.importKind = \"value\";\n    let kind = null;\n\n    if (this.match(78)) {\n      kind = \"typeof\";\n    } else if (this.isContextual(117)) {\n      kind = \"type\";\n    }\n\n    if (kind) {\n      const lh = this.lookahead();\n      const {\n        type\n      } = lh;\n\n      if (kind === \"type\" && type === 46) {\n        this.unexpected(lh.start);\n      }\n\n      if (isMaybeDefaultImport(type) || type === 5 || type === 46) {\n        this.next();\n        node.importKind = kind;\n      }\n    }\n\n    return super.maybeParseDefaultImportSpecifier(node);\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    const firstIdentIsString = this.match(120);\n    const firstIdent = this.parseModuleExportName();\n    let specifierTypeKind = null;\n\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n\n    let isBinding = false;\n\n    if (this.isContextual(84) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (firstIdentIsString) {\n          throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);\n        }\n\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n\n      if (this.eatContextual(84)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = cloneIdentifier(specifier.imported);\n      }\n    }\n\n    const nodeIsTypeImport = hasTypeImportKind(node);\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n    if (nodeIsTypeImport && specifierIsTypeImport) {\n      this.raise(specifier.start, FlowErrors.ImportTypeShorthandOnlyInPureImport);\n    }\n\n    if (nodeIsTypeImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.start, true);\n    }\n\n    if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n    }\n\n    this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 69:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const kind = node.kind;\n\n    if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n\n    let state = null;\n    let jsx;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(129) || this.isRelational(\"<\"))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const curContext = context[context.length - 1];\n\n      if (curContext === types.j_oTag) {\n        context.length -= 2;\n      } else if (curContext === types.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if ((_jsx = jsx) != null && _jsx.error || this.isRelational(\"<\")) {\n      var _jsx2, _jsx3;\n\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== \"ArrowFunctionExpression\") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);\n          }\n\n          return arrow.node;\n        }\n\n        arrowExpression = arrow.node;\n      }\n\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);\n    }\n\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n\n    return super.parseArrow(node);\n  }\n\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(node.params[i].start, FlowErrors.ThisParamMustBeFirst);\n      }\n    }\n\n    return super.checkParams(...arguments);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.isRelational(\"<\")) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n\n      throw arrow.error || result.error;\n    }\n\n    return super.parseSubscripts(base, startPos, startLoc, noCalls);\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.isRelational(\"<\")) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = this.parseCallExpressionArguments(11, false);\n        if (subscriptState.optionalChainMember) node.optional = false;\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);\n  }\n\n  parseNewArguments(node) {\n    let targs = null;\n\n    if (this.shouldParseTypes() && this.isRelational(\"<\")) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n\n    node.typeArguments = targs;\n    super.parseNewArguments(node);\n  }\n\n  parseAsyncArrowWithTypeParameters(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.parseFunctionParams(node);\n    if (!this.parseArrow(node)) return;\n    return this.parseArrowExpression(node, undefined, true);\n  }\n\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n\n    super.readToken_mult_modulo(code);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n\n    super.readToken_pipe_amp(code);\n  }\n\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n\n    if (this.state.hasFlowComment) {\n      this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);\n    }\n\n    return fileNode;\n  }\n\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        this.unexpected(null, FlowErrors.NestedFlowComment);\n      }\n\n      this.hasFlowCommentCompletion();\n      this.state.pos += this.skipFlowComment();\n      this.state.hasFlowComment = true;\n      return;\n    }\n\n    if (this.state.hasFlowComment) {\n      const end = this.input.indexOf(\"*-/\", this.state.pos += 2);\n\n      if (end === -1) {\n        throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);\n      }\n\n      this.state.pos = end + 3;\n      return;\n    }\n\n    return super.skipBlockComment();\n  }\n\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n\n    return false;\n  }\n\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n\n    if (end === -1) {\n      throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);\n    }\n  }\n\n  flowEnumErrorBooleanMemberNotInitialized(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);\n  }\n\n  flowEnumErrorInvalidMemberName(pos, {\n    enumName,\n    memberName\n  }) {\n    const suggestion = memberName[0].toUpperCase() + memberName.slice(1);\n    this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);\n  }\n\n  flowEnumErrorDuplicateMemberName(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);\n  }\n\n  flowEnumErrorInconsistentMemberValues(pos, {\n    enumName\n  }) {\n    this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);\n  }\n\n  flowEnumErrorInvalidExplicitType(pos, {\n    enumName,\n    suppliedType\n  }) {\n    return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);\n  }\n\n  flowEnumErrorInvalidMemberInitializer(pos, {\n    enumName,\n    explicitType,\n    memberName\n  }) {\n    let message = null;\n\n    switch (explicitType) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;\n        break;\n\n      case \"symbol\":\n        message = FlowErrors.EnumInvalidMemberInitializerSymbolType;\n        break;\n\n      default:\n        message = FlowErrors.EnumInvalidMemberInitializerUnknownType;\n    }\n\n    return this.raise(pos, message, enumName, memberName, explicitType);\n  }\n\n  flowEnumErrorNumberMemberNotInitialized(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);\n  }\n\n  flowEnumErrorStringMemberInconsistentlyInitailized(pos, {\n    enumName\n  }) {\n    this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);\n  }\n\n  flowEnumMemberInit() {\n    const startPos = this.state.start;\n\n    const endOfInit = () => this.match(12) || this.match(8);\n\n    switch (this.state.type) {\n      case 121:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      case 120:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      case 76:\n      case 77:\n        {\n          const literal = this.parseBooleanLiteral(this.match(76));\n\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      default:\n        return {\n          type: \"invalid\",\n          pos: startPos\n        };\n    }\n  }\n\n  flowEnumMemberRaw() {\n    const pos = this.state.start;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(27) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      pos\n    };\n    return {\n      id,\n      init\n    };\n  }\n\n  flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n\n    if (explicitType === null) {\n      return;\n    }\n\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(pos, context);\n    }\n  }\n\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n\n      if (memberName === \"\") {\n        continue;\n      }\n\n      if (/^[a-z]/.test(memberName)) {\n        this.flowEnumErrorInvalidMemberName(id.start, {\n          enumName,\n          memberName\n        });\n      }\n\n      if (seenNames.has(memberName)) {\n        this.flowEnumErrorDuplicateMemberName(id.start, {\n          enumName,\n          memberName\n        });\n      }\n\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);\n          }\n\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);\n                break;\n\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);\n                break;\n\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n          enumName\n        });\n      }\n\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n          enumName\n        });\n      }\n\n      return initializedMembers;\n    }\n  }\n\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (this.eatContextual(92)) {\n      if (!tokenIsIdentifier(this.state.type)) {\n        throw this.flowEnumErrorInvalidExplicitType(this.state.start, {\n          enumName,\n          suppliedType: null\n        });\n      }\n\n      const {\n        value\n      } = this.state;\n      this.next();\n\n      if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n        this.flowEnumErrorInvalidExplicitType(this.state.start, {\n          enumName,\n          suppliedType: value\n        });\n      }\n\n      return value;\n    }\n\n    return null;\n  }\n\n  flowEnumBody(node, {\n    enumName,\n    nameLoc\n  }) {\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.flowEnumErrorInconsistentMemberValues(nameLoc, {\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), {\n      enumName: id.name,\n      nameLoc: id.start\n    });\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n\n    return false;\n  }\n\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n\n});\n\nconst entities = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\nconst JsxErrors = makeErrorTemplates({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: \"Expected corresponding JSX closing tag for <%0>.\",\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n}, ErrorCodes.SyntaxError, \"jsx\");\ntypes.j_oTag = new TokContext(\"<tag\");\ntypes.j_cTag = new TokContext(\"</tag\");\ntypes.j_expr = new TokContext(\"<tag>...</tag>\", true);\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsx = (superClass => class extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.exprAllowed) {\n              ++this.state.pos;\n              return this.finishToken(129);\n            }\n\n            return super.getTokenFromCode(ch);\n          }\n\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(128, out);\n\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n\n        case 62:\n        case 125:\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n\n      }\n    }\n  }\n\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(120, out);\n  }\n\n  jsxReadEntity() {\n    let str = \"\";\n    let count = 0;\n    let entity;\n    let ch = this.input[this.state.pos];\n    const startPos = ++this.state.pos;\n\n    while (this.state.pos < this.length && count++ < 10) {\n      ch = this.input[this.state.pos++];\n\n      if (ch === \";\") {\n        if (str[0] === \"#\") {\n          if (str[1] === \"x\") {\n            str = str.substr(2);\n\n            if (HEX_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 16));\n            }\n          } else {\n            str = str.substr(1);\n\n            if (DECIMAL_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 10));\n            }\n          }\n        } else {\n          entity = entities[str];\n        }\n\n        break;\n      }\n\n      str += ch;\n    }\n\n    if (!entity) {\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    return entity;\n  }\n\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n\n    return this.finishToken(127, this.input.slice(start, this.state.pos));\n  }\n\n  jsxParseIdentifier() {\n    const node = this.startNode();\n\n    if (this.match(127)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n\n  jsxParseNamespacedName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n\n  jsxParseElementName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startPos, startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n\n    return node;\n  }\n\n  jsxParseAttributeValue() {\n    let node;\n\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.next();\n        node = this.jsxParseExpressionContainer(node);\n\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(node.start, JsxErrors.AttributeIsEmpty);\n        }\n\n        return node;\n\n      case 129:\n      case 120:\n        return this.parseExprAtom();\n\n      default:\n        throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);\n    }\n  }\n\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n  }\n\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n\n  jsxParseExpressionContainer(node) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n\n  jsxParseAttribute() {\n    const node = this.startNode();\n\n    if (this.eat(5)) {\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(27) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n\n  jsxParseOpeningElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(130)) {\n      this.expect(130);\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n\n    while (!this.match(47) && !this.match(130)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n\n    node.attributes = attributes;\n    node.selfClosing = this.eat(47);\n    this.expect(130);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n\n  jsxParseClosingElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(130)) {\n      this.expect(130);\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    this.expect(130);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n\n  jsxParseElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n    let closingElement = null;\n\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 129:\n            startPos = this.state.start;\n            startLoc = this.state.startLoc;\n            this.next();\n\n            if (this.eat(47)) {\n              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n\n            children.push(this.jsxParseElementAt(startPos, startLoc));\n            break;\n\n          case 128:\n            children.push(this.parseExprAtom());\n            break;\n\n          case 5:\n            {\n              const node = this.startNode();\n              this.next();\n\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node));\n              }\n\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      if (isFragment(openingElement) && !isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n        }\n      }\n    }\n\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n\n    node.children = children;\n\n    if (this.isRelational(\"<\")) {\n      throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);\n    }\n\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n\n  jsxParseElement() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startPos, startLoc);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(128)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(129)) {\n      return this.jsxParseElement();\n    } else if (this.isRelational(\"<\") && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.finishToken(129);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  createLookaheadState(state) {\n    const lookaheadState = super.createLookaheadState(state);\n    lookaheadState.inPropertyName = state.inPropertyName;\n    return lookaheadState;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inPropertyName) return super.getTokenFromCode(code);\n    const context = this.curContext();\n\n    if (context === types.j_expr) {\n      return this.jsxReadToken();\n    }\n\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(130);\n      }\n\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n\n    if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(129);\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  updateContext(prevType) {\n    super.updateContext(prevType);\n    const {\n      context,\n      type\n    } = this.state;\n\n    if (type === 47 && prevType === 129) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.exprAllowed = false;\n    } else if (type === 129) {\n      context.push(types.j_expr, types.j_oTag);\n    } else if (type === 130) {\n      const out = context.pop();\n\n      if (out === types.j_oTag && prevType === 47 || out === types.j_cTag) {\n        context.pop();\n        this.state.exprAllowed = context[context.length - 1] === types.j_expr;\n      } else {\n        this.state.exprAllowed = true;\n      }\n    } else if (tokenIsKeyword(type) && (prevType === 16 || prevType === 18)) {\n      this.state.exprAllowed = false;\n    } else {\n      this.state.exprAllowed = tokenComesBeforeExpression(type);\n    }\n  }\n\n});\n\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.types = new Set();\n    this.enums = new Set();\n    this.constEnums = new Set();\n    this.classes = new Set();\n    this.exportOnlyBindings = new Set();\n  }\n\n}\n\nclass TypeScriptScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name, bindingType, pos) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.add(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        this.maybeExportDefined(scope, name);\n      }\n\n      scope.types.add(name);\n    }\n\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.has(name)) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.has(name);\n        return isConst !== wasConst;\n      }\n\n      return true;\n    }\n\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {\n      if (scope.lexical.has(name)) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(...arguments);\n  }\n\n  checkLocalExport(id) {\n    const topLevelScope = this.scopeStack[0];\n    const {\n      name\n    } = id;\n\n    if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\nconst TSErrors = makeErrorTemplates({\n  AbstractMethodHasImplementation: \"Method '%0' cannot have an implementation because it is marked abstract.\",\n  AbstractPropertyHasInitializer: \"Property '%0' cannot have an initializer because it is marked abstract.\",\n  AccesorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: \"'declare' is not allowed in %0ters.\",\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: \"Accessibility modifier already seen.\",\n  DuplicateModifier: \"Duplicate modifier: '%0'.\",\n  EmptyHeritageClauseType: \"'%0' list cannot be empty.\",\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  IncompatibleModifiers: \"'%0' modifier cannot be used with '%1' modifier.\",\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: \"Index signatures cannot have an accessibility modifier ('%0').\",\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InvalidModifierOnTypeMember: \"'%0' modifier cannot appear on a type member.\",\n  InvalidModifiersOrder: \"'%0' modifier must precede '%1' modifier.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  MixedLabeledAndUnlabeledElements: \"Tuple members must all have names or all not have names.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: \"Private elements cannot have an accessibility modifier ('%0').\",\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  SetAccesorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: \"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0.\"\n}, ErrorCodes.SyntaxError, \"typescript\");\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\n\nvar typescript = (superClass => class extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n\n  tsTokenCanFollowModifier() {\n    return (this.match(0) || this.match(5) || this.match(46) || this.match(21) || this.match(125) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return this.tsTokenCanFollowModifier();\n  }\n\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n    if (!tokenIsIdentifier(this.state.type)) {\n      return undefined;\n    }\n\n    const modifier = this.state.value;\n\n    if (allowedModifiers.indexOf(modifier) !== -1) {\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n\n    return undefined;\n  }\n\n  tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate, stopOnStartOfClassStaticBlock) {\n    const enforceOrder = (pos, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(pos, TSErrors.InvalidModifiersOrder, before, after);\n      }\n    };\n\n    const incompatible = (pos, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);\n      }\n    };\n\n    for (;;) {\n      const startPos = this.state.start;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\n      if (!modifier) break;\n\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);\n        } else {\n          enforceOrder(startPos, modifier, modifier, \"override\");\n          enforceOrder(startPos, modifier, modifier, \"static\");\n          enforceOrder(startPos, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else {\n        if (Object.hasOwnProperty.call(modified, modifier)) {\n          this.raise(startPos, TSErrors.DuplicateModifier, modifier);\n        } else {\n          enforceOrder(startPos, modifier, \"static\", \"readonly\");\n          enforceOrder(startPos, modifier, \"static\", \"override\");\n          enforceOrder(startPos, modifier, \"override\", \"readonly\");\n          enforceOrder(startPos, modifier, \"abstract\", \"override\");\n          incompatible(startPos, modifier, \"declare\", \"override\");\n          incompatible(startPos, modifier, \"static\", \"abstract\");\n        }\n\n        modified[modifier] = true;\n      }\n\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(startPos, errorTemplate, modifier);\n      }\n    }\n  }\n\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n\n      case \"HeritageClauseElement\":\n        return this.match(5);\n\n      case \"TupleElementTypes\":\n        return this.match(3);\n\n      case \"TypeParametersOrArguments\":\n        return this.isRelational(\">\");\n    }\n\n    throw new Error(\"Unreachable\");\n  }\n\n  tsParseList(kind, parseElement) {\n    const result = [];\n\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n\n    return result;\n  }\n\n  tsParseDelimitedList(kind, parseElement) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));\n  }\n\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {\n    const result = [];\n\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      const element = parseElement();\n\n      if (element == null) {\n        return undefined;\n      }\n\n      result.push(element);\n\n      if (this.eat(12)) {\n        continue;\n      }\n\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      if (expectSuccess) {\n        this.expect(12);\n      }\n\n      return undefined;\n    }\n\n    return result;\n  }\n\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expectRelational(\"<\");\n      }\n    }\n\n    const result = this.tsParseDelimitedList(kind, parseElement);\n\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expectRelational(\">\");\n    }\n\n    return result;\n  }\n\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(74);\n    this.expect(10);\n\n    if (!this.match(120)) {\n      this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);\n    }\n\n    node.argument = this.parseExprAtom();\n    this.expect(11);\n\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName(true);\n    }\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSImportType\");\n  }\n\n  tsParseEntityName(allowReservedWords) {\n    let entity = this.parseIdentifier();\n\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n\n    return entity;\n  }\n\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(false);\n\n    if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(78);\n\n    if (this.match(74)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName(true);\n    }\n\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n\n  tsParseTypeParameter() {\n    const node = this.startNode();\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(72);\n    node.default = this.tsEatThenParseType(27);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsTryParseTypeParameters() {\n    if (this.isRelational(\"<\")) {\n      return this.tsParseTypeParameters();\n    }\n  }\n\n  tsParseTypeParameters() {\n    const node = this.startNode();\n\n    if (this.isRelational(\"<\") || this.match(129)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this), false, true);\n\n    if (node.params.length === 0) {\n      this.raise(node.start, TSErrors.EmptyTypeParameters);\n    }\n\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n\n  tsTryNextParseConstantContext() {\n    if (this.lookahead().type === 66) {\n      this.next();\n      return this.tsParseTypeReference();\n    }\n\n    return null;\n  }\n\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(10);\n    signature.parameters = this.tsParseBindingListForSignature();\n\n    if (returnTokenRequired) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n\n  tsParseBindingListForSignature() {\n    return this.parseBindingList(11, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);\n      }\n\n      return pattern;\n    });\n  }\n\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n\n    return false;\n  }\n\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    const nodeAny = node;\n\n    if (this.match(10) || this.isRelational(\"<\")) {\n      if (readonly) {\n        this.raise(node.start, TSErrors.ReadonlyForMethodSignature);\n      }\n\n      const method = nodeAny;\n\n      if (method.kind && this.isRelational(\"<\")) {\n        this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);\n      }\n\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n\n      if (method.kind === \"get\") {\n        if (method.parameters.length > 0) {\n          this.raise(this.state.pos, ErrorMessages.BadGetterArity);\n\n          if (this.isThisParam(method.parameters[0])) {\n            this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method.parameters.length !== 1) {\n          this.raise(this.state.pos, ErrorMessages.BadSetterArity);\n        } else {\n          const firstParameter = method.parameters[0];\n\n          if (this.isThisParam(firstParameter)) {\n            this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);\n          }\n\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveOptionalParameter);\n          }\n\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveRestParameter);\n          }\n        }\n\n        if (method.typeAnnotation) {\n          this.raise(method.typeAnnotation.start, TSErrors.SetAccesorCannotHaveReturnType);\n        }\n      } else {\n        method.kind = \"method\";\n      }\n\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n\n  tsParseTypeMember() {\n    const node = this.startNode();\n\n    if (this.match(10) || this.isRelational(\"<\")) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n\n    if (this.match(68)) {\n      const id = this.startNode();\n      this.next();\n\n      if (this.match(10) || this.isRelational(\"<\")) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n\n    this.tsParseModifiers(node, [\"readonly\"], [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"], TSErrors.InvalidModifierOnTypeMember);\n    const idx = this.tsTryParseIndexSignature(node);\n\n    if (idx) {\n      return idx;\n    }\n\n    this.parsePropertyName(node, false);\n\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      this.parsePropertyName(node, false);\n    }\n\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n\n  tsIsStartOfMappedType() {\n    this.next();\n\n    if (this.eat(44)) {\n      return this.isContextual(109);\n    }\n\n    if (this.isContextual(109)) {\n      this.next();\n    }\n\n    if (!this.match(0)) {\n      return false;\n    }\n\n    this.next();\n\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n\n    this.next();\n    return this.match(49);\n  }\n\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsExpectThenParseType(49);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n\n    if (this.match(44)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(109);\n    } else if (this.eatContextual(109)) {\n      node.readonly = true;\n    }\n\n    this.expect(0);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(84) ? this.tsParseType() : null;\n    this.expect(3);\n\n    if (this.match(44)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    let labeledElements = null;\n    node.elementTypes.forEach(elementNode => {\n      var _labeledElements;\n\n      let {\n        type\n      } = elementNode;\n\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);\n      }\n\n      seenOptionalElement = seenOptionalElement || type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\";\n\n      if (type === \"TSRestType\") {\n        elementNode = elementNode.typeAnnotation;\n        type = elementNode.type;\n      }\n\n      const isLabeled = type === \"TSNamedTupleMember\";\n      labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;\n\n      if (labeledElements !== isLabeled) {\n        this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n\n  tsParseTupleElementType() {\n    const {\n      start: startPos,\n      startLoc\n    } = this.state;\n    const rest = this.eat(21);\n    let type = this.tsParseType();\n    const optional = this.eat(17);\n    const labeled = this.eat(14);\n\n    if (labeled) {\n      const labeledNode = this.startNodeAtNode(type);\n      labeledNode.optional = optional;\n\n      if (type.type === \"TSTypeReference\" && !type.typeParameters && type.typeName.type === \"Identifier\") {\n        labeledNode.label = type.typeName;\n      } else {\n        this.raise(type.start, TSErrors.InvalidTupleMemberLabel);\n        labeledNode.label = type;\n      }\n\n      labeledNode.elementType = this.tsParseType();\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n\n    if (rest) {\n      const restNode = this.startNodeAt(startPos, startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n\n    return type;\n  }\n\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n\n    this.tsFillSignature(19, node);\n    return this.finishNode(node, type);\n  }\n\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n\n    node.literal = (() => {\n      switch (this.state.type) {\n        case 121:\n        case 122:\n        case 120:\n        case 76:\n        case 77:\n          return this.parseExprAtom();\n\n        default:\n          throw this.unexpected();\n      }\n    })();\n\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = this.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n\n    if (this.isContextual(104) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 120:\n      case 121:\n      case 122:\n      case 76:\n      case 77:\n        return this.tsParseLiteralTypeNode();\n\n      case 44:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n\n          if (nextToken.type !== 121 && nextToken.type !== 122) {\n            throw this.unexpected();\n          }\n\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n\n        break;\n\n      case 69:\n        return this.tsParseThisTypeOrThisTypePredicate();\n\n      case 78:\n        return this.tsParseTypeQuery();\n\n      case 74:\n        return this.tsParseImportType();\n\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n      case 0:\n        return this.tsParseTupleType();\n\n      case 10:\n        return this.tsParseParenthesizedType();\n\n      case 22:\n        return this.tsParseTemplateLiteralType();\n\n      default:\n        {\n          const {\n            type\n          } = this.state;\n\n          if (tokenIsIdentifier(type) || type === 79 || type === 75) {\n            const nodeType = type === 79 ? \"TSVoidKeyword\" : type === 75 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n\n    throw this.unexpected();\n  }\n\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n\n    return type;\n  }\n\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n\n      default:\n        this.raise(node.start, TSErrors.UnexpectedReadonly);\n    }\n  }\n\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(103);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(103) ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();\n  }\n\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 40);\n  }\n\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 38);\n  }\n\n  tsIsStartOfFunctionType() {\n    if (this.isRelational(\"<\")) {\n      return true;\n    }\n\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(69)) {\n      this.next();\n      return true;\n    }\n\n    if (this.match(5)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(5)) {\n          ++braceStackCounter;\n        } else if (this.match(8)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    if (this.match(0)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(0)) {\n          ++braceStackCounter;\n        } else if (this.match(3)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(27)) {\n        return true;\n      }\n\n      if (this.match(11)) {\n        this.next();\n\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n\n      if (asserts && this.match(69)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : undefined;\n  }\n\n  tsTryParseTypeAnnotation() {\n    return this.match(14) ? this.tsParseTypeAnnotation() : undefined;\n  }\n\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n\n    if (this.isContextual(104) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 97) {\n      return false;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.next();\n\n    if (!tokenIsIdentifier(this.state.type) && !this.match(69)) {\n      return false;\n    }\n\n    if (containsEsc) {\n      this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, \"asserts\");\n    }\n\n    return true;\n  }\n\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n\n    if (this.hasPrecedingLineBreak() || !this.eat(72)) {\n      return type;\n    }\n\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsParseNonConditionalType();\n    this.expect(17);\n    node.trueType = this.tsParseType();\n    this.expect(14);\n    node.falseType = this.tsParseType();\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n\n  isAbstractConstructorSignature() {\n    return this.isContextual(111) && this.lookahead().type === 68;\n  }\n\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n\n    if (this.match(68)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n\n    return this.tsParseUnionTypeOrHigher();\n  }\n\n  tsParseTypeAssertion() {\n    const node = this.startNode();\n\n    const _const = this.tsTryNextParseConstantContext();\n\n    node.typeAnnotation = _const || this.tsNextThenParseType();\n    this.expectRelational(\">\");\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n\n  tsParseHeritageClause(descriptor) {\n    const originalStart = this.state.start;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n\n    if (!delimitedList.length) {\n      this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);\n    }\n\n    return delimitedList;\n  }\n\n  tsParseExpressionWithTypeArguments() {\n    const node = this.startNode();\n    node.expression = this.tsParseEntityName(false);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n  }\n\n  tsParseInterfaceDeclaration(node) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkLVal(node.id, \"typescript interface declaration\", BIND_TS_INTERFACE);\n    } else {\n      node.id = null;\n      this.raise(this.state.start, TSErrors.MissingInterfaceName);\n    }\n\n    node.typeParameters = this.tsTryParseTypeParameters();\n\n    if (this.eat(72)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript type alias\", BIND_TS_TYPE);\n    node.typeParameters = this.tsTryParseTypeParameters();\n    node.typeAnnotation = this.tsInType(() => {\n      this.expect(27);\n\n      if (this.isContextual(102) && this.lookahead().type !== 16) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(120) ? this.parseExprAtom() : this.parseIdentifier(true);\n\n    if (this.eat(27)) {\n      node.initializer = this.parseMaybeAssignAllowIn();\n    }\n\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n\n  tsParseEnumDeclaration(node, isConst) {\n    if (isConst) node.const = true;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript enum declaration\", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(5);\n    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n\n    if (!nested) {\n      this.checkLVal(node.id, \"module or namespace declaration\", BIND_TS_NAMESPACE);\n    }\n\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(100)) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(120)) {\n      node.id = this.parseExprAtom();\n    } else {\n      this.unexpected();\n    }\n\n    if (this.match(5)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"import equals declaration\", BIND_LEXICAL);\n    this.expect(27);\n    const moduleReference = this.tsParseModuleReference();\n\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);\n    }\n\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n\n  tsIsExternalModuleReference() {\n    return this.isContextual(107) && this.lookaheadCharCode() === 40;\n  }\n\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(107);\n    this.expect(10);\n\n    if (!this.match(120)) {\n      throw this.unexpected();\n    }\n\n    node.expression = this.parseExprAtom();\n    this.expect(11);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n\n    let starttype = this.state.type;\n    let kind;\n\n    if (this.isContextual(90)) {\n      starttype = 65;\n      kind = \"let\";\n    }\n\n    return this.tsInAmbientContext(() => {\n      switch (starttype) {\n        case 59:\n          nany.declare = true;\n          return this.parseFunctionStatement(nany, false, true);\n\n        case 71:\n          nany.declare = true;\n          return this.parseClass(nany, true, false);\n\n        case 66:\n          if (this.match(66) && this.isLookaheadContextual(\"enum\")) {\n            this.expect(66);\n            this.expectContextual(113);\n            return this.tsParseEnumDeclaration(nany, true);\n          }\n\n        case 65:\n          kind = kind || this.state.value;\n          return this.parseVarStatement(nany, kind);\n\n        case 100:\n          return this.tsParseAmbientExternalModuleDeclaration(nany);\n\n        default:\n          {\n            if (tokenIsIdentifier(starttype)) {\n              return this.tsParseDeclaration(nany, this.state.value, true);\n            }\n          }\n      }\n    });\n  }\n\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true);\n  }\n\n  tsParseExpressionStatement(node, expr) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n\n          break;\n        }\n\n      case \"global\":\n        if (this.match(5)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          this.prodParam.enter(PARAM);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n\n        break;\n\n      default:\n        return this.tsParseDeclaration(node, expr.name, false);\n    }\n  }\n\n  tsParseDeclaration(node, value, next) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(71) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node);\n        }\n\n        break;\n\n      case \"enum\":\n        if (next || tokenIsIdentifier(this.state.type)) {\n          if (next) this.next();\n          return this.tsParseEnumDeclaration(node, false);\n        }\n\n        break;\n\n      case \"interface\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseInterfaceDeclaration(node);\n        }\n\n        break;\n\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(120)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n\n        break;\n\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n\n        break;\n    }\n  }\n\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n\n    return !this.isLineTerminator();\n  }\n\n  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n    if (!this.isRelational(\"<\")) {\n      return undefined;\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    if (!res) {\n      return undefined;\n    }\n\n    return this.parseArrowExpression(res, null, true);\n  }\n\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expectRelational(\"<\");\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n\n    if (node.params.length === 0) {\n      this.raise(node.start, TSErrors.EmptyTypeArguments);\n    }\n\n    this.expectRelational(\">\");\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n    let override = false;\n\n    if (allowModifiers !== undefined) {\n      const modified = {};\n      this.tsParseModifiers(modified, [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]);\n      accessibility = modified.accessibility;\n      override = modified.override;\n      readonly = modified.readonly;\n\n      if (allowModifiers === false && (accessibility || readonly || override)) {\n        this.raise(startPos, TSErrors.UnexpectedParameterModifier);\n      }\n    }\n\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startPos, startLoc);\n\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);\n      }\n\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" ? \"TSDeclareMethod\" : undefined;\n\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      this.finishNode(node, bodilessType);\n      return;\n    }\n\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);\n\n      if (node.declare) {\n        super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n        return;\n      }\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkLVal(node.id, \"function name\", BIND_TS_AMBIENT);\n    } else {\n      super.registerFunctionStatementId(...arguments);\n    }\n  }\n\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);\n      }\n    });\n  }\n\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n\n  parseArrayLike(...args) {\n    const node = super.parseArrayLike(...args);\n\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(32)) {\n      this.state.exprAllowed = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startPos, startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n\n    let isOptionalCall = false;\n\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n\n    if (this.isRelational(\"<\")) {\n      let missingParenErrorPos;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        const typeArguments = this.tsParseTypeArguments();\n\n        if (typeArguments) {\n          if (isOptionalCall && !this.match(10)) {\n            missingParenErrorPos = this.state.pos;\n            this.unexpected();\n          }\n\n          if (!noCalls && this.eat(10)) {\n            node.arguments = this.parseCallExpressionArguments(11, false);\n            this.tsCheckForInvalidTypeCasts(node.arguments);\n            node.typeParameters = typeArguments;\n\n            if (state.optionalChainMember) {\n              node.optional = isOptionalCall;\n            }\n\n            return this.finishCallExpression(node, state.optionalChainMember);\n          } else if (this.match(22)) {\n            const result = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n            result.typeParameters = typeArguments;\n            return result;\n          }\n        }\n\n        this.unexpected();\n      });\n\n      if (missingParenErrorPos) {\n        this.unexpected(missingParenErrorPos, 10);\n      }\n\n      if (result) return result;\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n  }\n\n  parseNewArguments(node) {\n    if (this.isRelational(\"<\")) {\n      const typeParameters = this.tsTryParseAndCatch(() => {\n        const args = this.tsParseTypeArguments();\n        if (!this.match(10)) this.unexpected();\n        return args;\n      });\n\n      if (typeParameters) {\n        node.typeParameters = typeParameters;\n      }\n    }\n\n    super.parseNewArguments(node);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    if (tokenOperatorPrecedence(49) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(84)) {\n      const node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.expression = left;\n\n      const _const = this.tsTryNextParseConstantContext();\n\n      if (_const) {\n        node.typeAnnotation = _const;\n      } else {\n        node.typeAnnotation = this.tsNextThenParseType();\n      }\n\n      this.finishNode(node, \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n    }\n\n    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}\n\n  checkDuplicateExports() {}\n\n  parseImport(node) {\n    node.importKind = \"value\";\n\n    if (tokenIsIdentifier(this.state.type) || this.match(46) || this.match(5)) {\n      let ahead = this.lookahead();\n\n      if (this.isContextual(117) && ahead.type !== 12 && ahead.type !== 88 && ahead.type !== 27) {\n        node.importKind = \"type\";\n        this.next();\n        ahead = this.lookahead();\n      }\n\n      if (tokenIsIdentifier(this.state.type) && ahead.type === 27) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n    }\n\n    const importNode = super.parseImport(node);\n\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(importNode.start, TSErrors.TypeImportCannotSpecifyDefaultAndNamed);\n    }\n\n    return importNode;\n  }\n\n  parseExport(node) {\n    if (this.match(74)) {\n      this.next();\n\n      if (this.isContextual(117) && this.lookaheadCharCode() !== 61) {\n        node.importKind = \"type\";\n        this.next();\n      } else {\n        node.importKind = \"value\";\n      }\n\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(27)) {\n      const assign = node;\n      assign.expression = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(84)) {\n      const decl = node;\n      this.expectContextual(115);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      if (this.isContextual(117) && this.lookahead().type === 5) {\n        this.next();\n        node.exportKind = \"type\";\n      } else {\n        node.exportKind = \"value\";\n      }\n\n      return super.parseExport(node);\n    }\n  }\n\n  isAbstractClass() {\n    return this.isContextual(111) && this.lookahead().type === 71;\n  }\n\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      this.parseClass(cls, true, true);\n      return cls;\n    }\n\n    if (this.match(116)) {\n      const interfaceNode = this.startNode();\n      this.next();\n      const result = this.tsParseInterfaceDeclaration(interfaceNode);\n      if (result) return result;\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseStatementContent(context, topLevel) {\n    if (this.state.type === 66) {\n      const ahead = this.lookahead();\n\n      if (ahead.type === 113) {\n        const node = this.startNode();\n        this.next();\n        this.expectContextual(113);\n        return this.tsParseEnumDeclaration(node, true);\n      }\n    }\n\n    return super.parseStatementContent(context, topLevel);\n  }\n\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n\n      return !!member[modifier];\n    });\n  }\n\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(95) && this.lookaheadCharCode() === 123;\n  }\n\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers(member, modifiers, undefined, undefined, true);\n\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(this.state.pos, TSErrors.StaticBlockCannotHaveModifier);\n        }\n\n        this.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n\n    if (idx) {\n      classBody.body.push(idx);\n\n      if (member.abstract) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAbstract);\n      }\n\n      if (member.accessibility) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);\n      }\n\n      if (member.declare) {\n        this.raise(member.start, TSErrors.IndexSignatureHasDeclare);\n      }\n\n      if (member.override) {\n        this.raise(member.start, TSErrors.IndexSignatureHasOverride);\n      }\n\n      return;\n    }\n\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);\n    }\n\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(member.start, TSErrors.OverrideNotInSubClass);\n      }\n    }\n\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);\n    }\n\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n    return decl || super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n\n  parseConditional(expr, startPos, startLoc, refExpressionErrors) {\n    if (!this.state.maybeInArrowParameters || !this.match(17)) {\n      return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);\n    }\n\n    const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));\n\n    if (!result.node) {\n      if (result.error) {\n        super.setOptionalParametersError(refExpressionErrors, result.error);\n      }\n\n      return expr;\n    }\n\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  parseExportDeclaration(node) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(112);\n\n    if (isDeclare && (this.isContextual(112) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);\n    }\n\n    let declaration;\n\n    if (tokenIsIdentifier(this.state.type)) {\n      declaration = this.tsTryParseExportDeclaration();\n    }\n\n    if (!declaration) {\n      declaration = super.parseExportDeclaration(node);\n    }\n\n    if (declaration && (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare)) {\n      node.exportKind = \"type\";\n    }\n\n    if (declaration && isDeclare) {\n      this.resetStartLocation(declaration, startPos, startLoc);\n      declaration.declare = true;\n    }\n\n    return declaration;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    if ((!isStatement || optionalId) && this.isContextual(101)) {\n      return;\n    }\n\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(32)) {\n      node.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n\n    if (this.state.isAmbientContext && this.match(27)) {\n      this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);\n    }\n\n    if (node.abstract && this.match(27)) {\n      const {\n        key\n      } = node;\n      this.raise(this.state.start, TSErrors.AbstractPropertyHasInitializer, key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(node.start, TSErrors.PrivateElementHasAbstract);\n    }\n\n    if (node.accessibility) {\n      this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);\n    }\n\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n\n    if (typeParameters && isConstructor) {\n      this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);\n    }\n\n    if (method.declare && (method.kind === \"get\" || method.kind === \"set\")) {\n      this.raise(method.start, TSErrors.DeclareAccessor, method.kind);\n    }\n\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.tsParseTypeArguments();\n    }\n\n    if (this.eatContextual(101)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n\n  parseObjPropValue(prop, ...args) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    super.parseObjPropValue(prop, ...args);\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (decl.id.type === \"Identifier\" && this.eat(32)) {\n      decl.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  parseMaybeAssign(...args) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;\n\n    let state;\n    let jsx;\n    let typeCast;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(129) || this.isRelational(\"<\"))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n\n      if (context[context.length - 1] === types.j_oTag) {\n        context.length -= 2;\n      } else if (context[context.length - 1] === types.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.isRelational(\"<\")) {\n      return super.parseMaybeAssign(...args);\n    }\n\n    let typeParameters;\n    state = state || this.state.clone();\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(...args);\n\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) return arrow.node;\n\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n\n    if (arrow.node) {\n      this.state = arrow.failState;\n      return arrow.node;\n    }\n\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n\n    if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;\n    throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    if (!this.hasPlugin(\"jsx\") && this.isRelational(\"<\")) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refExpressionErrors);\n    }\n  }\n\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n\n    return super.parseArrow(node);\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\" && !this.state.isAmbientContext && !this.state.inType) {\n        this.raise(param.start, TSErrors.PatternIsOptional);\n      }\n\n      param.optional = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n\n      case \"TSParameterProperty\":\n        return true;\n\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return super.toAssignable(this.typeCastToParameter(node), isLHS);\n\n      case \"TSParameterProperty\":\n        return super.toAssignable(node, isLHS);\n\n      case \"ParenthesizedExpression\":\n        return this.toAssignableParenthesizedExpression(node, isLHS);\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        node.expression = this.toAssignable(node.expression, isLHS);\n        return node;\n\n      default:\n        return super.toAssignable(node, isLHS);\n    }\n  }\n\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        node.expression = this.toAssignable(node.expression, isLHS);\n        return node;\n\n      default:\n        return super.toAssignable(node, isLHS);\n    }\n  }\n\n  checkLVal(expr, contextDescription, ...args) {\n    var _expr$extra2;\n\n    switch (expr.type) {\n      case \"TSTypeCastExpression\":\n        return;\n\n      case \"TSParameterProperty\":\n        this.checkLVal(expr.parameter, \"parameter property\", ...args);\n        return;\n\n      case \"TSAsExpression\":\n      case \"TSTypeAssertion\":\n        if (!args[0] && contextDescription !== \"parenthesized expression\" && !((_expr$extra2 = expr.extra) != null && _expr$extra2.parenthesized)) {\n          this.raise(expr.start, ErrorMessages.InvalidLhs, contextDescription);\n          break;\n        }\n\n        this.checkLVal(expr.expression, \"parenthesized expression\", ...args);\n        return;\n\n      case \"TSNonNullExpression\":\n        this.checkLVal(expr.expression, contextDescription, ...args);\n        return;\n\n      default:\n        super.checkLVal(expr, contextDescription, ...args);\n        return;\n    }\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 69:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsParseTypeArguments();\n\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n\n      this.unexpected(this.state.start, 10);\n    }\n\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n    } else {\n      super.checkCommaAfterRest(close);\n    }\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(32) || this.match(14) || super.isClassProperty();\n  }\n\n  parseMaybeDefault(...args) {\n    const node = super.parseMaybeDefault(...args);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);\n    }\n\n    return node;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(42, 1);\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  reScan_lt_gt() {\n    if (this.match(42)) {\n      const code = this.input.charCodeAt(this.state.start);\n\n      if (code === 60 || code === 62) {\n        this.state.pos -= 1;\n        this.readToken_lt_gt(code);\n      }\n    }\n  }\n\n  toAssignableList(exprList) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if (!expr) continue;\n\n      switch (expr.type) {\n        case \"TSTypeCastExpression\":\n          exprList[i] = this.typeCastToParameter(expr);\n          break;\n\n        case \"TSAsExpression\":\n        case \"TSTypeAssertion\":\n          if (!this.state.maybeInArrowParameters) {\n            exprList[i] = this.typeCastToParameter(expr);\n          } else {\n            this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);\n          }\n\n          break;\n      }\n    }\n\n    return super.toAssignableList(...arguments);\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n\n    return super.shouldParseArrow(params);\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n\n    return param;\n  }\n\n  tsInAmbientContext(cb) {\n    const oldIsAmbientContext = this.state.isAmbientContext;\n    this.state.isAmbientContext = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n    }\n  }\n\n  parseClass(node, ...args) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n\n    try {\n      return super.parseClass(node, ...args);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n\n  tsParseAbstractDeclaration(node) {\n    if (this.match(71)) {\n      node.abstract = true;\n      return this.parseClass(node, true, false);\n    } else if (this.isContextual(116)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(node.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);\n        this.next();\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 71);\n    }\n  }\n\n  parseMethod(...args) {\n    const method = super.parseMethod(...args);\n\n    if (method.abstract) {\n      const hasBody = this.hasPlugin(\"estree\") ? !!method.value.body : !!method.body;\n\n      if (hasBody) {\n        const {\n          key\n        } = method;\n        this.raise(method.start, TSErrors.AbstractMethodHasImplementation, key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);\n      }\n    }\n\n    return method;\n  }\n\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n\n    return super.parse();\n  }\n\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n\n    return super.getExpression();\n  }\n\n});\n\nconst PlaceHolderErrors = makeErrorTemplates({\n  ClassNameIsRequired: \"A class name is required.\"\n}, ErrorCodes.SyntaxError);\nvar placeholders = (superClass => class extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(131)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      this.expect(131);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(131, 2);\n    }\n\n    return super.getTokenFromCode(...arguments);\n  }\n\n  parseExprAtom() {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments);\n  }\n\n  parseIdentifier() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(...arguments);\n  }\n\n  checkReservedWord(word) {\n    if (word !== undefined) super.checkReservedWord(...arguments);\n  }\n\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments);\n  }\n\n  checkLVal(expr) {\n    if (expr.type !== \"Placeholder\") super.checkLVal(...arguments);\n  }\n\n  toAssignable(node) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n      return node;\n    }\n\n    return super.toAssignable(...arguments);\n  }\n\n  isLet(context) {\n    if (super.isLet(context)) {\n      return true;\n    }\n\n    if (!this.isContextual(90)) {\n      return false;\n    }\n\n    if (context) return false;\n    const nextToken = this.lookahead();\n\n    if (nextToken.type === 131) {\n      return true;\n    }\n\n    return false;\n  }\n\n  verifyBreakContinue(node) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(...arguments);\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(...arguments);\n    }\n\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = this.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n\n  parseBlock() {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(...arguments);\n  }\n\n  parseFunctionId() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(...arguments);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n\n    if (placeholder) {\n      if (this.match(72) || this.match(131) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n\n    this.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n\n  parseExport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(...arguments);\n\n    if (!this.isContextual(88) && !this.match(12)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(56)) {\n      const next = this.nextTokenStart();\n\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(131), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n\n    return super.maybeParseExportDefaultSpecifier(...arguments);\n  }\n\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(...arguments);\n    node.specifiers = [];\n\n    if (!this.isContextual(88) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    this.finishNode(specifier, \"ImportDefaultSpecifier\");\n    node.specifiers.push(specifier);\n\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n\n    this.expectContextual(88);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource(...arguments);\n  }\n\n});\n\nvar v8intrinsic = (superClass => class extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(45)) {\n      const v8IntrinsicStart = this.state.start;\n      const node = this.startNode();\n      this.next();\n\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName(this.state.start);\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n\n      this.unexpected(v8IntrinsicStart);\n    }\n  }\n\n  parseExprAtom() {\n    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n  }\n\n});\n\nfunction hasPlugin(plugins, name) {\n  return plugins.some(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" + \" whose value must be a boolean. If you are migrating from\" + \" Babylon/Babel 6 or want to use the old decorators proposal, you\" + \" should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n\n    const tupleSyntaxIsHash = hasPlugin(plugins, \"recordAndTuple\") && getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\") === \"hash\";\n\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n\n      const topicToken = getPluginOption(plugins, \"pipelineOperator\", \"topicToken\");\n\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n    }\n  }\n\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    {\n      if (hasPlugin(plugins, \"importAssertions\")) {\n        throw new Error(\"Cannot combine importAssertions and moduleAttributes plugins.\");\n      }\n\n      const moduleAttributesVerionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n\n      if (moduleAttributesVerionPluginOption !== \"may-2020\") {\n        throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n      }\n    }\n  }\n\n  if (hasPlugin(plugins, \"recordAndTuple\") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n\n  if (hasPlugin(plugins, \"asyncDoExpressions\") && !hasPlugin(plugins, \"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\n\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false,\n  attachComment: true\n};\nfunction getOptions(opts) {\n  const options = {};\n\n  for (const key of Object.keys(defaultOptions)) {\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\n\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n\n    let parenthesized = undefined;\n\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n        }\n      } else {\n        this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingComma) {\n            this.raiseRestNotLast(node.extra.trailingComma);\n          }\n        }\n\n        break;\n\n      case \"ObjectProperty\":\n        this.toAssignable(node.value, isLHS);\n        break;\n\n      case \"SpreadElement\":\n        {\n          this.checkToRestConversion(node);\n          node.type = \"RestElement\";\n          const arg = node.argument;\n          this.toAssignable(arg, isLHS);\n          break;\n        }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n\n    return node;\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      const error = prop.kind === \"get\" || prop.kind === \"set\" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;\n      this.raise(prop.key.start, error);\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raiseRestNotLast(prop.start);\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaPos, isLHS) {\n    let end = exprList.length;\n\n    if (end) {\n      const last = exprList[end - 1];\n\n      if ((last == null ? void 0 : last.type) === \"RestElement\") {\n        --end;\n      } else if ((last == null ? void 0 : last.type) === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        let arg = last.argument;\n        this.toAssignable(arg, isLHS);\n        arg = unwrapParenthesizedExpression(arg);\n\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\" && arg.type !== \"ObjectPattern\") {\n          this.unexpected(arg.start);\n        }\n\n        if (trailingCommaPos) {\n          this.raiseTrailingCommaAfterRest(trailingCommaPos);\n        }\n\n        --end;\n      }\n    }\n\n    for (let i = 0; i < end; i++) {\n      const elt = exprList[i];\n\n      if (elt) {\n        this.toAssignable(elt, isLHS);\n\n        if (elt.type === \"RestElement\") {\n          this.raiseRestNotLast(elt.start);\n        }\n      }\n    }\n\n    return exprList;\n  }\n\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  parseSpread(refExpressionErrors, refNeedsArrowPos) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case 5:\n        return this.parseObjectLike(8, true);\n    }\n\n    return this.parseIdentifier();\n  }\n\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        this.checkCommaAfterRest(closeCharCode);\n        this.expect(close);\n        break;\n      } else {\n        const decorators = [];\n\n        if (this.match(24) && this.hasPlugin(\"decorators\")) {\n          this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);\n        }\n\n        while (this.match(24)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    var _startLoc, _startPos, _left;\n\n    startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;\n    startPos = (_startPos = startPos) != null ? _startPos : this.state.start;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(27)) return left;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  checkLVal(expr, contextDescription, bindingType = BIND_NONE, checkClashes, disallowLetBinding, strictModeChanged = false) {\n    switch (expr.type) {\n      case \"Identifier\":\n        {\n          const {\n            name\n          } = expr;\n\n          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {\n            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);\n          }\n\n          if (checkClashes) {\n            if (checkClashes.has(name)) {\n              this.raise(expr.start, ErrorMessages.ParamDupe);\n            } else {\n              checkClashes.add(name);\n            }\n          }\n\n          if (disallowLetBinding && name === \"let\") {\n            this.raise(expr.start, ErrorMessages.LetInLexicalBinding);\n          }\n\n          if (!(bindingType & BIND_NONE)) {\n            this.scope.declareName(name, bindingType, expr.start);\n          }\n\n          break;\n        }\n\n      case \"MemberExpression\":\n        if (bindingType !== BIND_NONE) {\n          this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);\n        }\n\n        break;\n\n      case \"ObjectPattern\":\n        for (let prop of expr.properties) {\n          if (this.isObjectProperty(prop)) prop = prop.value;else if (this.isObjectMethod(prop)) continue;\n          this.checkLVal(prop, \"object destructuring pattern\", bindingType, checkClashes, disallowLetBinding);\n        }\n\n        break;\n\n      case \"ArrayPattern\":\n        for (const elem of expr.elements) {\n          if (elem) {\n            this.checkLVal(elem, \"array destructuring pattern\", bindingType, checkClashes, disallowLetBinding);\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, \"assignment pattern\", bindingType, checkClashes);\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, \"rest element\", bindingType, checkClashes);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(expr.expression, \"parenthesized expression\", bindingType, checkClashes);\n        break;\n\n      default:\n        {\n          this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);\n        }\n    }\n  }\n\n  checkToRestConversion(node) {\n    if (node.argument.type !== \"Identifier\" && node.argument.type !== \"MemberExpression\") {\n      this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);\n    }\n  }\n\n  checkCommaAfterRest(close) {\n    if (this.match(12)) {\n      if (this.lookaheadCharCode() === close) {\n        this.raiseTrailingCommaAfterRest(this.state.start);\n      } else {\n        this.raiseRestNotLast(this.state.start);\n      }\n    }\n  }\n\n  raiseRestNotLast(pos) {\n    throw this.raise(pos, ErrorMessages.ElementAfterRest);\n  }\n\n  raiseTrailingCommaAfterRest(pos) {\n    this.raise(pos, ErrorMessages.RestTrailingComma);\n  }\n\n}\n\nconst invalidHackPipeBodies = new Map([[\"ArrowFunctionExpression\", \"arrow function\"], [\"AssignmentExpression\", \"assignment\"], [\"ConditionalExpression\", \"conditional\"], [\"YieldExpression\", \"yield\"]]);\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(key.start, ErrorMessages.RecordNoProto);\n        return;\n      }\n\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProto === -1) {\n            refExpressionErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raise(key.start, ErrorMessages.DuplicateProto);\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n\n    if (!this.match(126)) {\n      this.unexpected();\n    }\n\n    this.finalizeRemainingComments();\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n\n    return expr;\n  }\n\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  parseExpressionBase(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n\n    if (this.match(12)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n\n  setOptionalParametersError(refExpressionErrors, resultError) {\n    var _resultError$pos;\n\n    refExpressionErrors.optionalParameters = (_resultError$pos = resultError == null ? void 0 : resultError.pos) != null ? _resultError$pos : this.state.start;\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    if (this.isContextual(96)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n\n    const {\n      type\n    } = this.state;\n\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(27)) {\n        node.left = this.toAssignable(left, true);\n        refExpressionErrors.doubleProto = -1;\n      } else {\n        node.left = left;\n      }\n\n      if (refExpressionErrors.shorthandAssign >= node.left.start) {\n        refExpressionErrors.shorthandAssign = -1;\n      }\n\n      this.checkLVal(left, \"assignment expression\");\n      this.next();\n      node.right = this.parseMaybeAssign();\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  parseMaybeConditional(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);\n  }\n\n  parseConditional(expr, startPos, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(125) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n\n  parseExprOps(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n      const {\n        start\n      } = left;\n\n      if (minPrec >= tokenOperatorPrecedence(49) || !this.prodParam.hasIn || !this.match(49)) {\n        this.raise(start, ErrorMessages.PrivateInExpectedIn, value);\n      }\n\n      this.classScope.usePrivateName(value, start);\n    }\n\n    const op = this.state.type;\n\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(49))) {\n      let prec = tokenOperatorPrecedence(op);\n\n      if (prec > minPrec) {\n        if (op === 34) {\n          this.expectPlugin(\"pipelineOperator\");\n\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n\n          this.checkPipelineAtInfixOperator(left, leftStartPos);\n        }\n\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 36 || op === 37;\n        const coalesce = op === 35;\n\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(37);\n        }\n\n        this.next();\n\n        if (op === 34 && this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"minimal\") {\n          if (this.state.type === 87 && this.prodParam.hasAwait) {\n            throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n\n        if (coalesce && (nextOp === 36 || nextOp === 37) || logical && nextOp === 35) {\n          throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);\n        }\n\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n      }\n    }\n\n    return left;\n  }\n\n  parseExprOpRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    switch (op) {\n      case 34:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(96)) {\n                throw this.raise(this.state.start, ErrorMessages.PipeBodyIsTighter, this.state.value);\n              }\n\n              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  parseExprOpBaseRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n\n  parseHackPipeBody() {\n    var _body$extra;\n\n    const {\n      start\n    } = this.state;\n    const body = this.parseMaybeAssign();\n\n    if (invalidHackPipeBodies.has(body.type) && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(start, ErrorMessages.PipeUnparenthesizedBody, invalidHackPipeBodies.get(body.type));\n    }\n\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(start, ErrorMessages.PipeTopicUnused);\n    }\n\n    return body;\n  }\n\n  checkExponentialAfterUnary(node) {\n    if (this.match(48)) {\n      this.raise(node.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);\n    }\n  }\n\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(87);\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startPos, startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n\n    const update = this.match(31);\n    const node = this.startNode();\n\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(63)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      const isDelete = this.match(80);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(node.start, ErrorMessages.StrictDelete);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(node.start, ErrorMessages.DeletePrivateField);\n        }\n      }\n\n      if (!update) {\n        if (!sawUnary) this.checkExponentialAfterUnary(node);\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(45);\n\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(startPos, ErrorMessages.AwaitNotInAsyncContext);\n        return this.parseAwait(startPos, startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      this.checkLVal(node.argument, \"prefix operation\");\n      return this.finishNode(node, \"UpdateExpression\");\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.checkLVal(expr, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(node, \"UpdateExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprSubscripts(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n\n    return base;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!noCalls && this.eat(15)) {\n      return this.parseBind(base, startPos, startLoc, noCalls, state);\n    } else if (this.match(22)) {\n      return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n    }\n\n    let optional = false;\n\n    if (this.match(18)) {\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startPos, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n\n  parseMember(base, startPos, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.computed = computed;\n    const privateName = !computed && this.match(125) && this.state.value;\n    const property = computed ? this.parseExpression() : privateName ? this.parsePrivateName() : this.parseIdentifier(true);\n\n    if (privateName !== false) {\n      if (node.object.type === \"Super\") {\n        this.raise(startPos, ErrorMessages.SuperPrivateField);\n      }\n\n      this.classScope.usePrivateName(privateName, property.start);\n    }\n\n    node.property = property;\n\n    if (computed) {\n      this.expect(3);\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  parseBind(base, startPos, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n  }\n\n  parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    let node = this.startNodeAt(startPos, startLoc);\n    node.callee = base;\n\n    if (state.maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(11);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(11, base.type === \"Import\", base.type !== \"Super\", node, refExpressionErrors);\n    }\n\n    this.finishCallExpression(node, state.optionalChainMember);\n\n    if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);\n    } else {\n      if (state.maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n\n      this.toReferencedArguments(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  parseTaggedTemplateExpression(base, startPos, startLoc, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n\n    if (state.optionalChainMember) {\n      this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);\n    }\n\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectPlugin(\"importAssertions\");\n          }\n        }\n      }\n\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? \"one or two arguments\" : \"one argument\");\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);\n          }\n        }\n      }\n    }\n\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n\n  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);\n          }\n\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);\n\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n\n    return node;\n  }\n\n  parseNoCallExpr() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    const {\n      type\n    } = this.state;\n\n    switch (type) {\n      case 70:\n        return this.parseSuper();\n\n      case 74:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(16)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        if (!this.match(10)) {\n          this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case 69:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case 81:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n\n      case 47:\n      case 29:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n\n      case 121:\n        return this.parseNumericLiteral(this.state.value);\n\n      case 122:\n        return this.parseBigIntLiteral(this.state.value);\n\n      case 123:\n        return this.parseDecimalLiteral(this.state.value);\n\n      case 120:\n        return this.parseStringLiteral(this.state.value);\n\n      case 75:\n        return this.parseNullLiteral();\n\n      case 76:\n        return this.parseBooleanLiteral(true);\n\n      case 77:\n        return this.parseBooleanLiteral(false);\n\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n\n      case 2:\n      case 1:\n        {\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true, refExpressionErrors);\n        }\n\n      case 0:\n        {\n          return this.parseArrayLike(3, true, false, refExpressionErrors);\n        }\n\n      case 6:\n      case 7:\n        {\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true, refExpressionErrors);\n        }\n\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n\n      case 59:\n        return this.parseFunctionOrFunctionSent();\n\n      case 24:\n        this.parseDecorators();\n\n      case 71:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case 68:\n        return this.parseNewOrNewTarget();\n\n      case 22:\n        return this.parseTemplate(false);\n\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(callee.start, ErrorMessages.UnsupportedBind);\n          }\n        }\n\n      case 125:\n        {\n          this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, this.state.value);\n          return this.parsePrivateName();\n        }\n\n      case 30:\n        if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"hack\" && this.getPluginOption(\"pipelineOperator\", \"topicToken\") === \"%\") {\n          this.state.value = \"%\";\n          this.state.type = 45;\n          this.state.pos--;\n          this.state.end--;\n          this.state.endLoc.column--;\n        } else {\n          throw this.unexpected();\n        }\n\n      case 45:\n      case 25:\n        {\n          const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n          if (pipeProposal) {\n            node = this.startNode();\n            const start = this.state.start;\n            const tokenType = this.state.type;\n            this.next();\n            return this.finishTopicReference(node, start, pipeProposal, tokenType);\n          }\n        }\n\n      case 42:\n        {\n          if (this.state.value === \"<\") {\n            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n\n            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n              this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n            }\n          }\n        }\n\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(114) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {\n            return this.parseModuleExpression();\n          }\n\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n\n            if (type === 59) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseFunction(this.startNodeAtNode(id), undefined, true);\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 81) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n\n          return id;\n        } else {\n          throw this.unexpected();\n        }\n\n    }\n  }\n\n  finishTopicReference(node, start, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, start, tokenType)) {\n      let nodeType;\n\n      if (pipeProposal === \"smart\") {\n        nodeType = \"PipelinePrimaryTopicReference\";\n      } else {\n        nodeType = \"TopicReference\";\n      }\n\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        if (pipeProposal === \"smart\") {\n          this.raise(start, ErrorMessages.PrimaryTopicNotAllowed);\n        } else {\n          this.raise(start, ErrorMessages.PipeTopicUnbound);\n        }\n      }\n\n      this.registerTopicReference();\n      return this.finishNode(node, nodeType);\n    } else {\n      throw this.raise(start, ErrorMessages.PipeTopicUnconfiguredToken, tokenLabelName(tokenType));\n    }\n  }\n\n  testTopicReferenceConfiguration(pipeProposal, start, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\":\n        {\n          const pluginTopicToken = this.getPluginOption(\"pipelineOperator\", \"topicToken\");\n          return tokenLabelName(tokenType) === pluginTopicToken;\n        }\n\n      case \"smart\":\n        return tokenType === 25;\n\n      default:\n        throw this.raise(start, ErrorMessages.PipeTopicRequiresHackPipes);\n    }\n  }\n\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);\n    }\n\n    this.expect(19);\n    this.parseArrowExpression(node, params, true);\n    return node;\n  }\n\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n\n    if (isAsync) {\n      this.prodParam.enter(PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(node.start, ErrorMessages.SuperNotAllowed);\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(node.start, ErrorMessages.UnexpectedSuper);\n    }\n\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(node.start, ErrorMessages.UnsupportedSuper);\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parseMaybePrivateName(isPrivateNameAllowed) {\n    const isPrivate = this.match(125);\n\n    if (isPrivate) {\n      if (!isPrivateNameAllowed) {\n        this.raise(this.state.start + 1, ErrorMessages.UnexpectedPrivateField);\n      }\n\n      return this.parsePrivateName();\n    } else {\n      return this.parseIdentifier(true);\n    }\n  }\n\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n\n      if (this.match(93)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n\n    if (this.isContextual(91)) {\n      if (!this.inModule) {\n        this.raise(id.start, SourceTypeModuleErrorMessages.ImportMetaOutsideModule);\n      }\n\n      this.sawUnambiguousESM = true;\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n\n  parseRegExpLiteral(value) {\n    const node = this.parseLiteral(value.value, \"RegExpLiteral\");\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStart;\n    let optionalCommaStart;\n\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParameters === -1 ? null : refExpressionErrors.optionalParameters);\n\n        if (this.match(11)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(21)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));\n        this.checkCommaAfterRest(41);\n        break;\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\n      }\n    }\n\n    const innerEndPos = this.state.lastTokEnd;\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(val, \"parenthesized\", true);\n      this.addExtra(val, \"parenStart\", startPos);\n      this.takeSurroundingComments(val, startPos, this.state.lastTokEnd);\n      return val;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = val;\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\n    return parenExpression;\n  }\n\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    return node;\n  }\n\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        this.raise(metaProp.start, ErrorMessages.UnexpectedNewTarget);\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node);\n  }\n\n  parseNew(node) {\n    node.callee = this.parseNoCallExpr();\n\n    if (node.callee.type === \"Import\") {\n      this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);\n    } else if (this.eat(18)) {\n      this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);\n    }\n\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewArguments(node) {\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  }\n\n  parseTemplateElement(isTagged) {\n    const elem = this.startNode();\n\n    if (this.state.value === null) {\n      if (!isTagged) {\n        this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);\n      }\n    }\n\n    elem.value = {\n      raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value\n    };\n    this.next();\n    elem.tail = this.match(22);\n    return this.finishNode(elem, \"TemplateElement\");\n  }\n\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    this.next();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this.expect(23);\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.expect(8);\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n\n        if (this.match(close)) {\n          this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n          break;\n        }\n      }\n\n      const prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);\n\n      if (!isPattern) {\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(prop.start, ErrorMessages.InvalidRecordProperty);\n      }\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n\n    return this.finishNode(node, type);\n  }\n\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(46));\n  }\n\n  parsePropertyDefinition(isPattern, refExpressionErrors) {\n    let decorators = [];\n\n    if (this.match(24)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);\n      }\n\n      while (this.match(24)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isGenerator = false;\n    let isAsync = false;\n    let isAccessor = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n\n      if (isPattern) {\n        this.next();\n        prop.argument = this.parseIdentifier();\n        this.checkCommaAfterRest(125);\n        return this.finishNode(prop, \"RestElement\");\n      }\n\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (isPattern || refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(46);\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, false);\n\n    if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(46);\n        this.parsePropertyName(prop, false);\n      }\n\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n\n        if (this.match(46)) {\n          isGenerator = true;\n          this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);\n          this.next();\n        }\n\n        this.parsePropertyName(prop, false);\n      }\n    }\n\n    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    return prop;\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n\n  checkGetterSetterParams(method) {\n    var _params;\n\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const start = method.start;\n\n    if (params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, ErrorMessages.BadGetterArity);\n      } else {\n        this.raise(start, ErrorMessages.BadSetterArity);\n      }\n    }\n\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(start, ErrorMessages.BadSetterRestParameter);\n    }\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));\n      } else if (this.match(27) && refExpressionErrors) {\n        if (refExpressionErrors.shorthandAssign === -1) {\n          refExpressionErrors.shorthandAssign = this.state.start;\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n\n  parsePropertyName(prop, isPrivateNameAllowed) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const oldInPropertyName = this.state.inPropertyName;\n      this.state.inPropertyName = true;\n      const type = this.state.type;\n      prop.key = type === 121 || type === 120 || type === 122 || type === 123 ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);\n\n      if (type !== 125) {\n        prop.computed = false;\n      }\n\n      this.state.inPropertyName = oldInPropertyName;\n    }\n\n    return prop.key;\n  }\n\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return node;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n\n  parseArrowExpression(node, params, isAsync, trailingCommaPos) {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n\n    if (!this.match(0) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaPos);\n    }\n\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(node, params, trailingCommaPos) {\n    node.params = this.toAssignableList(params, trailingCommaPos, false);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    this.finishNode(node, type);\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n\n        if (hasStrictModeDirective && nonSimple) {\n          const errorPos = (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.end : node.start;\n          this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);\n        }\n\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n\n        if (this.state.strict && node.id) {\n          this.checkLVal(node.id, \"function name\", BIND_OUTSIDE, undefined, undefined, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.expressionScope.exit();\n      this.state.labels = oldLabels;\n    }\n  }\n\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (params[i].type !== \"Identifier\") return false;\n    }\n\n    return true;\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = new Set();\n\n    for (const param of node.params) {\n      this.checkLVal(param, \"function parameter list\", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);\n    }\n  }\n\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n\n    return elts;\n  }\n\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(this.state.pos, ErrorMessages.UnexpectedToken, \",\");\n      }\n\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n\n      if (!allowPlaceholder) {\n        this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);\n      }\n\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\n    }\n\n    return elt;\n  }\n\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos, liberal) {\n    let name;\n    const {\n      start,\n      type\n    } = this.state;\n\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      throw this.unexpected();\n    }\n\n    if (liberal) {\n      this.state.type = 119;\n    } else {\n      this.checkReservedWord(name, start, tokenIsKeyword(type), false);\n    }\n\n    this.next();\n    return name;\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n\n    if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);\n        return;\n      } else if (this.scope.inStaticBlock) {\n        this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);\n        return;\n      } else {\n        this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);\n      }\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(startLoc, ErrorMessages.ArgumentsInClass);\n        return;\n      }\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);\n      return;\n    }\n\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);\n    }\n  }\n\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait) return true;\n\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n\n    return false;\n  }\n\n  parseAwait(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);\n\n    if (this.eat(46)) {\n      this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait() {\n    return this.hasPrecedingLineBreak() || this.match(44) || this.match(10) || this.match(0) || this.match(22) || this.match(124) || this.match(47) || this.hasPlugin(\"v8intrinsic\") && this.match(45);\n  }\n\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);\n    this.next();\n    let delegating = false;\n    let argument = null;\n\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(46);\n\n      switch (this.state.type) {\n        case 13:\n        case 126:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  checkPipelineAtInfixOperator(left, leftStartPos) {\n    if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);\n      }\n    }\n  }\n\n  checkHackPipeBodyEarlyErrors(startPos) {\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(startPos, ErrorMessages.PipeTopicUnused);\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {\n    const bodyNode = this.startNodeAt(startPos, startLoc);\n\n    if (this.isSimpleReference(childExpr)) {\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      this.checkSmartPipeTopicBodyEarlyErrors(startPos);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n\n      case \"Identifier\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  checkSmartPipeTopicBodyEarlyErrors(startPos) {\n    if (this.match(19)) {\n      throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);\n    } else if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(startPos, ErrorMessages.PipelineTopicUnused);\n    }\n  }\n\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSmartMixTopicForbiddingContext(callback) {\n    const proposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n    if (proposal === \"smart\") {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n\n  parseFSharpPipelineBody(prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    this.eat(5);\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    const program = this.startNode();\n\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n\n    this.eat(8);\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n\n}\n\nconst loopLabel = {\n  kind: \"loop\"\n},\n      switchLabel = {\n  kind: \"switch\"\n};\nconst FUNC_NO_FLAGS = 0b000,\n      FUNC_STATEMENT = 0b001,\n      FUNC_HANGING_STATEMENT = 0b010,\n      FUNC_NULLABLE_ID = 0b100;\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\n\nfunction babel7CompatTokens(tokens) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n\n    if (type === 125) {\n      {\n        const {\n          loc,\n          start,\n          value,\n          end\n        } = token;\n        const hashEndPos = start + 1;\n        const hashEndLoc = new Position(loc.start.line, loc.start.column + 1);\n        tokens.splice(i, 1, new Token({\n          type: getExportedToken(25),\n          value: \"#\",\n          start: start,\n          end: hashEndPos,\n          startLoc: loc.start,\n          endLoc: hashEndLoc\n        }), new Token({\n          type: getExportedToken(119),\n          value: value,\n          start: hashEndPos,\n          end: end,\n          startLoc: hashEndLoc,\n          endLoc: loc.end\n        }));\n        i++;\n        continue;\n      }\n    }\n\n    if (typeof type === \"number\") {\n      token.type = getExportedToken(type);\n    }\n  }\n\n  return tokens;\n}\n\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n    if (this.options.tokens) file.tokens = babel7CompatTokens(this.tokens);\n    return this.finishNode(file, \"File\");\n  }\n\n  parseProgram(program, end = 126, sourceType = this.options.sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (const [name] of Array.from(this.scope.undefinedExports)) {\n        const pos = this.scope.undefinedExports.get(name);\n        this.raise(pos, ErrorMessages.ModuleExportUndefined, name);\n      }\n    }\n\n    return this.finishNode(program, \"Program\");\n  }\n\n  stmtToDirective(stmt) {\n    const directive = stmt;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n    const directiveLiteral = directive.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    directiveLiteral.type = \"DirectiveLiteral\";\n    return directive;\n  }\n\n  parseInterpreterDirective() {\n    if (!this.match(26)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context) {\n    if (!this.isContextual(90)) {\n      return false;\n    }\n\n    return this.isLetKeyword(context);\n  }\n\n  isLetKeyword(context) {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n\n    if (nextCh === 92 || nextCh === 91) {\n      return true;\n    }\n\n    if (context) return false;\n    if (nextCh === 123) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      keywordRelationalOperator.lastIndex = next;\n\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.match(24)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context, topLevel) {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = 65;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case 51:\n        return this.parseBreakContinueStatement(node, true);\n\n      case 54:\n        return this.parseBreakContinueStatement(node, false);\n\n      case 55:\n        return this.parseDebuggerStatement(node);\n\n      case 81:\n        return this.parseDoStatement(node);\n\n      case 82:\n        return this.parseForStatement(node);\n\n      case 59:\n        if (this.lookaheadCharCode() === 46) break;\n\n        if (context) {\n          if (this.state.strict) {\n            this.raise(this.state.start, ErrorMessages.StrictFunction);\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(this.state.start, ErrorMessages.SloppyFunction);\n          }\n        }\n\n        return this.parseFunctionStatement(node, false, !context);\n\n      case 71:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case 60:\n        return this.parseIfStatement(node);\n\n      case 61:\n        return this.parseReturnStatement(node);\n\n      case 62:\n        return this.parseSwitchStatement(node);\n\n      case 63:\n        return this.parseThrowStatement(node);\n\n      case 64:\n        return this.parseTryStatement(node);\n\n      case 66:\n      case 65:\n        kind = kind || this.state.value;\n\n        if (context && kind !== \"var\") {\n          this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);\n        }\n\n        return this.parseVarStatement(node, kind);\n\n      case 83:\n        return this.parseWhileStatement(node);\n\n      case 67:\n        return this.parseWithStatement(node);\n\n      case 5:\n        return this.parseBlock();\n\n      case 13:\n        return this.parseEmptyStatement(node);\n\n      case 74:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n        }\n\n      case 73:\n        {\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);\n          }\n\n          this.next();\n          let result;\n\n          if (starttype === 74) {\n            result = this.parseImport(node);\n\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node);\n\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n\n          this.assertModuleNodeAllowed(node);\n          return result;\n        }\n\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);\n            }\n\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (tokenIsIdentifier(starttype) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(node.start, SourceTypeModuleErrorMessages.ImportOutsideModule);\n    }\n  }\n\n  takeDecorators(node) {\n    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator() {\n    return this.match(71);\n  }\n\n  parseDecorators(allowExport) {\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(24)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(73)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, ErrorMessages.DecoratorExportClass);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);\n    }\n  }\n\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      this.state.decoratorStack.push([]);\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr;\n\n      if (this.eat(10)) {\n        expr = this.parseExpression();\n        this.expect(11);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(10)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n\n  verifyBreakContinue(node, isBreak) {\n    let i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      this.raise(node.start, ErrorMessages.IllegalBreakContinue, isBreak ? \"break\" : \"continue\");\n    }\n  }\n\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(83);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = -1;\n\n    if (this.isAwaitAllowed() && this.eatContextual(87)) {\n      awaitAt = this.state.lastTokStart;\n    }\n\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(10);\n\n    if (this.match(13)) {\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    const startsWithLet = this.isContextual(90);\n    const isLet = startsWithLet && this.isLetKeyword();\n\n    if (this.match(65) || this.match(66) || isLet) {\n      const init = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(init, true, kind);\n      this.finishNode(init, \"VariableDeclaration\");\n\n      if ((this.match(49) || this.isContextual(92)) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, init);\n    }\n\n    const startsWithAsync = this.isContextual(86);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(92);\n\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(init.start, ErrorMessages.ForOfLet);\n      } else if (awaitAt === -1 && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(init.start, ErrorMessages.ForOfAsync);\n      }\n    }\n\n    if (isForOf || this.match(49)) {\n      this.toAssignable(init, true);\n      const description = isForOf ? \"for-of statement\" : \"for-in statement\";\n      this.checkLVal(init, description);\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(57) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, ErrorMessages.IllegalReturn);\n    }\n\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n    let cur;\n\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(52) || this.match(56)) {\n        const isCase = this.match(52);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node) {\n    this.next();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, \"catch clause\", BIND_LEXICAL);\n    return param;\n  }\n\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(53)) {\n      const clause = this.startNode();\n      this.next();\n\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(58) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, ErrorMessages.NoCatchOrFinally);\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(this.state.start, ErrorMessages.StrictWith);\n    }\n\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);\n      }\n    }\n\n    const kind = tokenIsLoop(this.state.type) ? \"loop\" : this.match(62) ? \"switch\" : null;\n\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n\n    this.expect(5);\n\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n\n      body.push(stmt);\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(49);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt > -1) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt > -1;\n    }\n\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? \"for-in\" : \"for-of\");\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, ErrorMessages.InvalidLhs, \"for-loop\");\n    }\n\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  parseVar(node, isFor, kind) {\n    const declarations = node.declarations = [];\n    const isTypescript = this.hasPlugin(\"typescript\");\n    node.kind = kind;\n\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n\n      if (this.eat(27)) {\n        decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      } else {\n        if (kind === \"const\" && !(this.match(49) || this.isContextual(92))) {\n          if (!isTypescript) {\n            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, \"Const declarations\");\n          }\n        } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(49) || this.isContextual(92)))) {\n          this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, \"Complex binding patterns\");\n        }\n\n        decl.init = null;\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12)) break;\n    }\n\n    return node;\n  }\n\n  parseVarId(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, \"variable declaration\", kind === \"var\" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== \"var\");\n  }\n\n  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n\n    if (this.match(46) && isHangingStatement) {\n      this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);\n    }\n\n    node.generator = this.eat(46);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, false, allowModifiers);\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n\n  isClassProperty() {\n    return this.match(27) || this.match(13) || this.match(8);\n  }\n\n  isClassMethod() {\n    return this.match(10);\n  }\n\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);\n          }\n\n          continue;\n        }\n\n        if (this.match(24)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(member.start, ErrorMessages.DecoratorConstructor);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n\n    if (decorators.length) {\n      throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);\n    }\n\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(95);\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n\n    if (this.eat(46)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(125);\n      this.parseClassElementName(method);\n\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n\n    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(125);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStart = this.state.start;\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, ErrorMessages.DuplicateConstructor);\n        }\n\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(key.start, ErrorMessages.OverrideOnConstructor);\n        }\n\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isContextual && key.name === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(46);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStart);\n      }\n\n      method.kind = \"method\";\n      const isPrivate = this.match(125);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isContextual && (key.name === \"get\" || key.name === \"set\") && !(this.match(46) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      const isPrivate = this.match(125);\n      this.parseClassElementName(publicMethod);\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  parseClassElementName(member) {\n    const {\n      type,\n      value,\n      start\n    } = this.state;\n\n    if ((type === 119 || type === 120) && member.static && value === \"prototype\") {\n      this.raise(start, ErrorMessages.StaticPrototype);\n    }\n\n    if (type === 125 && value === \"constructor\") {\n      this.raise(start, ErrorMessages.ConstructorClassPrivateField);\n    }\n\n    return this.parsePropertyName(member, true);\n  }\n\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n\n    this.expectPlugin(\"classStaticBlock\", member.start);\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(PARAM);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(member.start, ErrorMessages.DecoratorStaticBlock);\n    }\n  }\n\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(prop.key.start, ErrorMessages.ConstructorClassField);\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === \"set\" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {}\n\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseInitializer(node) {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(27) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n\n      if (isStatement) {\n        this.checkLVal(node.id, \"class name\", bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, ErrorMessages.MissingClassName);\n      }\n    }\n  }\n\n  parseClassSuper(node) {\n    node.superClass = this.eat(72) ? this.parseExprSubscripts() : null;\n  }\n\n  parseExport(node) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, 5);\n    }\n\n    let hasDeclaration;\n\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(56)) {\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, 5);\n  }\n\n  eatExportStar(node) {\n    return this.eat(46);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(84)) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      if (!node.specifiers) node.specifiers = [];\n      node.specifiers.push(...this.parseExportSpecifiers());\n      node.source = null;\n      node.declaration = null;\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  isAsyncFunction() {\n    if (!this.isContextual(86)) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(59) || isAsync) {\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    } else if (this.match(71)) {\n      return this.parseClass(expr, true, true);\n    } else if (this.match(24)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);\n      }\n\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    } else if (this.match(66) || this.match(65) || this.isLet()) {\n      throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);\n    } else {\n      const res = this.parseMaybeAssignAllowIn();\n      this.semicolon();\n      return res;\n    }\n  }\n\n  parseExportDeclaration(node) {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsIdentifier(type)) {\n      if (type === 86 && !this.state.containsEsc || type === 90) {\n        return false;\n      }\n\n      if ((type === 117 || type === 116) && !this.state.containsEsc) {\n        const {\n          type: nextType\n        } = this.lookahead();\n\n        if (tokenIsIdentifier(nextType) && nextType !== 88 || nextType === 5) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(56)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n\n    if (this.match(56) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n\n    return false;\n  }\n\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(88)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n\n      if (assertions) {\n        node.assertions = assertions;\n      }\n    } else {\n      if (expect) {\n        this.unexpected();\n      } else {\n        node.source = null;\n      }\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n\n    if (type === 24) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return type === 65 || type === 66 || type === 59 || type === 71 || this.isLet() || this.isAsyncFunction();\n  }\n\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n\n          const declaration = node.declaration;\n\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);\n          }\n        }\n      } else if (node.specifiers && node.specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportedName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportedName);\n\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n\n            if (local.type !== \"Identifier\") {\n              this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);\n            } else {\n              this.checkReservedWord(local.name, local.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);\n    }\n  }\n\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(node, name) {\n    if (this.exportedIdentifiers.has(name)) {\n      this.raise(node.start, name === \"default\" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);\n    }\n\n    this.exportedIdentifiers.add(name);\n  }\n\n  parseExportSpecifiers() {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n\n      const node = this.startNode();\n      const isString = this.match(120);\n      const local = this.parseModuleExportName();\n      node.local = local;\n\n      if (this.eatContextual(84)) {\n        node.exported = this.parseModuleExportName();\n      } else if (isString) {\n        node.exported = cloneStringLiteral(local);\n      } else {\n        node.exported = cloneIdentifier(local);\n      }\n\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }\n\n  parseModuleExportName() {\n    if (this.match(120)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n\n      if (surrogate) {\n        this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));\n      }\n\n      return result;\n    }\n\n    return this.parseIdentifier(true);\n  }\n\n  parseImport(node) {\n    node.specifiers = [];\n\n    if (!this.match(120)) {\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(12);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(88);\n    }\n\n    node.source = this.parseImportSource();\n    const assertions = this.maybeParseImportAssertions();\n\n    if (assertions) {\n      node.assertions = assertions;\n    } else {\n      const attributes = this.maybeParseModuleAttributes();\n\n      if (attributes) {\n        node.attributes = attributes;\n      }\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    if (!this.match(120)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  shouldParseDefaultImport(node) {\n    return tokenIsIdentifier(this.state.type);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  parseAssertEntries() {\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(8)) {\n        break;\n      }\n\n      const node = this.startNode();\n      const keyName = this.state.value;\n\n      if (attrNames.has(keyName)) {\n        this.raise(this.state.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);\n      }\n\n      attrNames.add(keyName);\n\n      if (this.match(120)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n\n      this.expect(14);\n\n      if (!this.match(120)) {\n        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);\n      }\n\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(12));\n\n    return attrs;\n  }\n\n  maybeParseModuleAttributes() {\n    if (this.match(67) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n\n    const attrs = [];\n    const attributes = new Set();\n\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);\n      }\n\n      attributes.add(node.key.name);\n      this.expect(14);\n\n      if (!this.match(120)) {\n        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);\n      }\n\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(12));\n\n    return attrs;\n  }\n\n  maybeParseImportAssertions() {\n    if (this.isContextual(85) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n\n    this.eat(5);\n    const attrs = this.parseAssertEntries();\n    this.eat(8);\n    return attrs;\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(46)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(84);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\", \"import namespace specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);\n        }\n\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n\n      this.parseImportSpecifier(node);\n    }\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    const importedIsString = this.match(120);\n    specifier.imported = this.parseModuleExportName();\n\n    if (this.eatContextual(84)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n\n      if (importedIsString) {\n        throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);\n      }\n\n      this.checkReservedWord(imported.name, specifier.start, true, true);\n      specifier.local = cloneIdentifier(imported);\n    }\n\n    this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n\n}\n\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n\n}\n\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n\n  return pluginMap;\n}\n\nfunction parse(input, options) {\n  var _options;\n\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\n\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n\n  return tokenTypes;\n}\n\nconst tokTypes = generateExportedTokenTypes(tt);\n\nfunction getParser(options, input) {\n  let cls = Parser;\n\n  if (options != null && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assertNode;\n\nvar _isNode = require(\"../validators/isNode\");\n\nfunction assertNode(node) {\n  if (!(0, _isNode.default)(node)) {\n    var _node$type;\n\n    const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);\n    throw new TypeError(`Not a valid node of type \"${type}\"`);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertArrayExpression = assertArrayExpression;\nexports.assertAssignmentExpression = assertAssignmentExpression;\nexports.assertBinaryExpression = assertBinaryExpression;\nexports.assertInterpreterDirective = assertInterpreterDirective;\nexports.assertDirective = assertDirective;\nexports.assertDirectiveLiteral = assertDirectiveLiteral;\nexports.assertBlockStatement = assertBlockStatement;\nexports.assertBreakStatement = assertBreakStatement;\nexports.assertCallExpression = assertCallExpression;\nexports.assertCatchClause = assertCatchClause;\nexports.assertConditionalExpression = assertConditionalExpression;\nexports.assertContinueStatement = assertContinueStatement;\nexports.assertDebuggerStatement = assertDebuggerStatement;\nexports.assertDoWhileStatement = assertDoWhileStatement;\nexports.assertEmptyStatement = assertEmptyStatement;\nexports.assertExpressionStatement = assertExpressionStatement;\nexports.assertFile = assertFile;\nexports.assertForInStatement = assertForInStatement;\nexports.assertForStatement = assertForStatement;\nexports.assertFunctionDeclaration = assertFunctionDeclaration;\nexports.assertFunctionExpression = assertFunctionExpression;\nexports.assertIdentifier = assertIdentifier;\nexports.assertIfStatement = assertIfStatement;\nexports.assertLabeledStatement = assertLabeledStatement;\nexports.assertStringLiteral = assertStringLiteral;\nexports.assertNumericLiteral = assertNumericLiteral;\nexports.assertNullLiteral = assertNullLiteral;\nexports.assertBooleanLiteral = assertBooleanLiteral;\nexports.assertRegExpLiteral = assertRegExpLiteral;\nexports.assertLogicalExpression = assertLogicalExpression;\nexports.assertMemberExpression = assertMemberExpression;\nexports.assertNewExpression = assertNewExpression;\nexports.assertProgram = assertProgram;\nexports.assertObjectExpression = assertObjectExpression;\nexports.assertObjectMethod = assertObjectMethod;\nexports.assertObjectProperty = assertObjectProperty;\nexports.assertRestElement = assertRestElement;\nexports.assertReturnStatement = assertReturnStatement;\nexports.assertSequenceExpression = assertSequenceExpression;\nexports.assertParenthesizedExpression = assertParenthesizedExpression;\nexports.assertSwitchCase = assertSwitchCase;\nexports.assertSwitchStatement = assertSwitchStatement;\nexports.assertThisExpression = assertThisExpression;\nexports.assertThrowStatement = assertThrowStatement;\nexports.assertTryStatement = assertTryStatement;\nexports.assertUnaryExpression = assertUnaryExpression;\nexports.assertUpdateExpression = assertUpdateExpression;\nexports.assertVariableDeclaration = assertVariableDeclaration;\nexports.assertVariableDeclarator = assertVariableDeclarator;\nexports.assertWhileStatement = assertWhileStatement;\nexports.assertWithStatement = assertWithStatement;\nexports.assertAssignmentPattern = assertAssignmentPattern;\nexports.assertArrayPattern = assertArrayPattern;\nexports.assertArrowFunctionExpression = assertArrowFunctionExpression;\nexports.assertClassBody = assertClassBody;\nexports.assertClassExpression = assertClassExpression;\nexports.assertClassDeclaration = assertClassDeclaration;\nexports.assertExportAllDeclaration = assertExportAllDeclaration;\nexports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;\nexports.assertExportNamedDeclaration = assertExportNamedDeclaration;\nexports.assertExportSpecifier = assertExportSpecifier;\nexports.assertForOfStatement = assertForOfStatement;\nexports.assertImportDeclaration = assertImportDeclaration;\nexports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;\nexports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;\nexports.assertImportSpecifier = assertImportSpecifier;\nexports.assertMetaProperty = assertMetaProperty;\nexports.assertClassMethod = assertClassMethod;\nexports.assertObjectPattern = assertObjectPattern;\nexports.assertSpreadElement = assertSpreadElement;\nexports.assertSuper = assertSuper;\nexports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;\nexports.assertTemplateElement = assertTemplateElement;\nexports.assertTemplateLiteral = assertTemplateLiteral;\nexports.assertYieldExpression = assertYieldExpression;\nexports.assertAwaitExpression = assertAwaitExpression;\nexports.assertImport = assertImport;\nexports.assertBigIntLiteral = assertBigIntLiteral;\nexports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;\nexports.assertOptionalMemberExpression = assertOptionalMemberExpression;\nexports.assertOptionalCallExpression = assertOptionalCallExpression;\nexports.assertClassProperty = assertClassProperty;\nexports.assertClassPrivateProperty = assertClassPrivateProperty;\nexports.assertClassPrivateMethod = assertClassPrivateMethod;\nexports.assertPrivateName = assertPrivateName;\nexports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;\nexports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;\nexports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;\nexports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;\nexports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;\nexports.assertClassImplements = assertClassImplements;\nexports.assertDeclareClass = assertDeclareClass;\nexports.assertDeclareFunction = assertDeclareFunction;\nexports.assertDeclareInterface = assertDeclareInterface;\nexports.assertDeclareModule = assertDeclareModule;\nexports.assertDeclareModuleExports = assertDeclareModuleExports;\nexports.assertDeclareTypeAlias = assertDeclareTypeAlias;\nexports.assertDeclareOpaqueType = assertDeclareOpaqueType;\nexports.assertDeclareVariable = assertDeclareVariable;\nexports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;\nexports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;\nexports.assertDeclaredPredicate = assertDeclaredPredicate;\nexports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;\nexports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;\nexports.assertFunctionTypeParam = assertFunctionTypeParam;\nexports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;\nexports.assertInferredPredicate = assertInferredPredicate;\nexports.assertInterfaceExtends = assertInterfaceExtends;\nexports.assertInterfaceDeclaration = assertInterfaceDeclaration;\nexports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;\nexports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;\nexports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;\nexports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;\nexports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;\nexports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;\nexports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;\nexports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;\nexports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;\nexports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;\nexports.assertObjectTypeIndexer = assertObjectTypeIndexer;\nexports.assertObjectTypeProperty = assertObjectTypeProperty;\nexports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;\nexports.assertOpaqueType = assertOpaqueType;\nexports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;\nexports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;\nexports.assertStringTypeAnnotation = assertStringTypeAnnotation;\nexports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;\nexports.assertThisTypeAnnotation = assertThisTypeAnnotation;\nexports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;\nexports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;\nexports.assertTypeAlias = assertTypeAlias;\nexports.assertTypeAnnotation = assertTypeAnnotation;\nexports.assertTypeCastExpression = assertTypeCastExpression;\nexports.assertTypeParameter = assertTypeParameter;\nexports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;\nexports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;\nexports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;\nexports.assertVariance = assertVariance;\nexports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;\nexports.assertEnumDeclaration = assertEnumDeclaration;\nexports.assertEnumBooleanBody = assertEnumBooleanBody;\nexports.assertEnumNumberBody = assertEnumNumberBody;\nexports.assertEnumStringBody = assertEnumStringBody;\nexports.assertEnumSymbolBody = assertEnumSymbolBody;\nexports.assertEnumBooleanMember = assertEnumBooleanMember;\nexports.assertEnumNumberMember = assertEnumNumberMember;\nexports.assertEnumStringMember = assertEnumStringMember;\nexports.assertEnumDefaultedMember = assertEnumDefaultedMember;\nexports.assertIndexedAccessType = assertIndexedAccessType;\nexports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;\nexports.assertJSXAttribute = assertJSXAttribute;\nexports.assertJSXClosingElement = assertJSXClosingElement;\nexports.assertJSXElement = assertJSXElement;\nexports.assertJSXEmptyExpression = assertJSXEmptyExpression;\nexports.assertJSXExpressionContainer = assertJSXExpressionContainer;\nexports.assertJSXSpreadChild = assertJSXSpreadChild;\nexports.assertJSXIdentifier = assertJSXIdentifier;\nexports.assertJSXMemberExpression = assertJSXMemberExpression;\nexports.assertJSXNamespacedName = assertJSXNamespacedName;\nexports.assertJSXOpeningElement = assertJSXOpeningElement;\nexports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;\nexports.assertJSXText = assertJSXText;\nexports.assertJSXFragment = assertJSXFragment;\nexports.assertJSXOpeningFragment = assertJSXOpeningFragment;\nexports.assertJSXClosingFragment = assertJSXClosingFragment;\nexports.assertNoop = assertNoop;\nexports.assertPlaceholder = assertPlaceholder;\nexports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;\nexports.assertArgumentPlaceholder = assertArgumentPlaceholder;\nexports.assertBindExpression = assertBindExpression;\nexports.assertImportAttribute = assertImportAttribute;\nexports.assertDecorator = assertDecorator;\nexports.assertDoExpression = assertDoExpression;\nexports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;\nexports.assertRecordExpression = assertRecordExpression;\nexports.assertTupleExpression = assertTupleExpression;\nexports.assertDecimalLiteral = assertDecimalLiteral;\nexports.assertStaticBlock = assertStaticBlock;\nexports.assertModuleExpression = assertModuleExpression;\nexports.assertTopicReference = assertTopicReference;\nexports.assertPipelineTopicExpression = assertPipelineTopicExpression;\nexports.assertPipelineBareFunction = assertPipelineBareFunction;\nexports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;\nexports.assertTSParameterProperty = assertTSParameterProperty;\nexports.assertTSDeclareFunction = assertTSDeclareFunction;\nexports.assertTSDeclareMethod = assertTSDeclareMethod;\nexports.assertTSQualifiedName = assertTSQualifiedName;\nexports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;\nexports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;\nexports.assertTSPropertySignature = assertTSPropertySignature;\nexports.assertTSMethodSignature = assertTSMethodSignature;\nexports.assertTSIndexSignature = assertTSIndexSignature;\nexports.assertTSAnyKeyword = assertTSAnyKeyword;\nexports.assertTSBooleanKeyword = assertTSBooleanKeyword;\nexports.assertTSBigIntKeyword = assertTSBigIntKeyword;\nexports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;\nexports.assertTSNeverKeyword = assertTSNeverKeyword;\nexports.assertTSNullKeyword = assertTSNullKeyword;\nexports.assertTSNumberKeyword = assertTSNumberKeyword;\nexports.assertTSObjectKeyword = assertTSObjectKeyword;\nexports.assertTSStringKeyword = assertTSStringKeyword;\nexports.assertTSSymbolKeyword = assertTSSymbolKeyword;\nexports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;\nexports.assertTSUnknownKeyword = assertTSUnknownKeyword;\nexports.assertTSVoidKeyword = assertTSVoidKeyword;\nexports.assertTSThisType = assertTSThisType;\nexports.assertTSFunctionType = assertTSFunctionType;\nexports.assertTSConstructorType = assertTSConstructorType;\nexports.assertTSTypeReference = assertTSTypeReference;\nexports.assertTSTypePredicate = assertTSTypePredicate;\nexports.assertTSTypeQuery = assertTSTypeQuery;\nexports.assertTSTypeLiteral = assertTSTypeLiteral;\nexports.assertTSArrayType = assertTSArrayType;\nexports.assertTSTupleType = assertTSTupleType;\nexports.assertTSOptionalType = assertTSOptionalType;\nexports.assertTSRestType = assertTSRestType;\nexports.assertTSNamedTupleMember = assertTSNamedTupleMember;\nexports.assertTSUnionType = assertTSUnionType;\nexports.assertTSIntersectionType = assertTSIntersectionType;\nexports.assertTSConditionalType = assertTSConditionalType;\nexports.assertTSInferType = assertTSInferType;\nexports.assertTSParenthesizedType = assertTSParenthesizedType;\nexports.assertTSTypeOperator = assertTSTypeOperator;\nexports.assertTSIndexedAccessType = assertTSIndexedAccessType;\nexports.assertTSMappedType = assertTSMappedType;\nexports.assertTSLiteralType = assertTSLiteralType;\nexports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;\nexports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;\nexports.assertTSInterfaceBody = assertTSInterfaceBody;\nexports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;\nexports.assertTSAsExpression = assertTSAsExpression;\nexports.assertTSTypeAssertion = assertTSTypeAssertion;\nexports.assertTSEnumDeclaration = assertTSEnumDeclaration;\nexports.assertTSEnumMember = assertTSEnumMember;\nexports.assertTSModuleDeclaration = assertTSModuleDeclaration;\nexports.assertTSModuleBlock = assertTSModuleBlock;\nexports.assertTSImportType = assertTSImportType;\nexports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;\nexports.assertTSExternalModuleReference = assertTSExternalModuleReference;\nexports.assertTSNonNullExpression = assertTSNonNullExpression;\nexports.assertTSExportAssignment = assertTSExportAssignment;\nexports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;\nexports.assertTSTypeAnnotation = assertTSTypeAnnotation;\nexports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;\nexports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;\nexports.assertTSTypeParameter = assertTSTypeParameter;\nexports.assertExpression = assertExpression;\nexports.assertBinary = assertBinary;\nexports.assertScopable = assertScopable;\nexports.assertBlockParent = assertBlockParent;\nexports.assertBlock = assertBlock;\nexports.assertStatement = assertStatement;\nexports.assertTerminatorless = assertTerminatorless;\nexports.assertCompletionStatement = assertCompletionStatement;\nexports.assertConditional = assertConditional;\nexports.assertLoop = assertLoop;\nexports.assertWhile = assertWhile;\nexports.assertExpressionWrapper = assertExpressionWrapper;\nexports.assertFor = assertFor;\nexports.assertForXStatement = assertForXStatement;\nexports.assertFunction = assertFunction;\nexports.assertFunctionParent = assertFunctionParent;\nexports.assertPureish = assertPureish;\nexports.assertDeclaration = assertDeclaration;\nexports.assertPatternLike = assertPatternLike;\nexports.assertLVal = assertLVal;\nexports.assertTSEntityName = assertTSEntityName;\nexports.assertLiteral = assertLiteral;\nexports.assertImmutable = assertImmutable;\nexports.assertUserWhitespacable = assertUserWhitespacable;\nexports.assertMethod = assertMethod;\nexports.assertObjectMember = assertObjectMember;\nexports.assertProperty = assertProperty;\nexports.assertUnaryLike = assertUnaryLike;\nexports.assertPattern = assertPattern;\nexports.assertClass = assertClass;\nexports.assertModuleDeclaration = assertModuleDeclaration;\nexports.assertExportDeclaration = assertExportDeclaration;\nexports.assertModuleSpecifier = assertModuleSpecifier;\nexports.assertPrivate = assertPrivate;\nexports.assertFlow = assertFlow;\nexports.assertFlowType = assertFlowType;\nexports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;\nexports.assertFlowDeclaration = assertFlowDeclaration;\nexports.assertFlowPredicate = assertFlowPredicate;\nexports.assertEnumBody = assertEnumBody;\nexports.assertEnumMember = assertEnumMember;\nexports.assertJSX = assertJSX;\nexports.assertTSTypeElement = assertTSTypeElement;\nexports.assertTSType = assertTSType;\nexports.assertTSBaseType = assertTSBaseType;\nexports.assertNumberLiteral = assertNumberLiteral;\nexports.assertRegexLiteral = assertRegexLiteral;\nexports.assertRestProperty = assertRestProperty;\nexports.assertSpreadProperty = assertSpreadProperty;\n\nvar _is = require(\"../../validators/is\");\n\nfunction assert(type, node, opts) {\n  if (!(0, _is.default)(type, node, opts)) {\n    throw new Error(`Expected type \"${type}\" with option ${JSON.stringify(opts)}, ` + `but instead got \"${node.type}\".`);\n  }\n}\n\nfunction assertArrayExpression(node, opts) {\n  assert(\"ArrayExpression\", node, opts);\n}\n\nfunction assertAssignmentExpression(node, opts) {\n  assert(\"AssignmentExpression\", node, opts);\n}\n\nfunction assertBinaryExpression(node, opts) {\n  assert(\"BinaryExpression\", node, opts);\n}\n\nfunction assertInterpreterDirective(node, opts) {\n  assert(\"InterpreterDirective\", node, opts);\n}\n\nfunction assertDirective(node, opts) {\n  assert(\"Directive\", node, opts);\n}\n\nfunction assertDirectiveLiteral(node, opts) {\n  assert(\"DirectiveLiteral\", node, opts);\n}\n\nfunction assertBlockStatement(node, opts) {\n  assert(\"BlockStatement\", node, opts);\n}\n\nfunction assertBreakStatement(node, opts) {\n  assert(\"BreakStatement\", node, opts);\n}\n\nfunction assertCallExpression(node, opts) {\n  assert(\"CallExpression\", node, opts);\n}\n\nfunction assertCatchClause(node, opts) {\n  assert(\"CatchClause\", node, opts);\n}\n\nfunction assertConditionalExpression(node, opts) {\n  assert(\"ConditionalExpression\", node, opts);\n}\n\nfunction assertContinueStatement(node, opts) {\n  assert(\"ContinueStatement\", node, opts);\n}\n\nfunction assertDebuggerStatement(node, opts) {\n  assert(\"DebuggerStatement\", node, opts);\n}\n\nfunction assertDoWhileStatement(node, opts) {\n  assert(\"DoWhileStatement\", node, opts);\n}\n\nfunction assertEmptyStatement(node, opts) {\n  assert(\"EmptyStatement\", node, opts);\n}\n\nfunction assertExpressionStatement(node, opts) {\n  assert(\"ExpressionStatement\", node, opts);\n}\n\nfunction assertFile(node, opts) {\n  assert(\"File\", node, opts);\n}\n\nfunction assertForInStatement(node, opts) {\n  assert(\"ForInStatement\", node, opts);\n}\n\nfunction assertForStatement(node, opts) {\n  assert(\"ForStatement\", node, opts);\n}\n\nfunction assertFunctionDeclaration(node, opts) {\n  assert(\"FunctionDeclaration\", node, opts);\n}\n\nfunction assertFunctionExpression(node, opts) {\n  assert(\"FunctionExpression\", node, opts);\n}\n\nfunction assertIdentifier(node, opts) {\n  assert(\"Identifier\", node, opts);\n}\n\nfunction assertIfStatement(node, opts) {\n  assert(\"IfStatement\", node, opts);\n}\n\nfunction assertLabeledStatement(node, opts) {\n  assert(\"LabeledStatement\", node, opts);\n}\n\nfunction assertStringLiteral(node, opts) {\n  assert(\"StringLiteral\", node, opts);\n}\n\nfunction assertNumericLiteral(node, opts) {\n  assert(\"NumericLiteral\", node, opts);\n}\n\nfunction assertNullLiteral(node, opts) {\n  assert(\"NullLiteral\", node, opts);\n}\n\nfunction assertBooleanLiteral(node, opts) {\n  assert(\"BooleanLiteral\", node, opts);\n}\n\nfunction assertRegExpLiteral(node, opts) {\n  assert(\"RegExpLiteral\", node, opts);\n}\n\nfunction assertLogicalExpression(node, opts) {\n  assert(\"LogicalExpression\", node, opts);\n}\n\nfunction assertMemberExpression(node, opts) {\n  assert(\"MemberExpression\", node, opts);\n}\n\nfunction assertNewExpression(node, opts) {\n  assert(\"NewExpression\", node, opts);\n}\n\nfunction assertProgram(node, opts) {\n  assert(\"Program\", node, opts);\n}\n\nfunction assertObjectExpression(node, opts) {\n  assert(\"ObjectExpression\", node, opts);\n}\n\nfunction assertObjectMethod(node, opts) {\n  assert(\"ObjectMethod\", node, opts);\n}\n\nfunction assertObjectProperty(node, opts) {\n  assert(\"ObjectProperty\", node, opts);\n}\n\nfunction assertRestElement(node, opts) {\n  assert(\"RestElement\", node, opts);\n}\n\nfunction assertReturnStatement(node, opts) {\n  assert(\"ReturnStatement\", node, opts);\n}\n\nfunction assertSequenceExpression(node, opts) {\n  assert(\"SequenceExpression\", node, opts);\n}\n\nfunction assertParenthesizedExpression(node, opts) {\n  assert(\"ParenthesizedExpression\", node, opts);\n}\n\nfunction assertSwitchCase(node, opts) {\n  assert(\"SwitchCase\", node, opts);\n}\n\nfunction assertSwitchStatement(node, opts) {\n  assert(\"SwitchStatement\", node, opts);\n}\n\nfunction assertThisExpression(node, opts) {\n  assert(\"ThisExpression\", node, opts);\n}\n\nfunction assertThrowStatement(node, opts) {\n  assert(\"ThrowStatement\", node, opts);\n}\n\nfunction assertTryStatement(node, opts) {\n  assert(\"TryStatement\", node, opts);\n}\n\nfunction assertUnaryExpression(node, opts) {\n  assert(\"UnaryExpression\", node, opts);\n}\n\nfunction assertUpdateExpression(node, opts) {\n  assert(\"UpdateExpression\", node, opts);\n}\n\nfunction assertVariableDeclaration(node, opts) {\n  assert(\"VariableDeclaration\", node, opts);\n}\n\nfunction assertVariableDeclarator(node, opts) {\n  assert(\"VariableDeclarator\", node, opts);\n}\n\nfunction assertWhileStatement(node, opts) {\n  assert(\"WhileStatement\", node, opts);\n}\n\nfunction assertWithStatement(node, opts) {\n  assert(\"WithStatement\", node, opts);\n}\n\nfunction assertAssignmentPattern(node, opts) {\n  assert(\"AssignmentPattern\", node, opts);\n}\n\nfunction assertArrayPattern(node, opts) {\n  assert(\"ArrayPattern\", node, opts);\n}\n\nfunction assertArrowFunctionExpression(node, opts) {\n  assert(\"ArrowFunctionExpression\", node, opts);\n}\n\nfunction assertClassBody(node, opts) {\n  assert(\"ClassBody\", node, opts);\n}\n\nfunction assertClassExpression(node, opts) {\n  assert(\"ClassExpression\", node, opts);\n}\n\nfunction assertClassDeclaration(node, opts) {\n  assert(\"ClassDeclaration\", node, opts);\n}\n\nfunction assertExportAllDeclaration(node, opts) {\n  assert(\"ExportAllDeclaration\", node, opts);\n}\n\nfunction assertExportDefaultDeclaration(node, opts) {\n  assert(\"ExportDefaultDeclaration\", node, opts);\n}\n\nfunction assertExportNamedDeclaration(node, opts) {\n  assert(\"ExportNamedDeclaration\", node, opts);\n}\n\nfunction assertExportSpecifier(node, opts) {\n  assert(\"ExportSpecifier\", node, opts);\n}\n\nfunction assertForOfStatement(node, opts) {\n  assert(\"ForOfStatement\", node, opts);\n}\n\nfunction assertImportDeclaration(node, opts) {\n  assert(\"ImportDeclaration\", node, opts);\n}\n\nfunction assertImportDefaultSpecifier(node, opts) {\n  assert(\"ImportDefaultSpecifier\", node, opts);\n}\n\nfunction assertImportNamespaceSpecifier(node, opts) {\n  assert(\"ImportNamespaceSpecifier\", node, opts);\n}\n\nfunction assertImportSpecifier(node, opts) {\n  assert(\"ImportSpecifier\", node, opts);\n}\n\nfunction assertMetaProperty(node, opts) {\n  assert(\"MetaProperty\", node, opts);\n}\n\nfunction assertClassMethod(node, opts) {\n  assert(\"ClassMethod\", node, opts);\n}\n\nfunction assertObjectPattern(node, opts) {\n  assert(\"ObjectPattern\", node, opts);\n}\n\nfunction assertSpreadElement(node, opts) {\n  assert(\"SpreadElement\", node, opts);\n}\n\nfunction assertSuper(node, opts) {\n  assert(\"Super\", node, opts);\n}\n\nfunction assertTaggedTemplateExpression(node, opts) {\n  assert(\"TaggedTemplateExpression\", node, opts);\n}\n\nfunction assertTemplateElement(node, opts) {\n  assert(\"TemplateElement\", node, opts);\n}\n\nfunction assertTemplateLiteral(node, opts) {\n  assert(\"TemplateLiteral\", node, opts);\n}\n\nfunction assertYieldExpression(node, opts) {\n  assert(\"YieldExpression\", node, opts);\n}\n\nfunction assertAwaitExpression(node, opts) {\n  assert(\"AwaitExpression\", node, opts);\n}\n\nfunction assertImport(node, opts) {\n  assert(\"Import\", node, opts);\n}\n\nfunction assertBigIntLiteral(node, opts) {\n  assert(\"BigIntLiteral\", node, opts);\n}\n\nfunction assertExportNamespaceSpecifier(node, opts) {\n  assert(\"ExportNamespaceSpecifier\", node, opts);\n}\n\nfunction assertOptionalMemberExpression(node, opts) {\n  assert(\"OptionalMemberExpression\", node, opts);\n}\n\nfunction assertOptionalCallExpression(node, opts) {\n  assert(\"OptionalCallExpression\", node, opts);\n}\n\nfunction assertClassProperty(node, opts) {\n  assert(\"ClassProperty\", node, opts);\n}\n\nfunction assertClassPrivateProperty(node, opts) {\n  assert(\"ClassPrivateProperty\", node, opts);\n}\n\nfunction assertClassPrivateMethod(node, opts) {\n  assert(\"ClassPrivateMethod\", node, opts);\n}\n\nfunction assertPrivateName(node, opts) {\n  assert(\"PrivateName\", node, opts);\n}\n\nfunction assertAnyTypeAnnotation(node, opts) {\n  assert(\"AnyTypeAnnotation\", node, opts);\n}\n\nfunction assertArrayTypeAnnotation(node, opts) {\n  assert(\"ArrayTypeAnnotation\", node, opts);\n}\n\nfunction assertBooleanTypeAnnotation(node, opts) {\n  assert(\"BooleanTypeAnnotation\", node, opts);\n}\n\nfunction assertBooleanLiteralTypeAnnotation(node, opts) {\n  assert(\"BooleanLiteralTypeAnnotation\", node, opts);\n}\n\nfunction assertNullLiteralTypeAnnotation(node, opts) {\n  assert(\"NullLiteralTypeAnnotation\", node, opts);\n}\n\nfunction assertClassImplements(node, opts) {\n  assert(\"ClassImplements\", node, opts);\n}\n\nfunction assertDeclareClass(node, opts) {\n  assert(\"DeclareClass\", node, opts);\n}\n\nfunction assertDeclareFunction(node, opts) {\n  assert(\"DeclareFunction\", node, opts);\n}\n\nfunction assertDeclareInterface(node, opts) {\n  assert(\"DeclareInterface\", node, opts);\n}\n\nfunction assertDeclareModule(node, opts) {\n  assert(\"DeclareModule\", node, opts);\n}\n\nfunction assertDeclareModuleExports(node, opts) {\n  assert(\"DeclareModuleExports\", node, opts);\n}\n\nfunction assertDeclareTypeAlias(node, opts) {\n  assert(\"DeclareTypeAlias\", node, opts);\n}\n\nfunction assertDeclareOpaqueType(node, opts) {\n  assert(\"DeclareOpaqueType\", node, opts);\n}\n\nfunction assertDeclareVariable(node, opts) {\n  assert(\"DeclareVariable\", node, opts);\n}\n\nfunction assertDeclareExportDeclaration(node, opts) {\n  assert(\"DeclareExportDeclaration\", node, opts);\n}\n\nfunction assertDeclareExportAllDeclaration(node, opts) {\n  assert(\"DeclareExportAllDeclaration\", node, opts);\n}\n\nfunction assertDeclaredPredicate(node, opts) {\n  assert(\"DeclaredPredicate\", node, opts);\n}\n\nfunction assertExistsTypeAnnotation(node, opts) {\n  assert(\"ExistsTypeAnnotation\", node, opts);\n}\n\nfunction assertFunctionTypeAnnotation(node, opts) {\n  assert(\"FunctionTypeAnnotation\", node, opts);\n}\n\nfunction assertFunctionTypeParam(node, opts) {\n  assert(\"FunctionTypeParam\", node, opts);\n}\n\nfunction assertGenericTypeAnnotation(node, opts) {\n  assert(\"GenericTypeAnnotation\", node, opts);\n}\n\nfunction assertInferredPredicate(node, opts) {\n  assert(\"InferredPredicate\", node, opts);\n}\n\nfunction assertInterfaceExtends(node, opts) {\n  assert(\"InterfaceExtends\", node, opts);\n}\n\nfunction assertInterfaceDeclaration(node, opts) {\n  assert(\"InterfaceDeclaration\", node, opts);\n}\n\nfunction assertInterfaceTypeAnnotation(node, opts) {\n  assert(\"InterfaceTypeAnnotation\", node, opts);\n}\n\nfunction assertIntersectionTypeAnnotation(node, opts) {\n  assert(\"IntersectionTypeAnnotation\", node, opts);\n}\n\nfunction assertMixedTypeAnnotation(node, opts) {\n  assert(\"MixedTypeAnnotation\", node, opts);\n}\n\nfunction assertEmptyTypeAnnotation(node, opts) {\n  assert(\"EmptyTypeAnnotation\", node, opts);\n}\n\nfunction assertNullableTypeAnnotation(node, opts) {\n  assert(\"NullableTypeAnnotation\", node, opts);\n}\n\nfunction assertNumberLiteralTypeAnnotation(node, opts) {\n  assert(\"NumberLiteralTypeAnnotation\", node, opts);\n}\n\nfunction assertNumberTypeAnnotation(node, opts) {\n  assert(\"NumberTypeAnnotation\", node, opts);\n}\n\nfunction assertObjectTypeAnnotation(node, opts) {\n  assert(\"ObjectTypeAnnotation\", node, opts);\n}\n\nfunction assertObjectTypeInternalSlot(node, opts) {\n  assert(\"ObjectTypeInternalSlot\", node, opts);\n}\n\nfunction assertObjectTypeCallProperty(node, opts) {\n  assert(\"ObjectTypeCallProperty\", node, opts);\n}\n\nfunction assertObjectTypeIndexer(node, opts) {\n  assert(\"ObjectTypeIndexer\", node, opts);\n}\n\nfunction assertObjectTypeProperty(node, opts) {\n  assert(\"ObjectTypeProperty\", node, opts);\n}\n\nfunction assertObjectTypeSpreadProperty(node, opts) {\n  assert(\"ObjectTypeSpreadProperty\", node, opts);\n}\n\nfunction assertOpaqueType(node, opts) {\n  assert(\"OpaqueType\", node, opts);\n}\n\nfunction assertQualifiedTypeIdentifier(node, opts) {\n  assert(\"QualifiedTypeIdentifier\", node, opts);\n}\n\nfunction assertStringLiteralTypeAnnotation(node, opts) {\n  assert(\"StringLiteralTypeAnnotation\", node, opts);\n}\n\nfunction assertStringTypeAnnotation(node, opts) {\n  assert(\"StringTypeAnnotation\", node, opts);\n}\n\nfunction assertSymbolTypeAnnotation(node, opts) {\n  assert(\"SymbolTypeAnnotation\", node, opts);\n}\n\nfunction assertThisTypeAnnotation(node, opts) {\n  assert(\"ThisTypeAnnotation\", node, opts);\n}\n\nfunction assertTupleTypeAnnotation(node, opts) {\n  assert(\"TupleTypeAnnotation\", node, opts);\n}\n\nfunction assertTypeofTypeAnnotation(node, opts) {\n  assert(\"TypeofTypeAnnotation\", node, opts);\n}\n\nfunction assertTypeAlias(node, opts) {\n  assert(\"TypeAlias\", node, opts);\n}\n\nfunction assertTypeAnnotation(node, opts) {\n  assert(\"TypeAnnotation\", node, opts);\n}\n\nfunction assertTypeCastExpression(node, opts) {\n  assert(\"TypeCastExpression\", node, opts);\n}\n\nfunction assertTypeParameter(node, opts) {\n  assert(\"TypeParameter\", node, opts);\n}\n\nfunction assertTypeParameterDeclaration(node, opts) {\n  assert(\"TypeParameterDeclaration\", node, opts);\n}\n\nfunction assertTypeParameterInstantiation(node, opts) {\n  assert(\"TypeParameterInstantiation\", node, opts);\n}\n\nfunction assertUnionTypeAnnotation(node, opts) {\n  assert(\"UnionTypeAnnotation\", node, opts);\n}\n\nfunction assertVariance(node, opts) {\n  assert(\"Variance\", node, opts);\n}\n\nfunction assertVoidTypeAnnotation(node, opts) {\n  assert(\"VoidTypeAnnotation\", node, opts);\n}\n\nfunction assertEnumDeclaration(node, opts) {\n  assert(\"EnumDeclaration\", node, opts);\n}\n\nfunction assertEnumBooleanBody(node, opts) {\n  assert(\"EnumBooleanBody\", node, opts);\n}\n\nfunction assertEnumNumberBody(node, opts) {\n  assert(\"EnumNumberBody\", node, opts);\n}\n\nfunction assertEnumStringBody(node, opts) {\n  assert(\"EnumStringBody\", node, opts);\n}\n\nfunction assertEnumSymbolBody(node, opts) {\n  assert(\"EnumSymbolBody\", node, opts);\n}\n\nfunction assertEnumBooleanMember(node, opts) {\n  assert(\"EnumBooleanMember\", node, opts);\n}\n\nfunction assertEnumNumberMember(node, opts) {\n  assert(\"EnumNumberMember\", node, opts);\n}\n\nfunction assertEnumStringMember(node, opts) {\n  assert(\"EnumStringMember\", node, opts);\n}\n\nfunction assertEnumDefaultedMember(node, opts) {\n  assert(\"EnumDefaultedMember\", node, opts);\n}\n\nfunction assertIndexedAccessType(node, opts) {\n  assert(\"IndexedAccessType\", node, opts);\n}\n\nfunction assertOptionalIndexedAccessType(node, opts) {\n  assert(\"OptionalIndexedAccessType\", node, opts);\n}\n\nfunction assertJSXAttribute(node, opts) {\n  assert(\"JSXAttribute\", node, opts);\n}\n\nfunction assertJSXClosingElement(node, opts) {\n  assert(\"JSXClosingElement\", node, opts);\n}\n\nfunction assertJSXElement(node, opts) {\n  assert(\"JSXElement\", node, opts);\n}\n\nfunction assertJSXEmptyExpression(node, opts) {\n  assert(\"JSXEmptyExpression\", node, opts);\n}\n\nfunction assertJSXExpressionContainer(node, opts) {\n  assert(\"JSXExpressionContainer\", node, opts);\n}\n\nfunction assertJSXSpreadChild(node, opts) {\n  assert(\"JSXSpreadChild\", node, opts);\n}\n\nfunction assertJSXIdentifier(node, opts) {\n  assert(\"JSXIdentifier\", node, opts);\n}\n\nfunction assertJSXMemberExpression(node, opts) {\n  assert(\"JSXMemberExpression\", node, opts);\n}\n\nfunction assertJSXNamespacedName(node, opts) {\n  assert(\"JSXNamespacedName\", node, opts);\n}\n\nfunction assertJSXOpeningElement(node, opts) {\n  assert(\"JSXOpeningElement\", node, opts);\n}\n\nfunction assertJSXSpreadAttribute(node, opts) {\n  assert(\"JSXSpreadAttribute\", node, opts);\n}\n\nfunction assertJSXText(node, opts) {\n  assert(\"JSXText\", node, opts);\n}\n\nfunction assertJSXFragment(node, opts) {\n  assert(\"JSXFragment\", node, opts);\n}\n\nfunction assertJSXOpeningFragment(node, opts) {\n  assert(\"JSXOpeningFragment\", node, opts);\n}\n\nfunction assertJSXClosingFragment(node, opts) {\n  assert(\"JSXClosingFragment\", node, opts);\n}\n\nfunction assertNoop(node, opts) {\n  assert(\"Noop\", node, opts);\n}\n\nfunction assertPlaceholder(node, opts) {\n  assert(\"Placeholder\", node, opts);\n}\n\nfunction assertV8IntrinsicIdentifier(node, opts) {\n  assert(\"V8IntrinsicIdentifier\", node, opts);\n}\n\nfunction assertArgumentPlaceholder(node, opts) {\n  assert(\"ArgumentPlaceholder\", node, opts);\n}\n\nfunction assertBindExpression(node, opts) {\n  assert(\"BindExpression\", node, opts);\n}\n\nfunction assertImportAttribute(node, opts) {\n  assert(\"ImportAttribute\", node, opts);\n}\n\nfunction assertDecorator(node, opts) {\n  assert(\"Decorator\", node, opts);\n}\n\nfunction assertDoExpression(node, opts) {\n  assert(\"DoExpression\", node, opts);\n}\n\nfunction assertExportDefaultSpecifier(node, opts) {\n  assert(\"ExportDefaultSpecifier\", node, opts);\n}\n\nfunction assertRecordExpression(node, opts) {\n  assert(\"RecordExpression\", node, opts);\n}\n\nfunction assertTupleExpression(node, opts) {\n  assert(\"TupleExpression\", node, opts);\n}\n\nfunction assertDecimalLiteral(node, opts) {\n  assert(\"DecimalLiteral\", node, opts);\n}\n\nfunction assertStaticBlock(node, opts) {\n  assert(\"StaticBlock\", node, opts);\n}\n\nfunction assertModuleExpression(node, opts) {\n  assert(\"ModuleExpression\", node, opts);\n}\n\nfunction assertTopicReference(node, opts) {\n  assert(\"TopicReference\", node, opts);\n}\n\nfunction assertPipelineTopicExpression(node, opts) {\n  assert(\"PipelineTopicExpression\", node, opts);\n}\n\nfunction assertPipelineBareFunction(node, opts) {\n  assert(\"PipelineBareFunction\", node, opts);\n}\n\nfunction assertPipelinePrimaryTopicReference(node, opts) {\n  assert(\"PipelinePrimaryTopicReference\", node, opts);\n}\n\nfunction assertTSParameterProperty(node, opts) {\n  assert(\"TSParameterProperty\", node, opts);\n}\n\nfunction assertTSDeclareFunction(node, opts) {\n  assert(\"TSDeclareFunction\", node, opts);\n}\n\nfunction assertTSDeclareMethod(node, opts) {\n  assert(\"TSDeclareMethod\", node, opts);\n}\n\nfunction assertTSQualifiedName(node, opts) {\n  assert(\"TSQualifiedName\", node, opts);\n}\n\nfunction assertTSCallSignatureDeclaration(node, opts) {\n  assert(\"TSCallSignatureDeclaration\", node, opts);\n}\n\nfunction assertTSConstructSignatureDeclaration(node, opts) {\n  assert(\"TSConstructSignatureDeclaration\", node, opts);\n}\n\nfunction assertTSPropertySignature(node, opts) {\n  assert(\"TSPropertySignature\", node, opts);\n}\n\nfunction assertTSMethodSignature(node, opts) {\n  assert(\"TSMethodSignature\", node, opts);\n}\n\nfunction assertTSIndexSignature(node, opts) {\n  assert(\"TSIndexSignature\", node, opts);\n}\n\nfunction assertTSAnyKeyword(node, opts) {\n  assert(\"TSAnyKeyword\", node, opts);\n}\n\nfunction assertTSBooleanKeyword(node, opts) {\n  assert(\"TSBooleanKeyword\", node, opts);\n}\n\nfunction assertTSBigIntKeyword(node, opts) {\n  assert(\"TSBigIntKeyword\", node, opts);\n}\n\nfunction assertTSIntrinsicKeyword(node, opts) {\n  assert(\"TSIntrinsicKeyword\", node, opts);\n}\n\nfunction assertTSNeverKeyword(node, opts) {\n  assert(\"TSNeverKeyword\", node, opts);\n}\n\nfunction assertTSNullKeyword(node, opts) {\n  assert(\"TSNullKeyword\", node, opts);\n}\n\nfunction assertTSNumberKeyword(node, opts) {\n  assert(\"TSNumberKeyword\", node, opts);\n}\n\nfunction assertTSObjectKeyword(node, opts) {\n  assert(\"TSObjectKeyword\", node, opts);\n}\n\nfunction assertTSStringKeyword(node, opts) {\n  assert(\"TSStringKeyword\", node, opts);\n}\n\nfunction assertTSSymbolKeyword(node, opts) {\n  assert(\"TSSymbolKeyword\", node, opts);\n}\n\nfunction assertTSUndefinedKeyword(node, opts) {\n  assert(\"TSUndefinedKeyword\", node, opts);\n}\n\nfunction assertTSUnknownKeyword(node, opts) {\n  assert(\"TSUnknownKeyword\", node, opts);\n}\n\nfunction assertTSVoidKeyword(node, opts) {\n  assert(\"TSVoidKeyword\", node, opts);\n}\n\nfunction assertTSThisType(node, opts) {\n  assert(\"TSThisType\", node, opts);\n}\n\nfunction assertTSFunctionType(node, opts) {\n  assert(\"TSFunctionType\", node, opts);\n}\n\nfunction assertTSConstructorType(node, opts) {\n  assert(\"TSConstructorType\", node, opts);\n}\n\nfunction assertTSTypeReference(node, opts) {\n  assert(\"TSTypeReference\", node, opts);\n}\n\nfunction assertTSTypePredicate(node, opts) {\n  assert(\"TSTypePredicate\", node, opts);\n}\n\nfunction assertTSTypeQuery(node, opts) {\n  assert(\"TSTypeQuery\", node, opts);\n}\n\nfunction assertTSTypeLiteral(node, opts) {\n  assert(\"TSTypeLiteral\", node, opts);\n}\n\nfunction assertTSArrayType(node, opts) {\n  assert(\"TSArrayType\", node, opts);\n}\n\nfunction assertTSTupleType(node, opts) {\n  assert(\"TSTupleType\", node, opts);\n}\n\nfunction assertTSOptionalType(node, opts) {\n  assert(\"TSOptionalType\", node, opts);\n}\n\nfunction assertTSRestType(node, opts) {\n  assert(\"TSRestType\", node, opts);\n}\n\nfunction assertTSNamedTupleMember(node, opts) {\n  assert(\"TSNamedTupleMember\", node, opts);\n}\n\nfunction assertTSUnionType(node, opts) {\n  assert(\"TSUnionType\", node, opts);\n}\n\nfunction assertTSIntersectionType(node, opts) {\n  assert(\"TSIntersectionType\", node, opts);\n}\n\nfunction assertTSConditionalType(node, opts) {\n  assert(\"TSConditionalType\", node, opts);\n}\n\nfunction assertTSInferType(node, opts) {\n  assert(\"TSInferType\", node, opts);\n}\n\nfunction assertTSParenthesizedType(node, opts) {\n  assert(\"TSParenthesizedType\", node, opts);\n}\n\nfunction assertTSTypeOperator(node, opts) {\n  assert(\"TSTypeOperator\", node, opts);\n}\n\nfunction assertTSIndexedAccessType(node, opts) {\n  assert(\"TSIndexedAccessType\", node, opts);\n}\n\nfunction assertTSMappedType(node, opts) {\n  assert(\"TSMappedType\", node, opts);\n}\n\nfunction assertTSLiteralType(node, opts) {\n  assert(\"TSLiteralType\", node, opts);\n}\n\nfunction assertTSExpressionWithTypeArguments(node, opts) {\n  assert(\"TSExpressionWithTypeArguments\", node, opts);\n}\n\nfunction assertTSInterfaceDeclaration(node, opts) {\n  assert(\"TSInterfaceDeclaration\", node, opts);\n}\n\nfunction assertTSInterfaceBody(node, opts) {\n  assert(\"TSInterfaceBody\", node, opts);\n}\n\nfunction assertTSTypeAliasDeclaration(node, opts) {\n  assert(\"TSTypeAliasDeclaration\", node, opts);\n}\n\nfunction assertTSAsExpression(node, opts) {\n  assert(\"TSAsExpression\", node, opts);\n}\n\nfunction assertTSTypeAssertion(node, opts) {\n  assert(\"TSTypeAssertion\", node, opts);\n}\n\nfunction assertTSEnumDeclaration(node, opts) {\n  assert(\"TSEnumDeclaration\", node, opts);\n}\n\nfunction assertTSEnumMember(node, opts) {\n  assert(\"TSEnumMember\", node, opts);\n}\n\nfunction assertTSModuleDeclaration(node, opts) {\n  assert(\"TSModuleDeclaration\", node, opts);\n}\n\nfunction assertTSModuleBlock(node, opts) {\n  assert(\"TSModuleBlock\", node, opts);\n}\n\nfunction assertTSImportType(node, opts) {\n  assert(\"TSImportType\", node, opts);\n}\n\nfunction assertTSImportEqualsDeclaration(node, opts) {\n  assert(\"TSImportEqualsDeclaration\", node, opts);\n}\n\nfunction assertTSExternalModuleReference(node, opts) {\n  assert(\"TSExternalModuleReference\", node, opts);\n}\n\nfunction assertTSNonNullExpression(node, opts) {\n  assert(\"TSNonNullExpression\", node, opts);\n}\n\nfunction assertTSExportAssignment(node, opts) {\n  assert(\"TSExportAssignment\", node, opts);\n}\n\nfunction assertTSNamespaceExportDeclaration(node, opts) {\n  assert(\"TSNamespaceExportDeclaration\", node, opts);\n}\n\nfunction assertTSTypeAnnotation(node, opts) {\n  assert(\"TSTypeAnnotation\", node, opts);\n}\n\nfunction assertTSTypeParameterInstantiation(node, opts) {\n  assert(\"TSTypeParameterInstantiation\", node, opts);\n}\n\nfunction assertTSTypeParameterDeclaration(node, opts) {\n  assert(\"TSTypeParameterDeclaration\", node, opts);\n}\n\nfunction assertTSTypeParameter(node, opts) {\n  assert(\"TSTypeParameter\", node, opts);\n}\n\nfunction assertExpression(node, opts) {\n  assert(\"Expression\", node, opts);\n}\n\nfunction assertBinary(node, opts) {\n  assert(\"Binary\", node, opts);\n}\n\nfunction assertScopable(node, opts) {\n  assert(\"Scopable\", node, opts);\n}\n\nfunction assertBlockParent(node, opts) {\n  assert(\"BlockParent\", node, opts);\n}\n\nfunction assertBlock(node, opts) {\n  assert(\"Block\", node, opts);\n}\n\nfunction assertStatement(node, opts) {\n  assert(\"Statement\", node, opts);\n}\n\nfunction assertTerminatorless(node, opts) {\n  assert(\"Terminatorless\", node, opts);\n}\n\nfunction assertCompletionStatement(node, opts) {\n  assert(\"CompletionStatement\", node, opts);\n}\n\nfunction assertConditional(node, opts) {\n  assert(\"Conditional\", node, opts);\n}\n\nfunction assertLoop(node, opts) {\n  assert(\"Loop\", node, opts);\n}\n\nfunction assertWhile(node, opts) {\n  assert(\"While\", node, opts);\n}\n\nfunction assertExpressionWrapper(node, opts) {\n  assert(\"ExpressionWrapper\", node, opts);\n}\n\nfunction assertFor(node, opts) {\n  assert(\"For\", node, opts);\n}\n\nfunction assertForXStatement(node, opts) {\n  assert(\"ForXStatement\", node, opts);\n}\n\nfunction assertFunction(node, opts) {\n  assert(\"Function\", node, opts);\n}\n\nfunction assertFunctionParent(node, opts) {\n  assert(\"FunctionParent\", node, opts);\n}\n\nfunction assertPureish(node, opts) {\n  assert(\"Pureish\", node, opts);\n}\n\nfunction assertDeclaration(node, opts) {\n  assert(\"Declaration\", node, opts);\n}\n\nfunction assertPatternLike(node, opts) {\n  assert(\"PatternLike\", node, opts);\n}\n\nfunction assertLVal(node, opts) {\n  assert(\"LVal\", node, opts);\n}\n\nfunction assertTSEntityName(node, opts) {\n  assert(\"TSEntityName\", node, opts);\n}\n\nfunction assertLiteral(node, opts) {\n  assert(\"Literal\", node, opts);\n}\n\nfunction assertImmutable(node, opts) {\n  assert(\"Immutable\", node, opts);\n}\n\nfunction assertUserWhitespacable(node, opts) {\n  assert(\"UserWhitespacable\", node, opts);\n}\n\nfunction assertMethod(node, opts) {\n  assert(\"Method\", node, opts);\n}\n\nfunction assertObjectMember(node, opts) {\n  assert(\"ObjectMember\", node, opts);\n}\n\nfunction assertProperty(node, opts) {\n  assert(\"Property\", node, opts);\n}\n\nfunction assertUnaryLike(node, opts) {\n  assert(\"UnaryLike\", node, opts);\n}\n\nfunction assertPattern(node, opts) {\n  assert(\"Pattern\", node, opts);\n}\n\nfunction assertClass(node, opts) {\n  assert(\"Class\", node, opts);\n}\n\nfunction assertModuleDeclaration(node, opts) {\n  assert(\"ModuleDeclaration\", node, opts);\n}\n\nfunction assertExportDeclaration(node, opts) {\n  assert(\"ExportDeclaration\", node, opts);\n}\n\nfunction assertModuleSpecifier(node, opts) {\n  assert(\"ModuleSpecifier\", node, opts);\n}\n\nfunction assertPrivate(node, opts) {\n  assert(\"Private\", node, opts);\n}\n\nfunction assertFlow(node, opts) {\n  assert(\"Flow\", node, opts);\n}\n\nfunction assertFlowType(node, opts) {\n  assert(\"FlowType\", node, opts);\n}\n\nfunction assertFlowBaseAnnotation(node, opts) {\n  assert(\"FlowBaseAnnotation\", node, opts);\n}\n\nfunction assertFlowDeclaration(node, opts) {\n  assert(\"FlowDeclaration\", node, opts);\n}\n\nfunction assertFlowPredicate(node, opts) {\n  assert(\"FlowPredicate\", node, opts);\n}\n\nfunction assertEnumBody(node, opts) {\n  assert(\"EnumBody\", node, opts);\n}\n\nfunction assertEnumMember(node, opts) {\n  assert(\"EnumMember\", node, opts);\n}\n\nfunction assertJSX(node, opts) {\n  assert(\"JSX\", node, opts);\n}\n\nfunction assertTSTypeElement(node, opts) {\n  assert(\"TSTypeElement\", node, opts);\n}\n\nfunction assertTSType(node, opts) {\n  assert(\"TSType\", node, opts);\n}\n\nfunction assertTSBaseType(node, opts) {\n  assert(\"TSBaseType\", node, opts);\n}\n\nfunction assertNumberLiteral(node, opts) {\n  console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n  assert(\"NumberLiteral\", node, opts);\n}\n\nfunction assertRegexLiteral(node, opts) {\n  console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n  assert(\"RegexLiteral\", node, opts);\n}\n\nfunction assertRestProperty(node, opts) {\n  console.trace(\"The node type RestProperty has been renamed to RestElement\");\n  assert(\"RestProperty\", node, opts);\n}\n\nfunction assertSpreadProperty(node, opts) {\n  console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n  assert(\"SpreadProperty\", node, opts);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = builder;\n\nvar _definitions = require(\"../definitions\");\n\nvar _validate = require(\"../validators/validate\");\n\nfunction builder(type, ...args) {\n  const keys = _definitions.BUILDER_KEYS[type];\n  const countArgs = args.length;\n\n  if (countArgs > keys.length) {\n    throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);\n  }\n\n  const node = {\n    type\n  };\n  let i = 0;\n  keys.forEach(key => {\n    const field = _definitions.NODE_FIELDS[type][key];\n    let arg;\n    if (i < countArgs) arg = args[i];\n\n    if (arg === undefined) {\n      arg = Array.isArray(field.default) ? [] : field.default;\n    }\n\n    node[key] = arg;\n    i++;\n  });\n\n  for (const key of Object.keys(node)) {\n    (0, _validate.default)(node, key, node[key]);\n  }\n\n  return node;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFlowUnionType;\n\nvar _generated = require(\"../generated\");\n\nvar _removeTypeDuplicates = require(\"../../modifications/flow/removeTypeDuplicates\");\n\nfunction createFlowUnionType(types) {\n  const flattened = (0, _removeTypeDuplicates.default)(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _generated.unionTypeAnnotation)(flattened);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createTypeAnnotationBasedOnTypeof;\n\nvar _generated = require(\"../generated\");\n\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  if (type === \"string\") {\n    return (0, _generated.stringTypeAnnotation)();\n  } else if (type === \"number\") {\n    return (0, _generated.numberTypeAnnotation)();\n  } else if (type === \"undefined\") {\n    return (0, _generated.voidTypeAnnotation)();\n  } else if (type === \"boolean\") {\n    return (0, _generated.booleanTypeAnnotation)();\n  } else if (type === \"function\") {\n    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)(\"Function\"));\n  } else if (type === \"object\") {\n    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)(\"Object\"));\n  } else if (type === \"symbol\") {\n    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)(\"Symbol\"));\n  } else if (type === \"bigint\") {\n    return (0, _generated.anyTypeAnnotation)();\n  } else {\n    throw new Error(\"Invalid typeof value: \" + type);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrayExpression = arrayExpression;\nexports.assignmentExpression = assignmentExpression;\nexports.binaryExpression = binaryExpression;\nexports.interpreterDirective = interpreterDirective;\nexports.directive = directive;\nexports.directiveLiteral = directiveLiteral;\nexports.blockStatement = blockStatement;\nexports.breakStatement = breakStatement;\nexports.callExpression = callExpression;\nexports.catchClause = catchClause;\nexports.conditionalExpression = conditionalExpression;\nexports.continueStatement = continueStatement;\nexports.debuggerStatement = debuggerStatement;\nexports.doWhileStatement = doWhileStatement;\nexports.emptyStatement = emptyStatement;\nexports.expressionStatement = expressionStatement;\nexports.file = file;\nexports.forInStatement = forInStatement;\nexports.forStatement = forStatement;\nexports.functionDeclaration = functionDeclaration;\nexports.functionExpression = functionExpression;\nexports.identifier = identifier;\nexports.ifStatement = ifStatement;\nexports.labeledStatement = labeledStatement;\nexports.stringLiteral = stringLiteral;\nexports.numericLiteral = numericLiteral;\nexports.nullLiteral = nullLiteral;\nexports.booleanLiteral = booleanLiteral;\nexports.regExpLiteral = regExpLiteral;\nexports.logicalExpression = logicalExpression;\nexports.memberExpression = memberExpression;\nexports.newExpression = newExpression;\nexports.program = program;\nexports.objectExpression = objectExpression;\nexports.objectMethod = objectMethod;\nexports.objectProperty = objectProperty;\nexports.restElement = restElement;\nexports.returnStatement = returnStatement;\nexports.sequenceExpression = sequenceExpression;\nexports.parenthesizedExpression = parenthesizedExpression;\nexports.switchCase = switchCase;\nexports.switchStatement = switchStatement;\nexports.thisExpression = thisExpression;\nexports.throwStatement = throwStatement;\nexports.tryStatement = tryStatement;\nexports.unaryExpression = unaryExpression;\nexports.updateExpression = updateExpression;\nexports.variableDeclaration = variableDeclaration;\nexports.variableDeclarator = variableDeclarator;\nexports.whileStatement = whileStatement;\nexports.withStatement = withStatement;\nexports.assignmentPattern = assignmentPattern;\nexports.arrayPattern = arrayPattern;\nexports.arrowFunctionExpression = arrowFunctionExpression;\nexports.classBody = classBody;\nexports.classExpression = classExpression;\nexports.classDeclaration = classDeclaration;\nexports.exportAllDeclaration = exportAllDeclaration;\nexports.exportDefaultDeclaration = exportDefaultDeclaration;\nexports.exportNamedDeclaration = exportNamedDeclaration;\nexports.exportSpecifier = exportSpecifier;\nexports.forOfStatement = forOfStatement;\nexports.importDeclaration = importDeclaration;\nexports.importDefaultSpecifier = importDefaultSpecifier;\nexports.importNamespaceSpecifier = importNamespaceSpecifier;\nexports.importSpecifier = importSpecifier;\nexports.metaProperty = metaProperty;\nexports.classMethod = classMethod;\nexports.objectPattern = objectPattern;\nexports.spreadElement = spreadElement;\nexports.super = _super;\nexports.taggedTemplateExpression = taggedTemplateExpression;\nexports.templateElement = templateElement;\nexports.templateLiteral = templateLiteral;\nexports.yieldExpression = yieldExpression;\nexports.awaitExpression = awaitExpression;\nexports.import = _import;\nexports.bigIntLiteral = bigIntLiteral;\nexports.exportNamespaceSpecifier = exportNamespaceSpecifier;\nexports.optionalMemberExpression = optionalMemberExpression;\nexports.optionalCallExpression = optionalCallExpression;\nexports.classProperty = classProperty;\nexports.classPrivateProperty = classPrivateProperty;\nexports.classPrivateMethod = classPrivateMethod;\nexports.privateName = privateName;\nexports.anyTypeAnnotation = anyTypeAnnotation;\nexports.arrayTypeAnnotation = arrayTypeAnnotation;\nexports.booleanTypeAnnotation = booleanTypeAnnotation;\nexports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;\nexports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;\nexports.classImplements = classImplements;\nexports.declareClass = declareClass;\nexports.declareFunction = declareFunction;\nexports.declareInterface = declareInterface;\nexports.declareModule = declareModule;\nexports.declareModuleExports = declareModuleExports;\nexports.declareTypeAlias = declareTypeAlias;\nexports.declareOpaqueType = declareOpaqueType;\nexports.declareVariable = declareVariable;\nexports.declareExportDeclaration = declareExportDeclaration;\nexports.declareExportAllDeclaration = declareExportAllDeclaration;\nexports.declaredPredicate = declaredPredicate;\nexports.existsTypeAnnotation = existsTypeAnnotation;\nexports.functionTypeAnnotation = functionTypeAnnotation;\nexports.functionTypeParam = functionTypeParam;\nexports.genericTypeAnnotation = genericTypeAnnotation;\nexports.inferredPredicate = inferredPredicate;\nexports.interfaceExtends = interfaceExtends;\nexports.interfaceDeclaration = interfaceDeclaration;\nexports.interfaceTypeAnnotation = interfaceTypeAnnotation;\nexports.intersectionTypeAnnotation = intersectionTypeAnnotation;\nexports.mixedTypeAnnotation = mixedTypeAnnotation;\nexports.emptyTypeAnnotation = emptyTypeAnnotation;\nexports.nullableTypeAnnotation = nullableTypeAnnotation;\nexports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;\nexports.numberTypeAnnotation = numberTypeAnnotation;\nexports.objectTypeAnnotation = objectTypeAnnotation;\nexports.objectTypeInternalSlot = objectTypeInternalSlot;\nexports.objectTypeCallProperty = objectTypeCallProperty;\nexports.objectTypeIndexer = objectTypeIndexer;\nexports.objectTypeProperty = objectTypeProperty;\nexports.objectTypeSpreadProperty = objectTypeSpreadProperty;\nexports.opaqueType = opaqueType;\nexports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;\nexports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;\nexports.stringTypeAnnotation = stringTypeAnnotation;\nexports.symbolTypeAnnotation = symbolTypeAnnotation;\nexports.thisTypeAnnotation = thisTypeAnnotation;\nexports.tupleTypeAnnotation = tupleTypeAnnotation;\nexports.typeofTypeAnnotation = typeofTypeAnnotation;\nexports.typeAlias = typeAlias;\nexports.typeAnnotation = typeAnnotation;\nexports.typeCastExpression = typeCastExpression;\nexports.typeParameter = typeParameter;\nexports.typeParameterDeclaration = typeParameterDeclaration;\nexports.typeParameterInstantiation = typeParameterInstantiation;\nexports.unionTypeAnnotation = unionTypeAnnotation;\nexports.variance = variance;\nexports.voidTypeAnnotation = voidTypeAnnotation;\nexports.enumDeclaration = enumDeclaration;\nexports.enumBooleanBody = enumBooleanBody;\nexports.enumNumberBody = enumNumberBody;\nexports.enumStringBody = enumStringBody;\nexports.enumSymbolBody = enumSymbolBody;\nexports.enumBooleanMember = enumBooleanMember;\nexports.enumNumberMember = enumNumberMember;\nexports.enumStringMember = enumStringMember;\nexports.enumDefaultedMember = enumDefaultedMember;\nexports.indexedAccessType = indexedAccessType;\nexports.optionalIndexedAccessType = optionalIndexedAccessType;\nexports.jSXAttribute = exports.jsxAttribute = jsxAttribute;\nexports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;\nexports.jSXElement = exports.jsxElement = jsxElement;\nexports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;\nexports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;\nexports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;\nexports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;\nexports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;\nexports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;\nexports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;\nexports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;\nexports.jSXText = exports.jsxText = jsxText;\nexports.jSXFragment = exports.jsxFragment = jsxFragment;\nexports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;\nexports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;\nexports.noop = noop;\nexports.placeholder = placeholder;\nexports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;\nexports.argumentPlaceholder = argumentPlaceholder;\nexports.bindExpression = bindExpression;\nexports.importAttribute = importAttribute;\nexports.decorator = decorator;\nexports.doExpression = doExpression;\nexports.exportDefaultSpecifier = exportDefaultSpecifier;\nexports.recordExpression = recordExpression;\nexports.tupleExpression = tupleExpression;\nexports.decimalLiteral = decimalLiteral;\nexports.staticBlock = staticBlock;\nexports.moduleExpression = moduleExpression;\nexports.topicReference = topicReference;\nexports.pipelineTopicExpression = pipelineTopicExpression;\nexports.pipelineBareFunction = pipelineBareFunction;\nexports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;\nexports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;\nexports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;\nexports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;\nexports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;\nexports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;\nexports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;\nexports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;\nexports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;\nexports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;\nexports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;\nexports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;\nexports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;\nexports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;\nexports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;\nexports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;\nexports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;\nexports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;\nexports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;\nexports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;\nexports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;\nexports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;\nexports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;\nexports.tSThisType = exports.tsThisType = tsThisType;\nexports.tSFunctionType = exports.tsFunctionType = tsFunctionType;\nexports.tSConstructorType = exports.tsConstructorType = tsConstructorType;\nexports.tSTypeReference = exports.tsTypeReference = tsTypeReference;\nexports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;\nexports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;\nexports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;\nexports.tSArrayType = exports.tsArrayType = tsArrayType;\nexports.tSTupleType = exports.tsTupleType = tsTupleType;\nexports.tSOptionalType = exports.tsOptionalType = tsOptionalType;\nexports.tSRestType = exports.tsRestType = tsRestType;\nexports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;\nexports.tSUnionType = exports.tsUnionType = tsUnionType;\nexports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;\nexports.tSConditionalType = exports.tsConditionalType = tsConditionalType;\nexports.tSInferType = exports.tsInferType = tsInferType;\nexports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;\nexports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;\nexports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;\nexports.tSMappedType = exports.tsMappedType = tsMappedType;\nexports.tSLiteralType = exports.tsLiteralType = tsLiteralType;\nexports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;\nexports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;\nexports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;\nexports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;\nexports.tSAsExpression = exports.tsAsExpression = tsAsExpression;\nexports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;\nexports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;\nexports.tSEnumMember = exports.tsEnumMember = tsEnumMember;\nexports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;\nexports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;\nexports.tSImportType = exports.tsImportType = tsImportType;\nexports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;\nexports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;\nexports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;\nexports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;\nexports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;\nexports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;\nexports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;\nexports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;\nexports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;\nexports.numberLiteral = NumberLiteral;\nexports.regexLiteral = RegexLiteral;\nexports.restProperty = RestProperty;\nexports.spreadProperty = SpreadProperty;\n\nvar _builder = require(\"../builder\");\n\nfunction arrayExpression(elements) {\n  return (0, _builder.default)(\"ArrayExpression\", ...arguments);\n}\n\nfunction assignmentExpression(operator, left, right) {\n  return (0, _builder.default)(\"AssignmentExpression\", ...arguments);\n}\n\nfunction binaryExpression(operator, left, right) {\n  return (0, _builder.default)(\"BinaryExpression\", ...arguments);\n}\n\nfunction interpreterDirective(value) {\n  return (0, _builder.default)(\"InterpreterDirective\", ...arguments);\n}\n\nfunction directive(value) {\n  return (0, _builder.default)(\"Directive\", ...arguments);\n}\n\nfunction directiveLiteral(value) {\n  return (0, _builder.default)(\"DirectiveLiteral\", ...arguments);\n}\n\nfunction blockStatement(body, directives) {\n  return (0, _builder.default)(\"BlockStatement\", ...arguments);\n}\n\nfunction breakStatement(label) {\n  return (0, _builder.default)(\"BreakStatement\", ...arguments);\n}\n\nfunction callExpression(callee, _arguments) {\n  return (0, _builder.default)(\"CallExpression\", ...arguments);\n}\n\nfunction catchClause(param, body) {\n  return (0, _builder.default)(\"CatchClause\", ...arguments);\n}\n\nfunction conditionalExpression(test, consequent, alternate) {\n  return (0, _builder.default)(\"ConditionalExpression\", ...arguments);\n}\n\nfunction continueStatement(label) {\n  return (0, _builder.default)(\"ContinueStatement\", ...arguments);\n}\n\nfunction debuggerStatement() {\n  return (0, _builder.default)(\"DebuggerStatement\", ...arguments);\n}\n\nfunction doWhileStatement(test, body) {\n  return (0, _builder.default)(\"DoWhileStatement\", ...arguments);\n}\n\nfunction emptyStatement() {\n  return (0, _builder.default)(\"EmptyStatement\", ...arguments);\n}\n\nfunction expressionStatement(expression) {\n  return (0, _builder.default)(\"ExpressionStatement\", ...arguments);\n}\n\nfunction file(program, comments, tokens) {\n  return (0, _builder.default)(\"File\", ...arguments);\n}\n\nfunction forInStatement(left, right, body) {\n  return (0, _builder.default)(\"ForInStatement\", ...arguments);\n}\n\nfunction forStatement(init, test, update, body) {\n  return (0, _builder.default)(\"ForStatement\", ...arguments);\n}\n\nfunction functionDeclaration(id, params, body, generator, async) {\n  return (0, _builder.default)(\"FunctionDeclaration\", ...arguments);\n}\n\nfunction functionExpression(id, params, body, generator, async) {\n  return (0, _builder.default)(\"FunctionExpression\", ...arguments);\n}\n\nfunction identifier(name) {\n  return (0, _builder.default)(\"Identifier\", ...arguments);\n}\n\nfunction ifStatement(test, consequent, alternate) {\n  return (0, _builder.default)(\"IfStatement\", ...arguments);\n}\n\nfunction labeledStatement(label, body) {\n  return (0, _builder.default)(\"LabeledStatement\", ...arguments);\n}\n\nfunction stringLiteral(value) {\n  return (0, _builder.default)(\"StringLiteral\", ...arguments);\n}\n\nfunction numericLiteral(value) {\n  return (0, _builder.default)(\"NumericLiteral\", ...arguments);\n}\n\nfunction nullLiteral() {\n  return (0, _builder.default)(\"NullLiteral\", ...arguments);\n}\n\nfunction booleanLiteral(value) {\n  return (0, _builder.default)(\"BooleanLiteral\", ...arguments);\n}\n\nfunction regExpLiteral(pattern, flags) {\n  return (0, _builder.default)(\"RegExpLiteral\", ...arguments);\n}\n\nfunction logicalExpression(operator, left, right) {\n  return (0, _builder.default)(\"LogicalExpression\", ...arguments);\n}\n\nfunction memberExpression(object, property, computed, optional) {\n  return (0, _builder.default)(\"MemberExpression\", ...arguments);\n}\n\nfunction newExpression(callee, _arguments) {\n  return (0, _builder.default)(\"NewExpression\", ...arguments);\n}\n\nfunction program(body, directives, sourceType, interpreter) {\n  return (0, _builder.default)(\"Program\", ...arguments);\n}\n\nfunction objectExpression(properties) {\n  return (0, _builder.default)(\"ObjectExpression\", ...arguments);\n}\n\nfunction objectMethod(kind, key, params, body, computed, generator, async) {\n  return (0, _builder.default)(\"ObjectMethod\", ...arguments);\n}\n\nfunction objectProperty(key, value, computed, shorthand, decorators) {\n  return (0, _builder.default)(\"ObjectProperty\", ...arguments);\n}\n\nfunction restElement(argument) {\n  return (0, _builder.default)(\"RestElement\", ...arguments);\n}\n\nfunction returnStatement(argument) {\n  return (0, _builder.default)(\"ReturnStatement\", ...arguments);\n}\n\nfunction sequenceExpression(expressions) {\n  return (0, _builder.default)(\"SequenceExpression\", ...arguments);\n}\n\nfunction parenthesizedExpression(expression) {\n  return (0, _builder.default)(\"ParenthesizedExpression\", ...arguments);\n}\n\nfunction switchCase(test, consequent) {\n  return (0, _builder.default)(\"SwitchCase\", ...arguments);\n}\n\nfunction switchStatement(discriminant, cases) {\n  return (0, _builder.default)(\"SwitchStatement\", ...arguments);\n}\n\nfunction thisExpression() {\n  return (0, _builder.default)(\"ThisExpression\", ...arguments);\n}\n\nfunction throwStatement(argument) {\n  return (0, _builder.default)(\"ThrowStatement\", ...arguments);\n}\n\nfunction tryStatement(block, handler, finalizer) {\n  return (0, _builder.default)(\"TryStatement\", ...arguments);\n}\n\nfunction unaryExpression(operator, argument, prefix) {\n  return (0, _builder.default)(\"UnaryExpression\", ...arguments);\n}\n\nfunction updateExpression(operator, argument, prefix) {\n  return (0, _builder.default)(\"UpdateExpression\", ...arguments);\n}\n\nfunction variableDeclaration(kind, declarations) {\n  return (0, _builder.default)(\"VariableDeclaration\", ...arguments);\n}\n\nfunction variableDeclarator(id, init) {\n  return (0, _builder.default)(\"VariableDeclarator\", ...arguments);\n}\n\nfunction whileStatement(test, body) {\n  return (0, _builder.default)(\"WhileStatement\", ...arguments);\n}\n\nfunction withStatement(object, body) {\n  return (0, _builder.default)(\"WithStatement\", ...arguments);\n}\n\nfunction assignmentPattern(left, right) {\n  return (0, _builder.default)(\"AssignmentPattern\", ...arguments);\n}\n\nfunction arrayPattern(elements) {\n  return (0, _builder.default)(\"ArrayPattern\", ...arguments);\n}\n\nfunction arrowFunctionExpression(params, body, async) {\n  return (0, _builder.default)(\"ArrowFunctionExpression\", ...arguments);\n}\n\nfunction classBody(body) {\n  return (0, _builder.default)(\"ClassBody\", ...arguments);\n}\n\nfunction classExpression(id, superClass, body, decorators) {\n  return (0, _builder.default)(\"ClassExpression\", ...arguments);\n}\n\nfunction classDeclaration(id, superClass, body, decorators) {\n  return (0, _builder.default)(\"ClassDeclaration\", ...arguments);\n}\n\nfunction exportAllDeclaration(source) {\n  return (0, _builder.default)(\"ExportAllDeclaration\", ...arguments);\n}\n\nfunction exportDefaultDeclaration(declaration) {\n  return (0, _builder.default)(\"ExportDefaultDeclaration\", ...arguments);\n}\n\nfunction exportNamedDeclaration(declaration, specifiers, source) {\n  return (0, _builder.default)(\"ExportNamedDeclaration\", ...arguments);\n}\n\nfunction exportSpecifier(local, exported) {\n  return (0, _builder.default)(\"ExportSpecifier\", ...arguments);\n}\n\nfunction forOfStatement(left, right, body, _await) {\n  return (0, _builder.default)(\"ForOfStatement\", ...arguments);\n}\n\nfunction importDeclaration(specifiers, source) {\n  return (0, _builder.default)(\"ImportDeclaration\", ...arguments);\n}\n\nfunction importDefaultSpecifier(local) {\n  return (0, _builder.default)(\"ImportDefaultSpecifier\", ...arguments);\n}\n\nfunction importNamespaceSpecifier(local) {\n  return (0, _builder.default)(\"ImportNamespaceSpecifier\", ...arguments);\n}\n\nfunction importSpecifier(local, imported) {\n  return (0, _builder.default)(\"ImportSpecifier\", ...arguments);\n}\n\nfunction metaProperty(meta, property) {\n  return (0, _builder.default)(\"MetaProperty\", ...arguments);\n}\n\nfunction classMethod(kind, key, params, body, computed, _static, generator, async) {\n  return (0, _builder.default)(\"ClassMethod\", ...arguments);\n}\n\nfunction objectPattern(properties) {\n  return (0, _builder.default)(\"ObjectPattern\", ...arguments);\n}\n\nfunction spreadElement(argument) {\n  return (0, _builder.default)(\"SpreadElement\", ...arguments);\n}\n\nfunction _super() {\n  return (0, _builder.default)(\"Super\", ...arguments);\n}\n\nfunction taggedTemplateExpression(tag, quasi) {\n  return (0, _builder.default)(\"TaggedTemplateExpression\", ...arguments);\n}\n\nfunction templateElement(value, tail) {\n  return (0, _builder.default)(\"TemplateElement\", ...arguments);\n}\n\nfunction templateLiteral(quasis, expressions) {\n  return (0, _builder.default)(\"TemplateLiteral\", ...arguments);\n}\n\nfunction yieldExpression(argument, delegate) {\n  return (0, _builder.default)(\"YieldExpression\", ...arguments);\n}\n\nfunction awaitExpression(argument) {\n  return (0, _builder.default)(\"AwaitExpression\", ...arguments);\n}\n\nfunction _import() {\n  return (0, _builder.default)(\"Import\", ...arguments);\n}\n\nfunction bigIntLiteral(value) {\n  return (0, _builder.default)(\"BigIntLiteral\", ...arguments);\n}\n\nfunction exportNamespaceSpecifier(exported) {\n  return (0, _builder.default)(\"ExportNamespaceSpecifier\", ...arguments);\n}\n\nfunction optionalMemberExpression(object, property, computed, optional) {\n  return (0, _builder.default)(\"OptionalMemberExpression\", ...arguments);\n}\n\nfunction optionalCallExpression(callee, _arguments, optional) {\n  return (0, _builder.default)(\"OptionalCallExpression\", ...arguments);\n}\n\nfunction classProperty(key, value, typeAnnotation, decorators, computed, _static) {\n  return (0, _builder.default)(\"ClassProperty\", ...arguments);\n}\n\nfunction classPrivateProperty(key, value, decorators, _static) {\n  return (0, _builder.default)(\"ClassPrivateProperty\", ...arguments);\n}\n\nfunction classPrivateMethod(kind, key, params, body, _static) {\n  return (0, _builder.default)(\"ClassPrivateMethod\", ...arguments);\n}\n\nfunction privateName(id) {\n  return (0, _builder.default)(\"PrivateName\", ...arguments);\n}\n\nfunction anyTypeAnnotation() {\n  return (0, _builder.default)(\"AnyTypeAnnotation\", ...arguments);\n}\n\nfunction arrayTypeAnnotation(elementType) {\n  return (0, _builder.default)(\"ArrayTypeAnnotation\", ...arguments);\n}\n\nfunction booleanTypeAnnotation() {\n  return (0, _builder.default)(\"BooleanTypeAnnotation\", ...arguments);\n}\n\nfunction booleanLiteralTypeAnnotation(value) {\n  return (0, _builder.default)(\"BooleanLiteralTypeAnnotation\", ...arguments);\n}\n\nfunction nullLiteralTypeAnnotation() {\n  return (0, _builder.default)(\"NullLiteralTypeAnnotation\", ...arguments);\n}\n\nfunction classImplements(id, typeParameters) {\n  return (0, _builder.default)(\"ClassImplements\", ...arguments);\n}\n\nfunction declareClass(id, typeParameters, _extends, body) {\n  return (0, _builder.default)(\"DeclareClass\", ...arguments);\n}\n\nfunction declareFunction(id) {\n  return (0, _builder.default)(\"DeclareFunction\", ...arguments);\n}\n\nfunction declareInterface(id, typeParameters, _extends, body) {\n  return (0, _builder.default)(\"DeclareInterface\", ...arguments);\n}\n\nfunction declareModule(id, body, kind) {\n  return (0, _builder.default)(\"DeclareModule\", ...arguments);\n}\n\nfunction declareModuleExports(typeAnnotation) {\n  return (0, _builder.default)(\"DeclareModuleExports\", ...arguments);\n}\n\nfunction declareTypeAlias(id, typeParameters, right) {\n  return (0, _builder.default)(\"DeclareTypeAlias\", ...arguments);\n}\n\nfunction declareOpaqueType(id, typeParameters, supertype) {\n  return (0, _builder.default)(\"DeclareOpaqueType\", ...arguments);\n}\n\nfunction declareVariable(id) {\n  return (0, _builder.default)(\"DeclareVariable\", ...arguments);\n}\n\nfunction declareExportDeclaration(declaration, specifiers, source) {\n  return (0, _builder.default)(\"DeclareExportDeclaration\", ...arguments);\n}\n\nfunction declareExportAllDeclaration(source) {\n  return (0, _builder.default)(\"DeclareExportAllDeclaration\", ...arguments);\n}\n\nfunction declaredPredicate(value) {\n  return (0, _builder.default)(\"DeclaredPredicate\", ...arguments);\n}\n\nfunction existsTypeAnnotation() {\n  return (0, _builder.default)(\"ExistsTypeAnnotation\", ...arguments);\n}\n\nfunction functionTypeAnnotation(typeParameters, params, rest, returnType) {\n  return (0, _builder.default)(\"FunctionTypeAnnotation\", ...arguments);\n}\n\nfunction functionTypeParam(name, typeAnnotation) {\n  return (0, _builder.default)(\"FunctionTypeParam\", ...arguments);\n}\n\nfunction genericTypeAnnotation(id, typeParameters) {\n  return (0, _builder.default)(\"GenericTypeAnnotation\", ...arguments);\n}\n\nfunction inferredPredicate() {\n  return (0, _builder.default)(\"InferredPredicate\", ...arguments);\n}\n\nfunction interfaceExtends(id, typeParameters) {\n  return (0, _builder.default)(\"InterfaceExtends\", ...arguments);\n}\n\nfunction interfaceDeclaration(id, typeParameters, _extends, body) {\n  return (0, _builder.default)(\"InterfaceDeclaration\", ...arguments);\n}\n\nfunction interfaceTypeAnnotation(_extends, body) {\n  return (0, _builder.default)(\"InterfaceTypeAnnotation\", ...arguments);\n}\n\nfunction intersectionTypeAnnotation(types) {\n  return (0, _builder.default)(\"IntersectionTypeAnnotation\", ...arguments);\n}\n\nfunction mixedTypeAnnotation() {\n  return (0, _builder.default)(\"MixedTypeAnnotation\", ...arguments);\n}\n\nfunction emptyTypeAnnotation() {\n  return (0, _builder.default)(\"EmptyTypeAnnotation\", ...arguments);\n}\n\nfunction nullableTypeAnnotation(typeAnnotation) {\n  return (0, _builder.default)(\"NullableTypeAnnotation\", ...arguments);\n}\n\nfunction numberLiteralTypeAnnotation(value) {\n  return (0, _builder.default)(\"NumberLiteralTypeAnnotation\", ...arguments);\n}\n\nfunction numberTypeAnnotation() {\n  return (0, _builder.default)(\"NumberTypeAnnotation\", ...arguments);\n}\n\nfunction objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {\n  return (0, _builder.default)(\"ObjectTypeAnnotation\", ...arguments);\n}\n\nfunction objectTypeInternalSlot(id, value, optional, _static, method) {\n  return (0, _builder.default)(\"ObjectTypeInternalSlot\", ...arguments);\n}\n\nfunction objectTypeCallProperty(value) {\n  return (0, _builder.default)(\"ObjectTypeCallProperty\", ...arguments);\n}\n\nfunction objectTypeIndexer(id, key, value, variance) {\n  return (0, _builder.default)(\"ObjectTypeIndexer\", ...arguments);\n}\n\nfunction objectTypeProperty(key, value, variance) {\n  return (0, _builder.default)(\"ObjectTypeProperty\", ...arguments);\n}\n\nfunction objectTypeSpreadProperty(argument) {\n  return (0, _builder.default)(\"ObjectTypeSpreadProperty\", ...arguments);\n}\n\nfunction opaqueType(id, typeParameters, supertype, impltype) {\n  return (0, _builder.default)(\"OpaqueType\", ...arguments);\n}\n\nfunction qualifiedTypeIdentifier(id, qualification) {\n  return (0, _builder.default)(\"QualifiedTypeIdentifier\", ...arguments);\n}\n\nfunction stringLiteralTypeAnnotation(value) {\n  return (0, _builder.default)(\"StringLiteralTypeAnnotation\", ...arguments);\n}\n\nfunction stringTypeAnnotation() {\n  return (0, _builder.default)(\"StringTypeAnnotation\", ...arguments);\n}\n\nfunction symbolTypeAnnotation() {\n  return (0, _builder.default)(\"SymbolTypeAnnotation\", ...arguments);\n}\n\nfunction thisTypeAnnotation() {\n  return (0, _builder.default)(\"ThisTypeAnnotation\", ...arguments);\n}\n\nfunction tupleTypeAnnotation(types) {\n  return (0, _builder.default)(\"TupleTypeAnnotation\", ...arguments);\n}\n\nfunction typeofTypeAnnotation(argument) {\n  return (0, _builder.default)(\"TypeofTypeAnnotation\", ...arguments);\n}\n\nfunction typeAlias(id, typeParameters, right) {\n  return (0, _builder.default)(\"TypeAlias\", ...arguments);\n}\n\nfunction typeAnnotation(typeAnnotation) {\n  return (0, _builder.default)(\"TypeAnnotation\", ...arguments);\n}\n\nfunction typeCastExpression(expression, typeAnnotation) {\n  return (0, _builder.default)(\"TypeCastExpression\", ...arguments);\n}\n\nfunction typeParameter(bound, _default, variance) {\n  return (0, _builder.default)(\"TypeParameter\", ...arguments);\n}\n\nfunction typeParameterDeclaration(params) {\n  return (0, _builder.default)(\"TypeParameterDeclaration\", ...arguments);\n}\n\nfunction typeParameterInstantiation(params) {\n  return (0, _builder.default)(\"TypeParameterInstantiation\", ...arguments);\n}\n\nfunction unionTypeAnnotation(types) {\n  return (0, _builder.default)(\"UnionTypeAnnotation\", ...arguments);\n}\n\nfunction variance(kind) {\n  return (0, _builder.default)(\"Variance\", ...arguments);\n}\n\nfunction voidTypeAnnotation() {\n  return (0, _builder.default)(\"VoidTypeAnnotation\", ...arguments);\n}\n\nfunction enumDeclaration(id, body) {\n  return (0, _builder.default)(\"EnumDeclaration\", ...arguments);\n}\n\nfunction enumBooleanBody(members) {\n  return (0, _builder.default)(\"EnumBooleanBody\", ...arguments);\n}\n\nfunction enumNumberBody(members) {\n  return (0, _builder.default)(\"EnumNumberBody\", ...arguments);\n}\n\nfunction enumStringBody(members) {\n  return (0, _builder.default)(\"EnumStringBody\", ...arguments);\n}\n\nfunction enumSymbolBody(members) {\n  return (0, _builder.default)(\"EnumSymbolBody\", ...arguments);\n}\n\nfunction enumBooleanMember(id) {\n  return (0, _builder.default)(\"EnumBooleanMember\", ...arguments);\n}\n\nfunction enumNumberMember(id, init) {\n  return (0, _builder.default)(\"EnumNumberMember\", ...arguments);\n}\n\nfunction enumStringMember(id, init) {\n  return (0, _builder.default)(\"EnumStringMember\", ...arguments);\n}\n\nfunction enumDefaultedMember(id) {\n  return (0, _builder.default)(\"EnumDefaultedMember\", ...arguments);\n}\n\nfunction indexedAccessType(objectType, indexType) {\n  return (0, _builder.default)(\"IndexedAccessType\", ...arguments);\n}\n\nfunction optionalIndexedAccessType(objectType, indexType) {\n  return (0, _builder.default)(\"OptionalIndexedAccessType\", ...arguments);\n}\n\nfunction jsxAttribute(name, value) {\n  return (0, _builder.default)(\"JSXAttribute\", ...arguments);\n}\n\nfunction jsxClosingElement(name) {\n  return (0, _builder.default)(\"JSXClosingElement\", ...arguments);\n}\n\nfunction jsxElement(openingElement, closingElement, children, selfClosing) {\n  return (0, _builder.default)(\"JSXElement\", ...arguments);\n}\n\nfunction jsxEmptyExpression() {\n  return (0, _builder.default)(\"JSXEmptyExpression\", ...arguments);\n}\n\nfunction jsxExpressionContainer(expression) {\n  return (0, _builder.default)(\"JSXExpressionContainer\", ...arguments);\n}\n\nfunction jsxSpreadChild(expression) {\n  return (0, _builder.default)(\"JSXSpreadChild\", ...arguments);\n}\n\nfunction jsxIdentifier(name) {\n  return (0, _builder.default)(\"JSXIdentifier\", ...arguments);\n}\n\nfunction jsxMemberExpression(object, property) {\n  return (0, _builder.default)(\"JSXMemberExpression\", ...arguments);\n}\n\nfunction jsxNamespacedName(namespace, name) {\n  return (0, _builder.default)(\"JSXNamespacedName\", ...arguments);\n}\n\nfunction jsxOpeningElement(name, attributes, selfClosing) {\n  return (0, _builder.default)(\"JSXOpeningElement\", ...arguments);\n}\n\nfunction jsxSpreadAttribute(argument) {\n  return (0, _builder.default)(\"JSXSpreadAttribute\", ...arguments);\n}\n\nfunction jsxText(value) {\n  return (0, _builder.default)(\"JSXText\", ...arguments);\n}\n\nfunction jsxFragment(openingFragment, closingFragment, children) {\n  return (0, _builder.default)(\"JSXFragment\", ...arguments);\n}\n\nfunction jsxOpeningFragment() {\n  return (0, _builder.default)(\"JSXOpeningFragment\", ...arguments);\n}\n\nfunction jsxClosingFragment() {\n  return (0, _builder.default)(\"JSXClosingFragment\", ...arguments);\n}\n\nfunction noop() {\n  return (0, _builder.default)(\"Noop\", ...arguments);\n}\n\nfunction placeholder(expectedNode, name) {\n  return (0, _builder.default)(\"Placeholder\", ...arguments);\n}\n\nfunction v8IntrinsicIdentifier(name) {\n  return (0, _builder.default)(\"V8IntrinsicIdentifier\", ...arguments);\n}\n\nfunction argumentPlaceholder() {\n  return (0, _builder.default)(\"ArgumentPlaceholder\", ...arguments);\n}\n\nfunction bindExpression(object, callee) {\n  return (0, _builder.default)(\"BindExpression\", ...arguments);\n}\n\nfunction importAttribute(key, value) {\n  return (0, _builder.default)(\"ImportAttribute\", ...arguments);\n}\n\nfunction decorator(expression) {\n  return (0, _builder.default)(\"Decorator\", ...arguments);\n}\n\nfunction doExpression(body, async) {\n  return (0, _builder.default)(\"DoExpression\", ...arguments);\n}\n\nfunction exportDefaultSpecifier(exported) {\n  return (0, _builder.default)(\"ExportDefaultSpecifier\", ...arguments);\n}\n\nfunction recordExpression(properties) {\n  return (0, _builder.default)(\"RecordExpression\", ...arguments);\n}\n\nfunction tupleExpression(elements) {\n  return (0, _builder.default)(\"TupleExpression\", ...arguments);\n}\n\nfunction decimalLiteral(value) {\n  return (0, _builder.default)(\"DecimalLiteral\", ...arguments);\n}\n\nfunction staticBlock(body) {\n  return (0, _builder.default)(\"StaticBlock\", ...arguments);\n}\n\nfunction moduleExpression(body) {\n  return (0, _builder.default)(\"ModuleExpression\", ...arguments);\n}\n\nfunction topicReference() {\n  return (0, _builder.default)(\"TopicReference\", ...arguments);\n}\n\nfunction pipelineTopicExpression(expression) {\n  return (0, _builder.default)(\"PipelineTopicExpression\", ...arguments);\n}\n\nfunction pipelineBareFunction(callee) {\n  return (0, _builder.default)(\"PipelineBareFunction\", ...arguments);\n}\n\nfunction pipelinePrimaryTopicReference() {\n  return (0, _builder.default)(\"PipelinePrimaryTopicReference\", ...arguments);\n}\n\nfunction tsParameterProperty(parameter) {\n  return (0, _builder.default)(\"TSParameterProperty\", ...arguments);\n}\n\nfunction tsDeclareFunction(id, typeParameters, params, returnType) {\n  return (0, _builder.default)(\"TSDeclareFunction\", ...arguments);\n}\n\nfunction tsDeclareMethod(decorators, key, typeParameters, params, returnType) {\n  return (0, _builder.default)(\"TSDeclareMethod\", ...arguments);\n}\n\nfunction tsQualifiedName(left, right) {\n  return (0, _builder.default)(\"TSQualifiedName\", ...arguments);\n}\n\nfunction tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default)(\"TSCallSignatureDeclaration\", ...arguments);\n}\n\nfunction tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default)(\"TSConstructSignatureDeclaration\", ...arguments);\n}\n\nfunction tsPropertySignature(key, typeAnnotation, initializer) {\n  return (0, _builder.default)(\"TSPropertySignature\", ...arguments);\n}\n\nfunction tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default)(\"TSMethodSignature\", ...arguments);\n}\n\nfunction tsIndexSignature(parameters, typeAnnotation) {\n  return (0, _builder.default)(\"TSIndexSignature\", ...arguments);\n}\n\nfunction tsAnyKeyword() {\n  return (0, _builder.default)(\"TSAnyKeyword\", ...arguments);\n}\n\nfunction tsBooleanKeyword() {\n  return (0, _builder.default)(\"TSBooleanKeyword\", ...arguments);\n}\n\nfunction tsBigIntKeyword() {\n  return (0, _builder.default)(\"TSBigIntKeyword\", ...arguments);\n}\n\nfunction tsIntrinsicKeyword() {\n  return (0, _builder.default)(\"TSIntrinsicKeyword\", ...arguments);\n}\n\nfunction tsNeverKeyword() {\n  return (0, _builder.default)(\"TSNeverKeyword\", ...arguments);\n}\n\nfunction tsNullKeyword() {\n  return (0, _builder.default)(\"TSNullKeyword\", ...arguments);\n}\n\nfunction tsNumberKeyword() {\n  return (0, _builder.default)(\"TSNumberKeyword\", ...arguments);\n}\n\nfunction tsObjectKeyword() {\n  return (0, _builder.default)(\"TSObjectKeyword\", ...arguments);\n}\n\nfunction tsStringKeyword() {\n  return (0, _builder.default)(\"TSStringKeyword\", ...arguments);\n}\n\nfunction tsSymbolKeyword() {\n  return (0, _builder.default)(\"TSSymbolKeyword\", ...arguments);\n}\n\nfunction tsUndefinedKeyword() {\n  return (0, _builder.default)(\"TSUndefinedKeyword\", ...arguments);\n}\n\nfunction tsUnknownKeyword() {\n  return (0, _builder.default)(\"TSUnknownKeyword\", ...arguments);\n}\n\nfunction tsVoidKeyword() {\n  return (0, _builder.default)(\"TSVoidKeyword\", ...arguments);\n}\n\nfunction tsThisType() {\n  return (0, _builder.default)(\"TSThisType\", ...arguments);\n}\n\nfunction tsFunctionType(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default)(\"TSFunctionType\", ...arguments);\n}\n\nfunction tsConstructorType(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default)(\"TSConstructorType\", ...arguments);\n}\n\nfunction tsTypeReference(typeName, typeParameters) {\n  return (0, _builder.default)(\"TSTypeReference\", ...arguments);\n}\n\nfunction tsTypePredicate(parameterName, typeAnnotation, asserts) {\n  return (0, _builder.default)(\"TSTypePredicate\", ...arguments);\n}\n\nfunction tsTypeQuery(exprName) {\n  return (0, _builder.default)(\"TSTypeQuery\", ...arguments);\n}\n\nfunction tsTypeLiteral(members) {\n  return (0, _builder.default)(\"TSTypeLiteral\", ...arguments);\n}\n\nfunction tsArrayType(elementType) {\n  return (0, _builder.default)(\"TSArrayType\", ...arguments);\n}\n\nfunction tsTupleType(elementTypes) {\n  return (0, _builder.default)(\"TSTupleType\", ...arguments);\n}\n\nfunction tsOptionalType(typeAnnotation) {\n  return (0, _builder.default)(\"TSOptionalType\", ...arguments);\n}\n\nfunction tsRestType(typeAnnotation) {\n  return (0, _builder.default)(\"TSRestType\", ...arguments);\n}\n\nfunction tsNamedTupleMember(label, elementType, optional) {\n  return (0, _builder.default)(\"TSNamedTupleMember\", ...arguments);\n}\n\nfunction tsUnionType(types) {\n  return (0, _builder.default)(\"TSUnionType\", ...arguments);\n}\n\nfunction tsIntersectionType(types) {\n  return (0, _builder.default)(\"TSIntersectionType\", ...arguments);\n}\n\nfunction tsConditionalType(checkType, extendsType, trueType, falseType) {\n  return (0, _builder.default)(\"TSConditionalType\", ...arguments);\n}\n\nfunction tsInferType(typeParameter) {\n  return (0, _builder.default)(\"TSInferType\", ...arguments);\n}\n\nfunction tsParenthesizedType(typeAnnotation) {\n  return (0, _builder.default)(\"TSParenthesizedType\", ...arguments);\n}\n\nfunction tsTypeOperator(typeAnnotation) {\n  return (0, _builder.default)(\"TSTypeOperator\", ...arguments);\n}\n\nfunction tsIndexedAccessType(objectType, indexType) {\n  return (0, _builder.default)(\"TSIndexedAccessType\", ...arguments);\n}\n\nfunction tsMappedType(typeParameter, typeAnnotation, nameType) {\n  return (0, _builder.default)(\"TSMappedType\", ...arguments);\n}\n\nfunction tsLiteralType(literal) {\n  return (0, _builder.default)(\"TSLiteralType\", ...arguments);\n}\n\nfunction tsExpressionWithTypeArguments(expression, typeParameters) {\n  return (0, _builder.default)(\"TSExpressionWithTypeArguments\", ...arguments);\n}\n\nfunction tsInterfaceDeclaration(id, typeParameters, _extends, body) {\n  return (0, _builder.default)(\"TSInterfaceDeclaration\", ...arguments);\n}\n\nfunction tsInterfaceBody(body) {\n  return (0, _builder.default)(\"TSInterfaceBody\", ...arguments);\n}\n\nfunction tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {\n  return (0, _builder.default)(\"TSTypeAliasDeclaration\", ...arguments);\n}\n\nfunction tsAsExpression(expression, typeAnnotation) {\n  return (0, _builder.default)(\"TSAsExpression\", ...arguments);\n}\n\nfunction tsTypeAssertion(typeAnnotation, expression) {\n  return (0, _builder.default)(\"TSTypeAssertion\", ...arguments);\n}\n\nfunction tsEnumDeclaration(id, members) {\n  return (0, _builder.default)(\"TSEnumDeclaration\", ...arguments);\n}\n\nfunction tsEnumMember(id, initializer) {\n  return (0, _builder.default)(\"TSEnumMember\", ...arguments);\n}\n\nfunction tsModuleDeclaration(id, body) {\n  return (0, _builder.default)(\"TSModuleDeclaration\", ...arguments);\n}\n\nfunction tsModuleBlock(body) {\n  return (0, _builder.default)(\"TSModuleBlock\", ...arguments);\n}\n\nfunction tsImportType(argument, qualifier, typeParameters) {\n  return (0, _builder.default)(\"TSImportType\", ...arguments);\n}\n\nfunction tsImportEqualsDeclaration(id, moduleReference) {\n  return (0, _builder.default)(\"TSImportEqualsDeclaration\", ...arguments);\n}\n\nfunction tsExternalModuleReference(expression) {\n  return (0, _builder.default)(\"TSExternalModuleReference\", ...arguments);\n}\n\nfunction tsNonNullExpression(expression) {\n  return (0, _builder.default)(\"TSNonNullExpression\", ...arguments);\n}\n\nfunction tsExportAssignment(expression) {\n  return (0, _builder.default)(\"TSExportAssignment\", ...arguments);\n}\n\nfunction tsNamespaceExportDeclaration(id) {\n  return (0, _builder.default)(\"TSNamespaceExportDeclaration\", ...arguments);\n}\n\nfunction tsTypeAnnotation(typeAnnotation) {\n  return (0, _builder.default)(\"TSTypeAnnotation\", ...arguments);\n}\n\nfunction tsTypeParameterInstantiation(params) {\n  return (0, _builder.default)(\"TSTypeParameterInstantiation\", ...arguments);\n}\n\nfunction tsTypeParameterDeclaration(params) {\n  return (0, _builder.default)(\"TSTypeParameterDeclaration\", ...arguments);\n}\n\nfunction tsTypeParameter(constraint, _default, name) {\n  return (0, _builder.default)(\"TSTypeParameter\", ...arguments);\n}\n\nfunction NumberLiteral(...args) {\n  console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n  return (0, _builder.default)(\"NumberLiteral\", ...args);\n}\n\nfunction RegexLiteral(...args) {\n  console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n  return (0, _builder.default)(\"RegexLiteral\", ...args);\n}\n\nfunction RestProperty(...args) {\n  console.trace(\"The node type RestProperty has been renamed to RestElement\");\n  return (0, _builder.default)(\"RestProperty\", ...args);\n}\n\nfunction SpreadProperty(...args) {\n  console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n  return (0, _builder.default)(\"SpreadProperty\", ...args);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ArrayExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.arrayExpression;\n  }\n});\nObject.defineProperty(exports, \"AssignmentExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.assignmentExpression;\n  }\n});\nObject.defineProperty(exports, \"BinaryExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.binaryExpression;\n  }\n});\nObject.defineProperty(exports, \"InterpreterDirective\", {\n  enumerable: true,\n  get: function () {\n    return _index.interpreterDirective;\n  }\n});\nObject.defineProperty(exports, \"Directive\", {\n  enumerable: true,\n  get: function () {\n    return _index.directive;\n  }\n});\nObject.defineProperty(exports, \"DirectiveLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.directiveLiteral;\n  }\n});\nObject.defineProperty(exports, \"BlockStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.blockStatement;\n  }\n});\nObject.defineProperty(exports, \"BreakStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.breakStatement;\n  }\n});\nObject.defineProperty(exports, \"CallExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.callExpression;\n  }\n});\nObject.defineProperty(exports, \"CatchClause\", {\n  enumerable: true,\n  get: function () {\n    return _index.catchClause;\n  }\n});\nObject.defineProperty(exports, \"ConditionalExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.conditionalExpression;\n  }\n});\nObject.defineProperty(exports, \"ContinueStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.continueStatement;\n  }\n});\nObject.defineProperty(exports, \"DebuggerStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.debuggerStatement;\n  }\n});\nObject.defineProperty(exports, \"DoWhileStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.doWhileStatement;\n  }\n});\nObject.defineProperty(exports, \"EmptyStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.emptyStatement;\n  }\n});\nObject.defineProperty(exports, \"ExpressionStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.expressionStatement;\n  }\n});\nObject.defineProperty(exports, \"File\", {\n  enumerable: true,\n  get: function () {\n    return _index.file;\n  }\n});\nObject.defineProperty(exports, \"ForInStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.forInStatement;\n  }\n});\nObject.defineProperty(exports, \"ForStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.forStatement;\n  }\n});\nObject.defineProperty(exports, \"FunctionDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.functionDeclaration;\n  }\n});\nObject.defineProperty(exports, \"FunctionExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.functionExpression;\n  }\n});\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _index.identifier;\n  }\n});\nObject.defineProperty(exports, \"IfStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.ifStatement;\n  }\n});\nObject.defineProperty(exports, \"LabeledStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.labeledStatement;\n  }\n});\nObject.defineProperty(exports, \"StringLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.stringLiteral;\n  }\n});\nObject.defineProperty(exports, \"NumericLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.numericLiteral;\n  }\n});\nObject.defineProperty(exports, \"NullLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.nullLiteral;\n  }\n});\nObject.defineProperty(exports, \"BooleanLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.booleanLiteral;\n  }\n});\nObject.defineProperty(exports, \"RegExpLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.regExpLiteral;\n  }\n});\nObject.defineProperty(exports, \"LogicalExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.logicalExpression;\n  }\n});\nObject.defineProperty(exports, \"MemberExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.memberExpression;\n  }\n});\nObject.defineProperty(exports, \"NewExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.newExpression;\n  }\n});\nObject.defineProperty(exports, \"Program\", {\n  enumerable: true,\n  get: function () {\n    return _index.program;\n  }\n});\nObject.defineProperty(exports, \"ObjectExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.objectExpression;\n  }\n});\nObject.defineProperty(exports, \"ObjectMethod\", {\n  enumerable: true,\n  get: function () {\n    return _index.objectMethod;\n  }\n});\nObject.defineProperty(exports, \"ObjectProperty\", {\n  enumerable: true,\n  get: function () {\n    return _index.objectProperty;\n  }\n});\nObject.defineProperty(exports, \"RestElement\", {\n  enumerable: true,\n  get: function () {\n    return _index.restElement;\n  }\n});\nObject.defineProperty(exports, \"ReturnStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.returnStatement;\n  }\n});\nObject.defineProperty(exports, \"SequenceExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.sequenceExpression;\n  }\n});\nObject.defineProperty(exports, \"ParenthesizedExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.parenthesizedExpression;\n  }\n});\nObject.defineProperty(exports, \"SwitchCase\", {\n  enumerable: true,\n  get: function () {\n    return _index.switchCase;\n  }\n});\nObject.defineProperty(exports, \"SwitchStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.switchStatement;\n  }\n});\nObject.defineProperty(exports, \"ThisExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.thisExpression;\n  }\n});\nObject.defineProperty(exports, \"ThrowStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.throwStatement;\n  }\n});\nObject.defineProperty(exports, \"TryStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.tryStatement;\n  }\n});\nObject.defineProperty(exports, \"UnaryExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.unaryExpression;\n  }\n});\nObject.defineProperty(exports, \"UpdateExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.updateExpression;\n  }\n});\nObject.defineProperty(exports, \"VariableDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.variableDeclaration;\n  }\n});\nObject.defineProperty(exports, \"VariableDeclarator\", {\n  enumerable: true,\n  get: function () {\n    return _index.variableDeclarator;\n  }\n});\nObject.defineProperty(exports, \"WhileStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.whileStatement;\n  }\n});\nObject.defineProperty(exports, \"WithStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.withStatement;\n  }\n});\nObject.defineProperty(exports, \"AssignmentPattern\", {\n  enumerable: true,\n  get: function () {\n    return _index.assignmentPattern;\n  }\n});\nObject.defineProperty(exports, \"ArrayPattern\", {\n  enumerable: true,\n  get: function () {\n    return _index.arrayPattern;\n  }\n});\nObject.defineProperty(exports, \"ArrowFunctionExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.arrowFunctionExpression;\n  }\n});\nObject.defineProperty(exports, \"ClassBody\", {\n  enumerable: true,\n  get: function () {\n    return _index.classBody;\n  }\n});\nObject.defineProperty(exports, \"ClassExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.classExpression;\n  }\n});\nObject.defineProperty(exports, \"ClassDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.classDeclaration;\n  }\n});\nObject.defineProperty(exports, \"ExportAllDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.exportAllDeclaration;\n  }\n});\nObject.defineProperty(exports, \"ExportDefaultDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.exportDefaultDeclaration;\n  }\n});\nObject.defineProperty(exports, \"ExportNamedDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.exportNamedDeclaration;\n  }\n});\nObject.defineProperty(exports, \"ExportSpecifier\", {\n  enumerable: true,\n  get: function () {\n    return _index.exportSpecifier;\n  }\n});\nObject.defineProperty(exports, \"ForOfStatement\", {\n  enumerable: true,\n  get: function () {\n    return _index.forOfStatement;\n  }\n});\nObject.defineProperty(exports, \"ImportDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.importDeclaration;\n  }\n});\nObject.defineProperty(exports, \"ImportDefaultSpecifier\", {\n  enumerable: true,\n  get: function () {\n    return _index.importDefaultSpecifier;\n  }\n});\nObject.defineProperty(exports, \"ImportNamespaceSpecifier\", {\n  enumerable: true,\n  get: function () {\n    return _index.importNamespaceSpecifier;\n  }\n});\nObject.defineProperty(exports, \"ImportSpecifier\", {\n  enumerable: true,\n  get: function () {\n    return _index.importSpecifier;\n  }\n});\nObject.defineProperty(exports, \"MetaProperty\", {\n  enumerable: true,\n  get: function () {\n    return _index.metaProperty;\n  }\n});\nObject.defineProperty(exports, \"ClassMethod\", {\n  enumerable: true,\n  get: function () {\n    return _index.classMethod;\n  }\n});\nObject.defineProperty(exports, \"ObjectPattern\", {\n  enumerable: true,\n  get: function () {\n    return _index.objectPattern;\n  }\n});\nObject.defineProperty(exports, \"SpreadElement\", {\n  enumerable: true,\n  get: function () {\n    return _index.spreadElement;\n  }\n});\nObject.defineProperty(exports, \"Super\", {\n  enumerable: true,\n  get: function () {\n    return _index.super;\n  }\n});\nObject.defineProperty(exports, \"TaggedTemplateExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.taggedTemplateExpression;\n  }\n});\nObject.defineProperty(exports, \"TemplateElement\", {\n  enumerable: true,\n  get: function () {\n    return _index.templateElement;\n  }\n});\nObject.defineProperty(exports, \"TemplateLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.templateLiteral;\n  }\n});\nObject.defineProperty(exports, \"YieldExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.yieldExpression;\n  }\n});\nObject.defineProperty(exports, \"AwaitExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.awaitExpression;\n  }\n});\nObject.defineProperty(exports, \"Import\", {\n  enumerable: true,\n  get: function () {\n    return _index.import;\n  }\n});\nObject.defineProperty(exports, \"BigIntLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.bigIntLiteral;\n  }\n});\nObject.defineProperty(exports, \"ExportNamespaceSpecifier\", {\n  enumerable: true,\n  get: function () {\n    return _index.exportNamespaceSpecifier;\n  }\n});\nObject.defineProperty(exports, \"OptionalMemberExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.optionalMemberExpression;\n  }\n});\nObject.defineProperty(exports, \"OptionalCallExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.optionalCallExpression;\n  }\n});\nObject.defineProperty(exports, \"ClassProperty\", {\n  enumerable: true,\n  get: function () {\n    return _index.classProperty;\n  }\n});\nObject.defineProperty(exports, \"ClassPrivateProperty\", {\n  enumerable: true,\n  get: function () {\n    return _index.classPrivateProperty;\n  }\n});\nObject.defineProperty(exports, \"ClassPrivateMethod\", {\n  enumerable: true,\n  get: function () {\n    return _index.classPrivateMethod;\n  }\n});\nObject.defineProperty(exports, \"PrivateName\", {\n  enumerable: true,\n  get: function () {\n    return _index.privateName;\n  }\n});\nObject.defineProperty(exports, \"AnyTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.anyTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"ArrayTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.arrayTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"BooleanTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.booleanTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"BooleanLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.booleanLiteralTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"NullLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.nullLiteralTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"ClassImplements\", {\n  enumerable: true,\n  get: function () {\n    return _index.classImplements;\n  }\n});\nObject.defineProperty(exports, \"DeclareClass\", {\n  enumerable: true,\n  get: function () {\n    return _index.declareClass;\n  }\n});\nObject.defineProperty(exports, \"DeclareFunction\", {\n  enumerable: true,\n  get: function () {\n    return _index.declareFunction;\n  }\n});\nObject.defineProperty(exports, \"DeclareInterface\", {\n  enumerable: true,\n  get: function () {\n    return _index.declareInterface;\n  }\n});\nObject.defineProperty(exports, \"DeclareModule\", {\n  enumerable: true,\n  get: function () {\n    return _index.declareModule;\n  }\n});\nObject.defineProperty(exports, \"DeclareModuleExports\", {\n  enumerable: true,\n  get: function () {\n    return _index.declareModuleExports;\n  }\n});\nObject.defineProperty(exports, \"DeclareTypeAlias\", {\n  enumerable: true,\n  get: function () {\n    return _index.declareTypeAlias;\n  }\n});\nObject.defineProperty(exports, \"DeclareOpaqueType\", {\n  enumerable: true,\n  get: function () {\n    return _index.declareOpaqueType;\n  }\n});\nObject.defineProperty(exports, \"DeclareVariable\", {\n  enumerable: true,\n  get: function () {\n    return _index.declareVariable;\n  }\n});\nObject.defineProperty(exports, \"DeclareExportDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.declareExportDeclaration;\n  }\n});\nObject.defineProperty(exports, \"DeclareExportAllDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.declareExportAllDeclaration;\n  }\n});\nObject.defineProperty(exports, \"DeclaredPredicate\", {\n  enumerable: true,\n  get: function () {\n    return _index.declaredPredicate;\n  }\n});\nObject.defineProperty(exports, \"ExistsTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.existsTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"FunctionTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.functionTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"FunctionTypeParam\", {\n  enumerable: true,\n  get: function () {\n    return _index.functionTypeParam;\n  }\n});\nObject.defineProperty(exports, \"GenericTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.genericTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"InferredPredicate\", {\n  enumerable: true,\n  get: function () {\n    return _index.inferredPredicate;\n  }\n});\nObject.defineProperty(exports, \"InterfaceExtends\", {\n  enumerable: true,\n  get: function () {\n    return _index.interfaceExtends;\n  }\n});\nObject.defineProperty(exports, \"InterfaceDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.interfaceDeclaration;\n  }\n});\nObject.defineProperty(exports, \"InterfaceTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.interfaceTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"IntersectionTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.intersectionTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"MixedTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.mixedTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"EmptyTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.emptyTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"NullableTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.nullableTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"NumberLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.numberLiteralTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"NumberTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.numberTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"ObjectTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"ObjectTypeInternalSlot\", {\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeInternalSlot;\n  }\n});\nObject.defineProperty(exports, \"ObjectTypeCallProperty\", {\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeCallProperty;\n  }\n});\nObject.defineProperty(exports, \"ObjectTypeIndexer\", {\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeIndexer;\n  }\n});\nObject.defineProperty(exports, \"ObjectTypeProperty\", {\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeProperty;\n  }\n});\nObject.defineProperty(exports, \"ObjectTypeSpreadProperty\", {\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeSpreadProperty;\n  }\n});\nObject.defineProperty(exports, \"OpaqueType\", {\n  enumerable: true,\n  get: function () {\n    return _index.opaqueType;\n  }\n});\nObject.defineProperty(exports, \"QualifiedTypeIdentifier\", {\n  enumerable: true,\n  get: function () {\n    return _index.qualifiedTypeIdentifier;\n  }\n});\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.stringLiteralTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"StringTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.stringTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"SymbolTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.symbolTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"ThisTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.thisTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"TupleTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.tupleTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"TypeofTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.typeofTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"TypeAlias\", {\n  enumerable: true,\n  get: function () {\n    return _index.typeAlias;\n  }\n});\nObject.defineProperty(exports, \"TypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.typeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"TypeCastExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.typeCastExpression;\n  }\n});\nObject.defineProperty(exports, \"TypeParameter\", {\n  enumerable: true,\n  get: function () {\n    return _index.typeParameter;\n  }\n});\nObject.defineProperty(exports, \"TypeParameterDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.typeParameterDeclaration;\n  }\n});\nObject.defineProperty(exports, \"TypeParameterInstantiation\", {\n  enumerable: true,\n  get: function () {\n    return _index.typeParameterInstantiation;\n  }\n});\nObject.defineProperty(exports, \"UnionTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.unionTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"Variance\", {\n  enumerable: true,\n  get: function () {\n    return _index.variance;\n  }\n});\nObject.defineProperty(exports, \"VoidTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.voidTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"EnumDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.enumDeclaration;\n  }\n});\nObject.defineProperty(exports, \"EnumBooleanBody\", {\n  enumerable: true,\n  get: function () {\n    return _index.enumBooleanBody;\n  }\n});\nObject.defineProperty(exports, \"EnumNumberBody\", {\n  enumerable: true,\n  get: function () {\n    return _index.enumNumberBody;\n  }\n});\nObject.defineProperty(exports, \"EnumStringBody\", {\n  enumerable: true,\n  get: function () {\n    return _index.enumStringBody;\n  }\n});\nObject.defineProperty(exports, \"EnumSymbolBody\", {\n  enumerable: true,\n  get: function () {\n    return _index.enumSymbolBody;\n  }\n});\nObject.defineProperty(exports, \"EnumBooleanMember\", {\n  enumerable: true,\n  get: function () {\n    return _index.enumBooleanMember;\n  }\n});\nObject.defineProperty(exports, \"EnumNumberMember\", {\n  enumerable: true,\n  get: function () {\n    return _index.enumNumberMember;\n  }\n});\nObject.defineProperty(exports, \"EnumStringMember\", {\n  enumerable: true,\n  get: function () {\n    return _index.enumStringMember;\n  }\n});\nObject.defineProperty(exports, \"EnumDefaultedMember\", {\n  enumerable: true,\n  get: function () {\n    return _index.enumDefaultedMember;\n  }\n});\nObject.defineProperty(exports, \"IndexedAccessType\", {\n  enumerable: true,\n  get: function () {\n    return _index.indexedAccessType;\n  }\n});\nObject.defineProperty(exports, \"OptionalIndexedAccessType\", {\n  enumerable: true,\n  get: function () {\n    return _index.optionalIndexedAccessType;\n  }\n});\nObject.defineProperty(exports, \"JSXAttribute\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxAttribute;\n  }\n});\nObject.defineProperty(exports, \"JSXClosingElement\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxClosingElement;\n  }\n});\nObject.defineProperty(exports, \"JSXElement\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxElement;\n  }\n});\nObject.defineProperty(exports, \"JSXEmptyExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxEmptyExpression;\n  }\n});\nObject.defineProperty(exports, \"JSXExpressionContainer\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxExpressionContainer;\n  }\n});\nObject.defineProperty(exports, \"JSXSpreadChild\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxSpreadChild;\n  }\n});\nObject.defineProperty(exports, \"JSXIdentifier\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxIdentifier;\n  }\n});\nObject.defineProperty(exports, \"JSXMemberExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxMemberExpression;\n  }\n});\nObject.defineProperty(exports, \"JSXNamespacedName\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxNamespacedName;\n  }\n});\nObject.defineProperty(exports, \"JSXOpeningElement\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxOpeningElement;\n  }\n});\nObject.defineProperty(exports, \"JSXSpreadAttribute\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxSpreadAttribute;\n  }\n});\nObject.defineProperty(exports, \"JSXText\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxText;\n  }\n});\nObject.defineProperty(exports, \"JSXFragment\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxFragment;\n  }\n});\nObject.defineProperty(exports, \"JSXOpeningFragment\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxOpeningFragment;\n  }\n});\nObject.defineProperty(exports, \"JSXClosingFragment\", {\n  enumerable: true,\n  get: function () {\n    return _index.jsxClosingFragment;\n  }\n});\nObject.defineProperty(exports, \"Noop\", {\n  enumerable: true,\n  get: function () {\n    return _index.noop;\n  }\n});\nObject.defineProperty(exports, \"Placeholder\", {\n  enumerable: true,\n  get: function () {\n    return _index.placeholder;\n  }\n});\nObject.defineProperty(exports, \"V8IntrinsicIdentifier\", {\n  enumerable: true,\n  get: function () {\n    return _index.v8IntrinsicIdentifier;\n  }\n});\nObject.defineProperty(exports, \"ArgumentPlaceholder\", {\n  enumerable: true,\n  get: function () {\n    return _index.argumentPlaceholder;\n  }\n});\nObject.defineProperty(exports, \"BindExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.bindExpression;\n  }\n});\nObject.defineProperty(exports, \"ImportAttribute\", {\n  enumerable: true,\n  get: function () {\n    return _index.importAttribute;\n  }\n});\nObject.defineProperty(exports, \"Decorator\", {\n  enumerable: true,\n  get: function () {\n    return _index.decorator;\n  }\n});\nObject.defineProperty(exports, \"DoExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.doExpression;\n  }\n});\nObject.defineProperty(exports, \"ExportDefaultSpecifier\", {\n  enumerable: true,\n  get: function () {\n    return _index.exportDefaultSpecifier;\n  }\n});\nObject.defineProperty(exports, \"RecordExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.recordExpression;\n  }\n});\nObject.defineProperty(exports, \"TupleExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.tupleExpression;\n  }\n});\nObject.defineProperty(exports, \"DecimalLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.decimalLiteral;\n  }\n});\nObject.defineProperty(exports, \"StaticBlock\", {\n  enumerable: true,\n  get: function () {\n    return _index.staticBlock;\n  }\n});\nObject.defineProperty(exports, \"ModuleExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.moduleExpression;\n  }\n});\nObject.defineProperty(exports, \"TopicReference\", {\n  enumerable: true,\n  get: function () {\n    return _index.topicReference;\n  }\n});\nObject.defineProperty(exports, \"PipelineTopicExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.pipelineTopicExpression;\n  }\n});\nObject.defineProperty(exports, \"PipelineBareFunction\", {\n  enumerable: true,\n  get: function () {\n    return _index.pipelineBareFunction;\n  }\n});\nObject.defineProperty(exports, \"PipelinePrimaryTopicReference\", {\n  enumerable: true,\n  get: function () {\n    return _index.pipelinePrimaryTopicReference;\n  }\n});\nObject.defineProperty(exports, \"TSParameterProperty\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsParameterProperty;\n  }\n});\nObject.defineProperty(exports, \"TSDeclareFunction\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsDeclareFunction;\n  }\n});\nObject.defineProperty(exports, \"TSDeclareMethod\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsDeclareMethod;\n  }\n});\nObject.defineProperty(exports, \"TSQualifiedName\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsQualifiedName;\n  }\n});\nObject.defineProperty(exports, \"TSCallSignatureDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsCallSignatureDeclaration;\n  }\n});\nObject.defineProperty(exports, \"TSConstructSignatureDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsConstructSignatureDeclaration;\n  }\n});\nObject.defineProperty(exports, \"TSPropertySignature\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsPropertySignature;\n  }\n});\nObject.defineProperty(exports, \"TSMethodSignature\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsMethodSignature;\n  }\n});\nObject.defineProperty(exports, \"TSIndexSignature\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsIndexSignature;\n  }\n});\nObject.defineProperty(exports, \"TSAnyKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsAnyKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSBooleanKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsBooleanKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSBigIntKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsBigIntKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSIntrinsicKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsIntrinsicKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSNeverKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsNeverKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSNullKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsNullKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSNumberKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsNumberKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSObjectKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsObjectKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSStringKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsStringKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSSymbolKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsSymbolKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSUndefinedKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsUndefinedKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSUnknownKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsUnknownKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSVoidKeyword\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsVoidKeyword;\n  }\n});\nObject.defineProperty(exports, \"TSThisType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsThisType;\n  }\n});\nObject.defineProperty(exports, \"TSFunctionType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsFunctionType;\n  }\n});\nObject.defineProperty(exports, \"TSConstructorType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsConstructorType;\n  }\n});\nObject.defineProperty(exports, \"TSTypeReference\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeReference;\n  }\n});\nObject.defineProperty(exports, \"TSTypePredicate\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypePredicate;\n  }\n});\nObject.defineProperty(exports, \"TSTypeQuery\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeQuery;\n  }\n});\nObject.defineProperty(exports, \"TSTypeLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeLiteral;\n  }\n});\nObject.defineProperty(exports, \"TSArrayType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsArrayType;\n  }\n});\nObject.defineProperty(exports, \"TSTupleType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTupleType;\n  }\n});\nObject.defineProperty(exports, \"TSOptionalType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsOptionalType;\n  }\n});\nObject.defineProperty(exports, \"TSRestType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsRestType;\n  }\n});\nObject.defineProperty(exports, \"TSNamedTupleMember\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsNamedTupleMember;\n  }\n});\nObject.defineProperty(exports, \"TSUnionType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsUnionType;\n  }\n});\nObject.defineProperty(exports, \"TSIntersectionType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsIntersectionType;\n  }\n});\nObject.defineProperty(exports, \"TSConditionalType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsConditionalType;\n  }\n});\nObject.defineProperty(exports, \"TSInferType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsInferType;\n  }\n});\nObject.defineProperty(exports, \"TSParenthesizedType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsParenthesizedType;\n  }\n});\nObject.defineProperty(exports, \"TSTypeOperator\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeOperator;\n  }\n});\nObject.defineProperty(exports, \"TSIndexedAccessType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsIndexedAccessType;\n  }\n});\nObject.defineProperty(exports, \"TSMappedType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsMappedType;\n  }\n});\nObject.defineProperty(exports, \"TSLiteralType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsLiteralType;\n  }\n});\nObject.defineProperty(exports, \"TSExpressionWithTypeArguments\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsExpressionWithTypeArguments;\n  }\n});\nObject.defineProperty(exports, \"TSInterfaceDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsInterfaceDeclaration;\n  }\n});\nObject.defineProperty(exports, \"TSInterfaceBody\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsInterfaceBody;\n  }\n});\nObject.defineProperty(exports, \"TSTypeAliasDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeAliasDeclaration;\n  }\n});\nObject.defineProperty(exports, \"TSAsExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsAsExpression;\n  }\n});\nObject.defineProperty(exports, \"TSTypeAssertion\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeAssertion;\n  }\n});\nObject.defineProperty(exports, \"TSEnumDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsEnumDeclaration;\n  }\n});\nObject.defineProperty(exports, \"TSEnumMember\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsEnumMember;\n  }\n});\nObject.defineProperty(exports, \"TSModuleDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsModuleDeclaration;\n  }\n});\nObject.defineProperty(exports, \"TSModuleBlock\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsModuleBlock;\n  }\n});\nObject.defineProperty(exports, \"TSImportType\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsImportType;\n  }\n});\nObject.defineProperty(exports, \"TSImportEqualsDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsImportEqualsDeclaration;\n  }\n});\nObject.defineProperty(exports, \"TSExternalModuleReference\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsExternalModuleReference;\n  }\n});\nObject.defineProperty(exports, \"TSNonNullExpression\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsNonNullExpression;\n  }\n});\nObject.defineProperty(exports, \"TSExportAssignment\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsExportAssignment;\n  }\n});\nObject.defineProperty(exports, \"TSNamespaceExportDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsNamespaceExportDeclaration;\n  }\n});\nObject.defineProperty(exports, \"TSTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"TSTypeParameterInstantiation\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeParameterInstantiation;\n  }\n});\nObject.defineProperty(exports, \"TSTypeParameterDeclaration\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeParameterDeclaration;\n  }\n});\nObject.defineProperty(exports, \"TSTypeParameter\", {\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeParameter;\n  }\n});\nObject.defineProperty(exports, \"NumberLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.numberLiteral;\n  }\n});\nObject.defineProperty(exports, \"RegexLiteral\", {\n  enumerable: true,\n  get: function () {\n    return _index.regexLiteral;\n  }\n});\nObject.defineProperty(exports, \"RestProperty\", {\n  enumerable: true,\n  get: function () {\n    return _index.restProperty;\n  }\n});\nObject.defineProperty(exports, \"SpreadProperty\", {\n  enumerable: true,\n  get: function () {\n    return _index.spreadProperty;\n  }\n});\n\nvar _index = require(\"./index\");","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = buildChildren;\n\nvar _generated = require(\"../../validators/generated\");\n\nvar _cleanJSXElementLiteralChild = require(\"../../utils/react/cleanJSXElementLiteralChild\");\n\nfunction buildChildren(node) {\n  const elements = [];\n\n  for (let i = 0; i < node.children.length; i++) {\n    let child = node.children[i];\n\n    if ((0, _generated.isJSXText)(child)) {\n      (0, _cleanJSXElementLiteralChild.default)(child, elements);\n      continue;\n    }\n\n    if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;\n    if ((0, _generated.isJSXEmptyExpression)(child)) continue;\n    elements.push(child);\n  }\n\n  return elements;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createTSUnionType;\n\nvar _generated = require(\"../generated\");\n\nvar _removeTypeDuplicates = require(\"../../modifications/typescript/removeTypeDuplicates\");\n\nfunction createTSUnionType(typeAnnotations) {\n  const types = typeAnnotations.map(type => type.typeAnnotation);\n  const flattened = (0, _removeTypeDuplicates.default)(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _generated.tsUnionType)(flattened);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = clone;\n\nvar _cloneNode = require(\"./cloneNode\");\n\nfunction clone(node) {\n  return (0, _cloneNode.default)(node, false);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneDeep;\n\nvar _cloneNode = require(\"./cloneNode\");\n\nfunction cloneDeep(node) {\n  return (0, _cloneNode.default)(node);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneDeepWithoutLoc;\n\nvar _cloneNode = require(\"./cloneNode\");\n\nfunction cloneDeepWithoutLoc(node) {\n  return (0, _cloneNode.default)(node, true, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneNode;\n\nvar _definitions = require(\"../definitions\");\n\nvar _generated = require(\"../validators/generated\");\n\nconst has = Function.call.bind(Object.prototype.hasOwnProperty);\n\nfunction cloneIfNode(obj, deep, withoutLoc) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNode(obj, deep, withoutLoc);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc));\n  }\n\n  return cloneIfNode(obj, deep, withoutLoc);\n}\n\nfunction cloneNode(node, deep = true, withoutLoc = false) {\n  if (!node) return node;\n  const {\n    type\n  } = node;\n  const newNode = {\n    type: node.type\n  };\n\n  if ((0, _generated.isIdentifier)(node)) {\n    newNode.name = node.name;\n\n    if (has(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n\n    if (has(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;\n    }\n  } else if (!has(_definitions.NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {\n      if (has(node, field)) {\n        if (deep) {\n          newNode[field] = (0, _generated.isFile)(node) && field === \"comments\" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n\n  if (has(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n\n  if (has(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"extra\")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n\n  return newNode;\n}\n\nfunction maybeCloneComments(comments, deep, withoutLoc) {\n  if (!comments || !deep) {\n    return comments;\n  }\n\n  return comments.map(({\n    type,\n    value,\n    loc\n  }) => {\n    if (withoutLoc) {\n      return {\n        type,\n        value,\n        loc: null\n      };\n    }\n\n    return {\n      type,\n      value,\n      loc\n    };\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneWithoutLoc;\n\nvar _cloneNode = require(\"./cloneNode\");\n\nfunction cloneWithoutLoc(node) {\n  return (0, _cloneNode.default)(node, false, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = addComment;\n\nvar _addComments = require(\"./addComments\");\n\nfunction addComment(node, type, content, line) {\n  return (0, _addComments.default)(node, type, [{\n    type: line ? \"CommentLine\" : \"CommentBlock\",\n    value: content\n  }]);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = addComments;\n\nfunction addComments(node, type, comments) {\n  if (!comments || !node) return node;\n  const key = `${type}Comments`;\n\n  if (node[key]) {\n    if (type === \"leading\") {\n      node[key] = comments.concat(node[key]);\n    } else {\n      node[key].push(...comments);\n    }\n  } else {\n    node[key] = comments;\n  }\n\n  return node;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritInnerComments;\n\nvar _inherit = require(\"../utils/inherit\");\n\nfunction inheritInnerComments(child, parent) {\n  (0, _inherit.default)(\"innerComments\", child, parent);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritLeadingComments;\n\nvar _inherit = require(\"../utils/inherit\");\n\nfunction inheritLeadingComments(child, parent) {\n  (0, _inherit.default)(\"leadingComments\", child, parent);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritTrailingComments;\n\nvar _inherit = require(\"../utils/inherit\");\n\nfunction inheritTrailingComments(child, parent) {\n  (0, _inherit.default)(\"trailingComments\", child, parent);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inheritsComments;\n\nvar _inheritTrailingComments = require(\"./inheritTrailingComments\");\n\nvar _inheritLeadingComments = require(\"./inheritLeadingComments\");\n\nvar _inheritInnerComments = require(\"./inheritInnerComments\");\n\nfunction inheritsComments(child, parent) {\n  (0, _inheritTrailingComments.default)(child, parent);\n  (0, _inheritLeadingComments.default)(child, parent);\n  (0, _inheritInnerComments.default)(child, parent);\n  return child;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeComments;\n\nvar _constants = require(\"../constants\");\n\nfunction removeComments(node) {\n  _constants.COMMENT_KEYS.forEach(key => {\n    node[key] = null;\n  });\n\n  return node;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSBASETYPE_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.JSX_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.PRIVATE_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;\n\nvar _definitions = require(\"../../definitions\");\n\nconst EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Expression\"];\nexports.EXPRESSION_TYPES = EXPRESSION_TYPES;\nconst BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Binary\"];\nexports.BINARY_TYPES = BINARY_TYPES;\nconst SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Scopable\"];\nexports.SCOPABLE_TYPES = SCOPABLE_TYPES;\nconst BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"BlockParent\"];\nexports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;\nconst BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Block\"];\nexports.BLOCK_TYPES = BLOCK_TYPES;\nconst STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Statement\"];\nexports.STATEMENT_TYPES = STATEMENT_TYPES;\nconst TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Terminatorless\"];\nexports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;\nconst COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"CompletionStatement\"];\nexports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;\nconst CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Conditional\"];\nexports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;\nconst LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Loop\"];\nexports.LOOP_TYPES = LOOP_TYPES;\nconst WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"While\"];\nexports.WHILE_TYPES = WHILE_TYPES;\nconst EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ExpressionWrapper\"];\nexports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;\nconst FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"For\"];\nexports.FOR_TYPES = FOR_TYPES;\nconst FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ForXStatement\"];\nexports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;\nconst FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Function\"];\nexports.FUNCTION_TYPES = FUNCTION_TYPES;\nconst FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"FunctionParent\"];\nexports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;\nconst PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Pureish\"];\nexports.PUREISH_TYPES = PUREISH_TYPES;\nconst DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Declaration\"];\nexports.DECLARATION_TYPES = DECLARATION_TYPES;\nconst PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"PatternLike\"];\nexports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;\nconst LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"LVal\"];\nexports.LVAL_TYPES = LVAL_TYPES;\nconst TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"TSEntityName\"];\nexports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;\nconst LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Literal\"];\nexports.LITERAL_TYPES = LITERAL_TYPES;\nconst IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Immutable\"];\nexports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;\nconst USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"UserWhitespacable\"];\nexports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;\nconst METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Method\"];\nexports.METHOD_TYPES = METHOD_TYPES;\nconst OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ObjectMember\"];\nexports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;\nconst PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Property\"];\nexports.PROPERTY_TYPES = PROPERTY_TYPES;\nconst UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"UnaryLike\"];\nexports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;\nconst PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Pattern\"];\nexports.PATTERN_TYPES = PATTERN_TYPES;\nconst CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Class\"];\nexports.CLASS_TYPES = CLASS_TYPES;\nconst MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ModuleDeclaration\"];\nexports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;\nconst EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ExportDeclaration\"];\nexports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;\nconst MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"ModuleSpecifier\"];\nexports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;\nconst PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Private\"];\nexports.PRIVATE_TYPES = PRIVATE_TYPES;\nconst FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"Flow\"];\nexports.FLOW_TYPES = FLOW_TYPES;\nconst FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"FlowType\"];\nexports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;\nconst FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"FlowBaseAnnotation\"];\nexports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;\nconst FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"FlowDeclaration\"];\nexports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;\nconst FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"FlowPredicate\"];\nexports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;\nconst ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"EnumBody\"];\nexports.ENUMBODY_TYPES = ENUMBODY_TYPES;\nconst ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"EnumMember\"];\nexports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;\nconst JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"JSX\"];\nexports.JSX_TYPES = JSX_TYPES;\nconst TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"TSTypeElement\"];\nexports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;\nconst TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"TSType\"];\nexports.TSTYPE_TYPES = TSTYPE_TYPES;\nconst TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS[\"TSBaseType\"];\nexports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;\nconst STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nexports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;\nconst FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nexports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;\nconst FOR_INIT_KEYS = [\"left\", \"init\"];\nexports.FOR_INIT_KEYS = FOR_INIT_KEYS;\nconst COMMENT_KEYS = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\nexports.COMMENT_KEYS = COMMENT_KEYS;\nconst LOGICAL_OPERATORS = [\"||\", \"&&\", \"??\"];\nexports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;\nconst UPDATE_OPERATORS = [\"++\", \"--\"];\nexports.UPDATE_OPERATORS = UPDATE_OPERATORS;\nconst BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nexports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;\nconst EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nexports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;\nconst COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, \"in\", \"instanceof\"];\nexports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;\nconst BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];\nexports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;\nconst NUMBER_BINARY_OPERATORS = [\"-\", \"/\", \"%\", \"*\", \"**\", \"&\", \"|\", \">>\", \">>>\", \"<<\", \"^\"];\nexports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;\nconst BINARY_OPERATORS = [\"+\", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS];\nexports.BINARY_OPERATORS = BINARY_OPERATORS;\nconst ASSIGNMENT_OPERATORS = [\"=\", \"+=\", ...NUMBER_BINARY_OPERATORS.map(op => op + \"=\"), ...LOGICAL_OPERATORS.map(op => op + \"=\")];\nexports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;\nconst BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nexports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;\nconst NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"~\"];\nexports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;\nconst STRING_UNARY_OPERATORS = [\"typeof\"];\nexports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;\nconst UNARY_OPERATORS = [\"void\", \"throw\", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];\nexports.UNARY_OPERATORS = UNARY_OPERATORS;\nconst INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"start\", \"loc\", \"end\"]\n};\nexports.INHERIT_KEYS = INHERIT_KEYS;\nconst BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\nexports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;\nconst NOT_LOCAL_BINDING = Symbol.for(\"should not be considered a local binding\");\nexports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ensureBlock;\n\nvar _toBlock = require(\"./toBlock\");\n\nfunction ensureBlock(node, key = \"body\") {\n  return node[key] = (0, _toBlock.default)(node[key], node);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = gatherSequenceExpressions;\n\nvar _getBindingIdentifiers = require(\"../retrievers/getBindingIdentifiers\");\n\nvar _generated = require(\"../validators/generated\");\n\nvar _generated2 = require(\"../builders/generated\");\n\nvar _cloneNode = require(\"../clone/cloneNode\");\n\nfunction gatherSequenceExpressions(nodes, scope, declars) {\n  const exprs = [];\n  let ensureLastUndefined = true;\n\n  for (const node of nodes) {\n    if (!(0, _generated.isEmptyStatement)(node)) {\n      ensureLastUndefined = false;\n    }\n\n    if ((0, _generated.isExpression)(node)) {\n      exprs.push(node);\n    } else if ((0, _generated.isExpressionStatement)(node)) {\n      exprs.push(node.expression);\n    } else if ((0, _generated.isVariableDeclaration)(node)) {\n      if (node.kind !== \"var\") return;\n\n      for (const declar of node.declarations) {\n        const bindings = (0, _getBindingIdentifiers.default)(declar);\n\n        for (const key of Object.keys(bindings)) {\n          declars.push({\n            kind: node.kind,\n            id: (0, _cloneNode.default)(bindings[key])\n          });\n        }\n\n        if (declar.init) {\n          exprs.push((0, _generated2.assignmentExpression)(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if ((0, _generated.isIfStatement)(node)) {\n      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();\n      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return;\n      exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));\n    } else if ((0, _generated.isBlockStatement)(node)) {\n      const body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return;\n      exprs.push(body);\n    } else if ((0, _generated.isEmptyStatement)(node)) {\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return (0, _generated2.sequenceExpression)(exprs);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toBindingIdentifierName;\n\nvar _toIdentifier = require(\"./toIdentifier\");\n\nfunction toBindingIdentifierName(name) {\n  name = (0, _toIdentifier.default)(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n  return name;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toBlock;\n\nvar _generated = require(\"../validators/generated\");\n\nvar _generated2 = require(\"../builders/generated\");\n\nfunction toBlock(node, parent) {\n  if ((0, _generated.isBlockStatement)(node)) {\n    return node;\n  }\n\n  let blockNodes = [];\n\n  if ((0, _generated.isEmptyStatement)(node)) {\n    blockNodes = [];\n  } else {\n    if (!(0, _generated.isStatement)(node)) {\n      if ((0, _generated.isFunction)(parent)) {\n        node = (0, _generated2.returnStatement)(node);\n      } else {\n        node = (0, _generated2.expressionStatement)(node);\n      }\n    }\n\n    blockNodes = [node];\n  }\n\n  return (0, _generated2.blockStatement)(blockNodes);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toComputedKey;\n\nvar _generated = require(\"../validators/generated\");\n\nvar _generated2 = require(\"../builders/generated\");\n\nfunction toComputedKey(node, key = node.key || node.property) {\n  if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);\n  return key;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _generated = require(\"../validators/generated\");\n\nvar _default = toExpression;\nexports.default = _default;\n\nfunction toExpression(node) {\n  if ((0, _generated.isExpressionStatement)(node)) {\n    node = node.expression;\n  }\n\n  if ((0, _generated.isExpression)(node)) {\n    return node;\n  }\n\n  if ((0, _generated.isClass)(node)) {\n    node.type = \"ClassExpression\";\n  } else if ((0, _generated.isFunction)(node)) {\n    node.type = \"FunctionExpression\";\n  }\n\n  if (!(0, _generated.isExpression)(node)) {\n    throw new Error(`cannot turn ${node.type} to an expression`);\n  }\n\n  return node;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toIdentifier;\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nfunction toIdentifier(input) {\n  input = input + \"\";\n  let name = \"\";\n\n  for (const c of input) {\n    name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : \"-\";\n  }\n\n  name = name.replace(/^[-0-9]+/, \"\");\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n\n  if (!(0, _isValidIdentifier.default)(name)) {\n    name = `_${name}`;\n  }\n\n  return name || \"_\";\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toKeyAlias;\n\nvar _generated = require(\"../validators/generated\");\n\nvar _cloneNode = require(\"../clone/cloneNode\");\n\nvar _removePropertiesDeep = require(\"../modifications/removePropertiesDeep\");\n\nfunction toKeyAlias(node, key = node.key) {\n  let alias;\n\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if ((0, _generated.isIdentifier)(key)) {\n    alias = key.name;\n  } else if ((0, _generated.isStringLiteral)(key)) {\n    alias = JSON.stringify(key.value);\n  } else {\n    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));\n  }\n\n  if (node.computed) {\n    alias = `[${alias}]`;\n  }\n\n  if (node.static) {\n    alias = `static:${alias}`;\n  }\n\n  return alias;\n}\n\ntoKeyAlias.uid = 0;\n\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {\n    return toKeyAlias.uid = 0;\n  } else {\n    return toKeyAlias.uid++;\n  }\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toSequenceExpression;\n\nvar _gatherSequenceExpressions = require(\"./gatherSequenceExpressions\");\n\nfunction toSequenceExpression(nodes, scope) {\n  if (!(nodes != null && nodes.length)) return;\n  const declars = [];\n  const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);\n  if (!result) return;\n\n  for (const declar of declars) {\n    scope.push(declar);\n  }\n\n  return result;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _generated = require(\"../validators/generated\");\n\nvar _generated2 = require(\"../builders/generated\");\n\nvar _default = toStatement;\nexports.default = _default;\n\nfunction toStatement(node, ignore) {\n  if ((0, _generated.isStatement)(node)) {\n    return node;\n  }\n\n  let mustHaveId = false;\n  let newType;\n\n  if ((0, _generated.isClass)(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if ((0, _generated.isFunction)(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if ((0, _generated.isAssignmentExpression)(node)) {\n    return (0, _generated2.expressionStatement)(node);\n  }\n\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n\n  node.type = newType;\n  return node;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _generated = require(\"../builders/generated\");\n\nvar _default = valueToNode;\nexports.default = _default;\nconst objectToString = Function.call.bind(Object.prototype.toString);\n\nfunction isRegExp(value) {\n  return objectToString(value) === \"[object RegExp]\";\n}\n\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null || Object.prototype.toString.call(value) !== \"[object Object]\") {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\n\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return (0, _generated.identifier)(\"undefined\");\n  }\n\n  if (value === true || value === false) {\n    return (0, _generated.booleanLiteral)(value);\n  }\n\n  if (value === null) {\n    return (0, _generated.nullLiteral)();\n  }\n\n  if (typeof value === \"string\") {\n    return (0, _generated.stringLiteral)(value);\n  }\n\n  if (typeof value === \"number\") {\n    let result;\n\n    if (Number.isFinite(value)) {\n      result = (0, _generated.numericLiteral)(Math.abs(value));\n    } else {\n      let numerator;\n\n      if (Number.isNaN(value)) {\n        numerator = (0, _generated.numericLiteral)(0);\n      } else {\n        numerator = (0, _generated.numericLiteral)(1);\n      }\n\n      result = (0, _generated.binaryExpression)(\"/\", numerator, (0, _generated.numericLiteral)(0));\n    }\n\n    if (value < 0 || Object.is(value, -0)) {\n      result = (0, _generated.unaryExpression)(\"-\", result);\n    }\n\n    return result;\n  }\n\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return (0, _generated.regExpLiteral)(pattern, flags);\n  }\n\n  if (Array.isArray(value)) {\n    return (0, _generated.arrayExpression)(value.map(valueToNode));\n  }\n\n  if (isPlainObject(value)) {\n    const props = [];\n\n    for (const key of Object.keys(value)) {\n      let nodeKey;\n\n      if ((0, _isValidIdentifier.default)(key)) {\n        nodeKey = (0, _generated.identifier)(key);\n      } else {\n        nodeKey = (0, _generated.stringLiteral)(key);\n      }\n\n      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));\n    }\n\n    return (0, _generated.objectExpression)(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _is = require(\"../validators/is\");\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"./utils\");\n\n(0, _utils.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n(0, _utils.default)(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n(0, _utils.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n(0, _utils.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n(0, _utils.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n(0, _utils.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\n(0, _utils.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\n(0, _utils.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\n(0, _utils.default)(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\n(0, _utils.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\n(0, _utils.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\n(0, _utils.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\")\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n(0, _utils.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n(0, _utils.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n(0, _utils.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    }\n  })\n});\n(0, _utils.default)(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n    }\n  }\n});\n(0, _utils.default)(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\n(0, _utils.default)(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\n(0, _utils.default)(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\n(0, _utils.default)(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\n(0, _utils.default)(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\n(0, _utils.default)(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Super\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\n(0, _utils.default)(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Import\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\n(0, _utils.default)(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon, {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\n(0, _utils.default)(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});","\"use strict\";\n\nvar _utils = require(\"./utils\");\n\n(0, _utils.default)(\"ArgumentPlaceholder\", {});\n(0, _utils.default)(\"BindExpression\", {\n  visitor: [\"object\", \"callee\"],\n  aliases: [\"Expression\"],\n  fields: !process.env.BABEL_TYPES_8_BREAKING ? {\n    object: {\n      validate: Object.assign(() => {}, {\n        oneOfNodeTypes: [\"Expression\"]\n      })\n    },\n    callee: {\n      validate: Object.assign(() => {}, {\n        oneOfNodeTypes: [\"Expression\"]\n      })\n    }\n  } : {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportAttribute\", {\n  visitor: [\"key\", \"value\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"Decorator\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"DoExpression\", {\n  visitor: [\"body\"],\n  builder: [\"body\", \"async\"],\n  aliases: [\"Expression\"],\n  fields: {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    async: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"RecordExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"TupleExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\"))),\n      default: []\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"DecimalLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ModuleExpression\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TopicReference\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"PipelineTopicExpression\", {\n  builder: [\"expression\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"PipelineBareFunction\", {\n  builder: [\"callee\"],\n  visitor: [\"callee\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"PipelinePrimaryTopicReference\", {\n  aliases: [\"Expression\"]\n});","\"use strict\";\n\nvar _utils = require(\"./utils\");\n\nconst defineInterfaceishType = (name, typeParameterType = \"TypeParameterDeclaration\") => {\n  (0, _utils.default)(name, {\n    builder: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n    visitor: [\"id\", \"typeParameters\", \"extends\", \"mixins\", \"implements\", \"body\"],\n    aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n    fields: {\n      id: (0, _utils.validateType)(\"Identifier\"),\n      typeParameters: (0, _utils.validateOptionalType)(typeParameterType),\n      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ClassImplements\")),\n      body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n    }\n  });\n};\n\n(0, _utils.default)(\"AnyTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"ArrayTypeAnnotation\", {\n  visitor: [\"elementType\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    elementType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"BooleanTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"BooleanLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"NullLiteralTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"ClassImplements\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\ndefineInterfaceishType(\"DeclareClass\");\n(0, _utils.default)(\"DeclareFunction\", {\n  visitor: [\"id\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    predicate: (0, _utils.validateOptionalType)(\"DeclaredPredicate\")\n  }\n});\ndefineInterfaceishType(\"DeclareInterface\");\n(0, _utils.default)(\"DeclareModule\", {\n  builder: [\"id\", \"body\", \"kind\"],\n  visitor: [\"id\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    body: (0, _utils.validateType)(\"BlockStatement\"),\n    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"CommonJS\", \"ES\"))\n  }\n});\n(0, _utils.default)(\"DeclareModuleExports\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TypeAnnotation\")\n  }\n});\n(0, _utils.default)(\"DeclareTypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    right: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"DeclareOpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    supertype: (0, _utils.validateOptionalType)(\"FlowType\"),\n    impltype: (0, _utils.validateOptionalType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"DeclareVariable\", {\n  visitor: [\"id\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\n(0, _utils.default)(\"DeclareExportDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    declaration: (0, _utils.validateOptionalType)(\"Flow\"),\n    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)([\"ExportSpecifier\", \"ExportNamespaceSpecifier\"])),\n    source: (0, _utils.validateOptionalType)(\"StringLiteral\"),\n    default: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"DeclareExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    source: (0, _utils.validateType)(\"StringLiteral\"),\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\n(0, _utils.default)(\"DeclaredPredicate\", {\n  visitor: [\"value\"],\n  aliases: [\"Flow\", \"FlowPredicate\"],\n  fields: {\n    value: (0, _utils.validateType)(\"Flow\")\n  }\n});\n(0, _utils.default)(\"ExistsTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\"]\n});\n(0, _utils.default)(\"FunctionTypeAnnotation\", {\n  visitor: [\"typeParameters\", \"params\", \"rest\", \"returnType\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    params: (0, _utils.validate)((0, _utils.arrayOfType)(\"FunctionTypeParam\")),\n    rest: (0, _utils.validateOptionalType)(\"FunctionTypeParam\"),\n    this: (0, _utils.validateOptionalType)(\"FunctionTypeParam\"),\n    returnType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"FunctionTypeParam\", {\n  visitor: [\"name\", \"typeAnnotation\"],\n  aliases: [\"Flow\"],\n  fields: {\n    name: (0, _utils.validateOptionalType)(\"Identifier\"),\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\"),\n    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"GenericTypeAnnotation\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    id: (0, _utils.validateType)([\"Identifier\", \"QualifiedTypeIdentifier\"]),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\n(0, _utils.default)(\"InferredPredicate\", {\n  aliases: [\"Flow\", \"FlowPredicate\"]\n});\n(0, _utils.default)(\"InterfaceExtends\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"],\n  fields: {\n    id: (0, _utils.validateType)([\"Identifier\", \"QualifiedTypeIdentifier\"]),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n  }\n});\ndefineInterfaceishType(\"InterfaceDeclaration\");\n(0, _utils.default)(\"InterfaceTypeAnnotation\", {\n  visitor: [\"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n    body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n  }\n});\n(0, _utils.default)(\"IntersectionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\n(0, _utils.default)(\"MixedTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"EmptyTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"NullableTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"NumberLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"number\"))\n  }\n});\n(0, _utils.default)(\"NumberTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"ObjectTypeAnnotation\", {\n  visitor: [\"properties\", \"indexers\", \"callProperties\", \"internalSlots\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  builder: [\"properties\", \"indexers\", \"callProperties\", \"internalSlots\", \"exact\"],\n  fields: {\n    properties: (0, _utils.validate)((0, _utils.arrayOfType)([\"ObjectTypeProperty\", \"ObjectTypeSpreadProperty\"])),\n    indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ObjectTypeIndexer\")),\n    callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ObjectTypeCallProperty\")),\n    internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ObjectTypeInternalSlot\")),\n    exact: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"ObjectTypeInternalSlot\", {\n  visitor: [\"id\", \"value\", \"optional\", \"static\", \"method\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    method: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"ObjectTypeCallProperty\", {\n  visitor: [\"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {\n    value: (0, _utils.validateType)(\"FlowType\"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"ObjectTypeIndexer\", {\n  visitor: [\"id\", \"key\", \"value\", \"variance\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {\n    id: (0, _utils.validateOptionalType)(\"Identifier\"),\n    key: (0, _utils.validateType)(\"FlowType\"),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    variance: (0, _utils.validateOptionalType)(\"Variance\")\n  }\n});\n(0, _utils.default)(\"ObjectTypeProperty\", {\n  visitor: [\"key\", \"value\", \"variance\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {\n    key: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    value: (0, _utils.validateType)(\"FlowType\"),\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)(\"init\", \"get\", \"set\")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    proto: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    variance: (0, _utils.validateOptionalType)(\"Variance\"),\n    method: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"ObjectTypeSpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"OpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\", \"impltype\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    supertype: (0, _utils.validateOptionalType)(\"FlowType\"),\n    impltype: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"QualifiedTypeIdentifier\", {\n  visitor: [\"id\", \"qualification\"],\n  aliases: [\"Flow\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    qualification: (0, _utils.validateType)([\"Identifier\", \"QualifiedTypeIdentifier\"])\n  }\n});\n(0, _utils.default)(\"StringLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)(\"string\"))\n  }\n});\n(0, _utils.default)(\"StringTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"SymbolTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"ThisTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"TupleTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\n(0, _utils.default)(\"TypeofTypeAnnotation\", {\n  visitor: [\"argument\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"TypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n    right: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"TypeAnnotation\", {\n  aliases: [\"Flow\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"TypeCastExpression\", {\n  visitor: [\"expression\", \"typeAnnotation\"],\n  aliases: [\"Flow\", \"ExpressionWrapper\", \"Expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeAnnotation: (0, _utils.validateType)(\"TypeAnnotation\")\n  }\n});\n(0, _utils.default)(\"TypeParameter\", {\n  aliases: [\"Flow\"],\n  visitor: [\"bound\", \"default\", \"variance\"],\n  fields: {\n    name: (0, _utils.validate)((0, _utils.assertValueType)(\"string\")),\n    bound: (0, _utils.validateOptionalType)(\"TypeAnnotation\"),\n    default: (0, _utils.validateOptionalType)(\"FlowType\"),\n    variance: (0, _utils.validateOptionalType)(\"Variance\")\n  }\n});\n(0, _utils.default)(\"TypeParameterDeclaration\", {\n  aliases: [\"Flow\"],\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)(\"TypeParameter\"))\n  }\n});\n(0, _utils.default)(\"TypeParameterInstantiation\", {\n  aliases: [\"Flow\"],\n  visitor: [\"params\"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\n(0, _utils.default)(\"UnionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n  }\n});\n(0, _utils.default)(\"Variance\", {\n  aliases: [\"Flow\"],\n  builder: [\"kind\"],\n  fields: {\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)(\"minus\", \"plus\"))\n  }\n});\n(0, _utils.default)(\"VoidTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowType\", \"FlowBaseAnnotation\"]\n});\n(0, _utils.default)(\"EnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    body: (0, _utils.validateType)([\"EnumBooleanBody\", \"EnumNumberBody\", \"EnumStringBody\", \"EnumSymbolBody\"])\n  }\n});\n(0, _utils.default)(\"EnumBooleanBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    members: (0, _utils.validateArrayOfType)(\"EnumBooleanMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"EnumNumberBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    members: (0, _utils.validateArrayOfType)(\"EnumNumberMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"EnumStringBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n    members: (0, _utils.validateArrayOfType)([\"EnumStringMember\", \"EnumDefaultedMember\"]),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"EnumSymbolBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"EnumDefaultedMember\"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});\n(0, _utils.default)(\"EnumBooleanMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    init: (0, _utils.validateType)(\"BooleanLiteral\")\n  }\n});\n(0, _utils.default)(\"EnumNumberMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    init: (0, _utils.validateType)(\"NumericLiteral\")\n  }\n});\n(0, _utils.default)(\"EnumStringMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\"),\n    init: (0, _utils.validateType)(\"StringLiteral\")\n  }\n});\n(0, _utils.default)(\"EnumDefaultedMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\n(0, _utils.default)(\"IndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"FlowType\"),\n    indexType: (0, _utils.validateType)(\"FlowType\")\n  }\n});\n(0, _utils.default)(\"OptionalIndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"Flow\", \"FlowType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"FlowType\"),\n    indexType: (0, _utils.validateType)(\"FlowType\"),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n  }\n});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"VISITOR_KEYS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.VISITOR_KEYS;\n  }\n});\nObject.defineProperty(exports, \"ALIAS_KEYS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.ALIAS_KEYS;\n  }\n});\nObject.defineProperty(exports, \"FLIPPED_ALIAS_KEYS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.FLIPPED_ALIAS_KEYS;\n  }\n});\nObject.defineProperty(exports, \"NODE_FIELDS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_FIELDS;\n  }\n});\nObject.defineProperty(exports, \"BUILDER_KEYS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.BUILDER_KEYS;\n  }\n});\nObject.defineProperty(exports, \"DEPRECATED_KEYS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.DEPRECATED_KEYS;\n  }\n});\nObject.defineProperty(exports, \"NODE_PARENT_VALIDATIONS\", {\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_PARENT_VALIDATIONS;\n  }\n});\nObject.defineProperty(exports, \"PLACEHOLDERS\", {\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS;\n  }\n});\nObject.defineProperty(exports, \"PLACEHOLDERS_ALIAS\", {\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS_ALIAS;\n  }\n});\nObject.defineProperty(exports, \"PLACEHOLDERS_FLIPPED_ALIAS\", {\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;\n  }\n});\nexports.TYPES = void 0;\n\nvar _toFastProperties = require(\"to-fast-properties\");\n\nrequire(\"./core\");\n\nrequire(\"./flow\");\n\nrequire(\"./jsx\");\n\nrequire(\"./misc\");\n\nrequire(\"./experimental\");\n\nrequire(\"./typescript\");\n\nvar _utils = require(\"./utils\");\n\nvar _placeholders = require(\"./placeholders\");\n\n_toFastProperties(_utils.VISITOR_KEYS);\n\n_toFastProperties(_utils.ALIAS_KEYS);\n\n_toFastProperties(_utils.FLIPPED_ALIAS_KEYS);\n\n_toFastProperties(_utils.NODE_FIELDS);\n\n_toFastProperties(_utils.BUILDER_KEYS);\n\n_toFastProperties(_utils.DEPRECATED_KEYS);\n\n_toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);\n\n_toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);\n\nconst TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));\nexports.TYPES = TYPES;","\"use strict\";\n\nvar _utils = require(\"./utils\");\n\n(0, _utils.default)(\"JSXAttribute\", {\n  visitor: [\"name\", \"value\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXNamespacedName\")\n    },\n    value: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"JSXElement\", \"JSXFragment\", \"StringLiteral\", \"JSXExpressionContainer\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXClosingElement\", {\n  visitor: [\"name\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\", \"JSXNamespacedName\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXElement\", {\n  builder: [\"openingElement\", \"closingElement\", \"children\", \"selfClosing\"],\n  visitor: [\"openingElement\", \"children\", \"closingElement\"],\n  aliases: [\"JSX\", \"Immutable\", \"Expression\"],\n  fields: {\n    openingElement: {\n      validate: (0, _utils.assertNodeType)(\"JSXOpeningElement\")\n    },\n    closingElement: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"JSXClosingElement\")\n    },\n    children: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\", \"JSXFragment\")))\n    },\n    selfClosing: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"JSXEmptyExpression\", {\n  aliases: [\"JSX\"]\n});\n(0, _utils.default)(\"JSXExpressionContainer\", {\n  visitor: [\"expression\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"JSXEmptyExpression\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXSpreadChild\", {\n  visitor: [\"expression\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXIdentifier\", {\n  builder: [\"name\"],\n  aliases: [\"JSX\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXMemberExpression\", {\n  visitor: [\"object\", \"property\"],\n  aliases: [\"JSX\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"JSXMemberExpression\", \"JSXIdentifier\")\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXNamespacedName\", {\n  visitor: [\"namespace\", \"name\"],\n  aliases: [\"JSX\"],\n  fields: {\n    namespace: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    },\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXOpeningElement\", {\n  builder: [\"name\", \"attributes\", \"selfClosing\"],\n  visitor: [\"name\", \"attributes\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\", \"JSXNamespacedName\")\n    },\n    selfClosing: {\n      default: false\n    },\n    attributes: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"JSXAttribute\", \"JSXSpreadAttribute\")))\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"JSXSpreadAttribute\", {\n  visitor: [\"argument\"],\n  aliases: [\"JSX\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXText\", {\n  aliases: [\"JSX\", \"Immutable\"],\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"JSXFragment\", {\n  builder: [\"openingFragment\", \"closingFragment\", \"children\"],\n  visitor: [\"openingFragment\", \"children\", \"closingFragment\"],\n  aliases: [\"JSX\", \"Immutable\", \"Expression\"],\n  fields: {\n    openingFragment: {\n      validate: (0, _utils.assertNodeType)(\"JSXOpeningFragment\")\n    },\n    closingFragment: {\n      validate: (0, _utils.assertNodeType)(\"JSXClosingFragment\")\n    },\n    children: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\", \"JSXFragment\")))\n    }\n  }\n});\n(0, _utils.default)(\"JSXOpeningFragment\", {\n  aliases: [\"JSX\", \"Immutable\"]\n});\n(0, _utils.default)(\"JSXClosingFragment\", {\n  aliases: [\"JSX\", \"Immutable\"]\n});","\"use strict\";\n\nvar _utils = require(\"./utils\");\n\nvar _placeholders = require(\"./placeholders\");\n\n{\n  (0, _utils.default)(\"Noop\", {\n    visitor: []\n  });\n}\n(0, _utils.default)(\"Placeholder\", {\n  visitor: [],\n  builder: [\"expectedNode\", \"name\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    expectedNode: {\n      validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)\n    }\n  }\n});\n(0, _utils.default)(\"V8IntrinsicIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;\n\nvar _utils = require(\"./utils\");\n\nconst PLACEHOLDERS = [\"Identifier\", \"StringLiteral\", \"Expression\", \"Statement\", \"Declaration\", \"BlockStatement\", \"ClassBody\", \"Pattern\"];\nexports.PLACEHOLDERS = PLACEHOLDERS;\nconst PLACEHOLDERS_ALIAS = {\n  Declaration: [\"Statement\"],\n  Pattern: [\"PatternLike\", \"LVal\"]\n};\nexports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;\n\nfor (const type of PLACEHOLDERS) {\n  const alias = _utils.ALIAS_KEYS[type];\n  if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;\n}\n\nconst PLACEHOLDERS_FLIPPED_ALIAS = {};\nexports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;\nObject.keys(PLACEHOLDERS_ALIAS).forEach(type => {\n  PLACEHOLDERS_ALIAS[type].forEach(alias => {\n    if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {\n      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];\n    }\n\n    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);\n  });\n});","\"use strict\";\n\nvar _utils = require(\"./utils\");\n\nvar _core = require(\"./core\");\n\nvar _is = require(\"../validators/is\");\n\nconst bool = (0, _utils.assertValueType)(\"boolean\");\nconst tSFunctionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\n(0, _utils.default)(\"TSParameterProperty\", {\n  aliases: [\"LVal\"],\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    parameter: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"AssignmentPattern\")\n    },\n    override: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)\n});\n(0, _utils.default)(\"TSDeclareMethod\", {\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)\n});\n(0, _utils.default)(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: (0, _utils.validateType)(\"TSEntityName\"),\n    right: (0, _utils.validateType)(\"Identifier\")\n  }\n});\nconst signatureDeclarationCommon = {\n  typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n  parameters: (0, _utils.validateArrayOfType)([\"Identifier\", \"RestElement\"]),\n  typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n};\nconst callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: signatureDeclarationCommon\n};\n(0, _utils.default)(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\n(0, _utils.default)(\"TSConstructSignatureDeclaration\", callConstructSignatureDeclaration);\nconst namedTypeElementCommon = {\n  key: (0, _utils.validateType)(\"Expression\"),\n  computed: (0, _utils.validate)(bool),\n  optional: (0, _utils.validateOptional)(bool)\n};\n(0, _utils.default)(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\", \"initializer\"],\n  fields: Object.assign({}, namedTypeElementCommon, {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\"),\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\")\n    }\n  })\n});\n(0, _utils.default)(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeParameters\", \"parameters\", \"typeAnnotation\"],\n  fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }\n  })\n});\n(0, _utils.default)(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    static: (0, _utils.validateOptional)(bool),\n    parameters: (0, _utils.validateArrayOfType)(\"Identifier\"),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n  }\n});\nconst tsKeywordTypes = [\"TSAnyKeyword\", \"TSBooleanKeyword\", \"TSBigIntKeyword\", \"TSIntrinsicKeyword\", \"TSNeverKeyword\", \"TSNullKeyword\", \"TSNumberKeyword\", \"TSObjectKeyword\", \"TSStringKeyword\", \"TSSymbolKeyword\", \"TSUndefinedKeyword\", \"TSUnknownKeyword\", \"TSVoidKeyword\"];\n\nfor (const type of tsKeywordTypes) {\n  (0, _utils.default)(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {}\n  });\n}\n\n(0, _utils.default)(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {}\n});\nconst fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameters\", \"parameters\", \"typeAnnotation\"]\n};\n(0, _utils.default)(\"TSFunctionType\", Object.assign({}, fnOrCtrBase, {\n  fields: signatureDeclarationCommon\n}));\n(0, _utils.default)(\"TSConstructorType\", Object.assign({}, fnOrCtrBase, {\n  fields: Object.assign({}, signatureDeclarationCommon, {\n    abstract: (0, _utils.validateOptional)(bool)\n  })\n}));\n(0, _utils.default)(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeParameters\"],\n  fields: {\n    typeName: (0, _utils.validateType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\n(0, _utils.default)(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: (0, _utils.validateType)([\"Identifier\", \"TSThisType\"]),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n    asserts: (0, _utils.validateOptional)(bool)\n  }\n});\n(0, _utils.default)(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\"],\n  fields: {\n    exprName: (0, _utils.validateType)([\"TSEntityName\", \"TSImportType\"])\n  }\n});\n(0, _utils.default)(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\n(0, _utils.default)(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: (0, _utils.validateArrayOfType)([\"TSType\", \"TSNamedTupleMember\"])\n  }\n});\n(0, _utils.default)(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: (0, _utils.validateType)(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false\n    },\n    elementType: (0, _utils.validateType)(\"TSType\")\n  }\n});\nconst unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: (0, _utils.validateArrayOfType)(\"TSType\")\n  }\n};\n(0, _utils.default)(\"TSUnionType\", unionOrIntersection);\n(0, _utils.default)(\"TSIntersectionType\", unionOrIntersection);\n(0, _utils.default)(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: (0, _utils.validateType)(\"TSType\"),\n    extendsType: (0, _utils.validateType)(\"TSType\"),\n    trueType: (0, _utils.validateType)(\"TSType\"),\n    falseType: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\")\n  }\n});\n(0, _utils.default)(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    operator: (0, _utils.validate)((0, _utils.assertValueType)(\"string\")),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: (0, _utils.validateType)(\"TSType\"),\n    indexType: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\", \"typeAnnotation\", \"nameType\"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeParameter: (0, _utils.validateType)(\"TSTypeParameter\"),\n    optional: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)(\"TSType\"),\n    nameType: (0, _utils.validateOptionalType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: function () {\n        const unaryExpression = (0, _utils.assertNodeType)(\"NumericLiteral\", \"BigIntLiteral\");\n        const unaryOperator = (0, _utils.assertOneOf)(\"-\");\n        const literal = (0, _utils.assertNodeType)(\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\");\n\n        function validator(parent, key, node) {\n          if ((0, _is.default)(\"UnaryExpression\", node)) {\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            literal(parent, key, node);\n          }\n        }\n\n        validator.oneOfNodeTypes = [\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\", \"UnaryExpression\"];\n        return validator;\n      }()\n    }\n  }\n});\n(0, _utils.default)(\"TSExpressionWithTypeArguments\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\n(0, _utils.default)(\"TSInterfaceDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\")),\n    body: (0, _utils.validateType)(\"TSInterfaceBody\")\n  }\n});\n(0, _utils.default)(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n  }\n});\n(0, _utils.default)(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSAsExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\"),\n    typeAnnotation: (0, _utils.validateType)(\"TSType\")\n  }\n});\n(0, _utils.default)(\"TSTypeAssertion\", {\n  aliases: [\"Expression\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)(\"TSType\"),\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\n(0, _utils.default)(\"TSEnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"members\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    const: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    members: (0, _utils.validateArrayOfType)(\"TSEnumMember\"),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  }\n});\n(0, _utils.default)(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    initializer: (0, _utils.validateOptionalType)(\"Expression\")\n  }\n});\n(0, _utils.default)(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    global: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)([\"Identifier\", \"StringLiteral\"]),\n    body: (0, _utils.validateType)([\"TSModuleBlock\", \"TSModuleDeclaration\"])\n  }\n});\n(0, _utils.default)(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)(\"Statement\")\n  }\n});\n(0, _utils.default)(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"argument\", \"qualifier\", \"typeParameters\"],\n  fields: {\n    argument: (0, _utils.validateType)(\"StringLiteral\"),\n    qualifier: (0, _utils.validateOptionalType)(\"TSEntityName\"),\n    typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n  }\n});\n(0, _utils.default)(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: {\n    isExport: (0, _utils.validate)(bool),\n    id: (0, _utils.validateType)(\"Identifier\"),\n    moduleReference: (0, _utils.validateType)([\"TSEntityName\", \"TSExternalModuleReference\"]),\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"StringLiteral\")\n  }\n});\n(0, _utils.default)(\"TSNonNullExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\n(0, _utils.default)(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: (0, _utils.validateType)(\"Expression\")\n  }\n});\n(0, _utils.default)(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: (0, _utils.validateType)(\"Identifier\")\n  }\n});\n(0, _utils.default)(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TSType\")\n    }\n  }\n});\n(0, _utils.default)(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSType\")))\n    }\n  }\n});\n(0, _utils.default)(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSTypeParameter\")))\n    }\n  }\n});\n(0, _utils.default)(\"TSTypeParameter\", {\n  builder: [\"constraint\", \"default\", \"name\"],\n  visitor: [\"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    constraint: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    },\n    default: {\n      validate: (0, _utils.assertNodeType)(\"TSType\"),\n      optional: true\n    }\n  }\n});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validate = validate;\nexports.typeIs = typeIs;\nexports.validateType = validateType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.validateArrayOfType = validateArrayOfType;\nexports.assertEach = assertEach;\nexports.assertOneOf = assertOneOf;\nexports.assertNodeType = assertNodeType;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertValueType = assertValueType;\nexports.assertShape = assertShape;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.chain = chain;\nexports.default = defineType;\nexports.NODE_PARENT_VALIDATIONS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;\n\nvar _is = require(\"../validators/is\");\n\nvar _validate = require(\"../validators/validate\");\n\nconst VISITOR_KEYS = {};\nexports.VISITOR_KEYS = VISITOR_KEYS;\nconst ALIAS_KEYS = {};\nexports.ALIAS_KEYS = ALIAS_KEYS;\nconst FLIPPED_ALIAS_KEYS = {};\nexports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;\nconst NODE_FIELDS = {};\nexports.NODE_FIELDS = NODE_FIELDS;\nconst BUILDER_KEYS = {};\nexports.BUILDER_KEYS = BUILDER_KEYS;\nconst DEPRECATED_KEYS = {};\nexports.DEPRECATED_KEYS = DEPRECATED_KEYS;\nconst NODE_PARENT_VALIDATIONS = {};\nexports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;\n\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\n\nfunction validate(validate) {\n  return {\n    validate\n  };\n}\n\nfunction typeIs(typeName) {\n  return typeof typeName === \"string\" ? assertNodeType(typeName) : assertNodeType(...typeName);\n}\n\nfunction validateType(typeName) {\n  return validate(typeIs(typeName));\n}\n\nfunction validateOptional(validate) {\n  return {\n    validate,\n    optional: true\n  };\n}\n\nfunction validateOptionalType(typeName) {\n  return {\n    validate: typeIs(typeName),\n    optional: true\n  };\n}\n\nfunction arrayOf(elementType) {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nfunction arrayOfType(typeName) {\n  return arrayOf(typeIs(typeName));\n}\n\nfunction validateArrayOfType(typeName) {\n  return validate(arrayOfType(typeName));\n}\n\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n\n    for (let i = 0; i < val.length; i++) {\n      const subkey = `${key}[${i}]`;\n      const v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);\n    }\n  }\n\n  validator.each = callback;\n  return validator;\n}\n\nfunction assertOneOf(...values) {\n  function validate(node, key, val) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);\n    }\n  }\n\n  validate.oneOf = values;\n  return validate;\n}\n\nfunction assertNodeType(...types) {\n  function validate(node, key, val) {\n    for (const type of types) {\n      if ((0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\n\nfunction assertNodeOrValueType(...types) {\n  function validate(node, key, val) {\n    for (const type of types) {\n      if (getType(val) === type || (0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\n\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    const valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);\n    }\n  }\n\n  validate.type = type;\n  return validate;\n}\n\nfunction assertShape(shape) {\n  function validate(node, key, val) {\n    const errors = [];\n\n    for (const property of Object.keys(shape)) {\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n\n        throw error;\n      }\n    }\n\n    if (errors.length) {\n      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\\n${errors.join(\"\\n\")}`);\n    }\n  }\n\n  validate.shapeOf = shape;\n  return validate;\n}\n\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n\n    let current = node;\n\n    while (node) {\n      const {\n        type\n      } = current;\n\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);\n  }\n\n  return validate;\n}\n\nfunction chain(...fns) {\n  function validate(...args) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n\n  validate.chainOf = fns;\n\n  if (fns.length >= 2 && \"type\" in fns[0] && fns[0].type === \"array\" && !(\"each\" in fns[1])) {\n    throw new Error(`An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`);\n  }\n\n  return validate;\n}\n\nconst validTypeOpts = [\"aliases\", \"builder\", \"deprecatedAlias\", \"fields\", \"inherits\", \"visitor\", \"validate\"];\nconst validFieldKeys = [\"default\", \"optional\", \"validate\"];\n\nfunction defineType(type, opts = {}) {\n  const inherits = opts.inherits && store[opts.inherits] || {};\n  let fields = opts.fields;\n\n  if (!fields) {\n    fields = {};\n\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n\n        if (Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\") {\n          throw new Error(\"field defaults can only be primitives or empty arrays currently\");\n        }\n\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          validate: field.validate\n        };\n      }\n    }\n  }\n\n  const visitor = opts.visitor || inherits.visitor || [];\n  const aliases = opts.aliases || inherits.aliases || [];\n  const builder = opts.builder || inherits.builder || opts.visitor || [];\n\n  for (const k of Object.keys(opts)) {\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n\n    if (field.default !== undefined && builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n\n    for (const k of Object.keys(field)) {\n      if (validFieldKeys.indexOf(k) === -1) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n\n  store[type] = opts;\n}\n\nconst store = {};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  react: true,\n  assertNode: true,\n  createTypeAnnotationBasedOnTypeof: true,\n  createUnionTypeAnnotation: true,\n  createFlowUnionType: true,\n  createTSUnionType: true,\n  cloneNode: true,\n  clone: true,\n  cloneDeep: true,\n  cloneDeepWithoutLoc: true,\n  cloneWithoutLoc: true,\n  addComment: true,\n  addComments: true,\n  inheritInnerComments: true,\n  inheritLeadingComments: true,\n  inheritsComments: true,\n  inheritTrailingComments: true,\n  removeComments: true,\n  ensureBlock: true,\n  toBindingIdentifierName: true,\n  toBlock: true,\n  toComputedKey: true,\n  toExpression: true,\n  toIdentifier: true,\n  toKeyAlias: true,\n  toSequenceExpression: true,\n  toStatement: true,\n  valueToNode: true,\n  appendToMemberExpression: true,\n  inherits: true,\n  prependToMemberExpression: true,\n  removeProperties: true,\n  removePropertiesDeep: true,\n  removeTypeDuplicates: true,\n  getBindingIdentifiers: true,\n  getOuterBindingIdentifiers: true,\n  traverse: true,\n  traverseFast: true,\n  shallowEqual: true,\n  is: true,\n  isBinding: true,\n  isBlockScoped: true,\n  isImmutable: true,\n  isLet: true,\n  isNode: true,\n  isNodesEquivalent: true,\n  isPlaceholderType: true,\n  isReferenced: true,\n  isScope: true,\n  isSpecifierDefault: true,\n  isType: true,\n  isValidES3Identifier: true,\n  isValidIdentifier: true,\n  isVar: true,\n  matchesPattern: true,\n  validate: true,\n  buildMatchMemberExpression: true\n};\nObject.defineProperty(exports, \"assertNode\", {\n  enumerable: true,\n  get: function () {\n    return _assertNode.default;\n  }\n});\nObject.defineProperty(exports, \"createTypeAnnotationBasedOnTypeof\", {\n  enumerable: true,\n  get: function () {\n    return _createTypeAnnotationBasedOnTypeof.default;\n  }\n});\nObject.defineProperty(exports, \"createUnionTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _createFlowUnionType.default;\n  }\n});\nObject.defineProperty(exports, \"createFlowUnionType\", {\n  enumerable: true,\n  get: function () {\n    return _createFlowUnionType.default;\n  }\n});\nObject.defineProperty(exports, \"createTSUnionType\", {\n  enumerable: true,\n  get: function () {\n    return _createTSUnionType.default;\n  }\n});\nObject.defineProperty(exports, \"cloneNode\", {\n  enumerable: true,\n  get: function () {\n    return _cloneNode.default;\n  }\n});\nObject.defineProperty(exports, \"clone\", {\n  enumerable: true,\n  get: function () {\n    return _clone.default;\n  }\n});\nObject.defineProperty(exports, \"cloneDeep\", {\n  enumerable: true,\n  get: function () {\n    return _cloneDeep.default;\n  }\n});\nObject.defineProperty(exports, \"cloneDeepWithoutLoc\", {\n  enumerable: true,\n  get: function () {\n    return _cloneDeepWithoutLoc.default;\n  }\n});\nObject.defineProperty(exports, \"cloneWithoutLoc\", {\n  enumerable: true,\n  get: function () {\n    return _cloneWithoutLoc.default;\n  }\n});\nObject.defineProperty(exports, \"addComment\", {\n  enumerable: true,\n  get: function () {\n    return _addComment.default;\n  }\n});\nObject.defineProperty(exports, \"addComments\", {\n  enumerable: true,\n  get: function () {\n    return _addComments.default;\n  }\n});\nObject.defineProperty(exports, \"inheritInnerComments\", {\n  enumerable: true,\n  get: function () {\n    return _inheritInnerComments.default;\n  }\n});\nObject.defineProperty(exports, \"inheritLeadingComments\", {\n  enumerable: true,\n  get: function () {\n    return _inheritLeadingComments.default;\n  }\n});\nObject.defineProperty(exports, \"inheritsComments\", {\n  enumerable: true,\n  get: function () {\n    return _inheritsComments.default;\n  }\n});\nObject.defineProperty(exports, \"inheritTrailingComments\", {\n  enumerable: true,\n  get: function () {\n    return _inheritTrailingComments.default;\n  }\n});\nObject.defineProperty(exports, \"removeComments\", {\n  enumerable: true,\n  get: function () {\n    return _removeComments.default;\n  }\n});\nObject.defineProperty(exports, \"ensureBlock\", {\n  enumerable: true,\n  get: function () {\n    return _ensureBlock.default;\n  }\n});\nObject.defineProperty(exports, \"toBindingIdentifierName\", {\n  enumerable: true,\n  get: function () {\n    return _toBindingIdentifierName.default;\n  }\n});\nObject.defineProperty(exports, \"toBlock\", {\n  enumerable: true,\n  get: function () {\n    return _toBlock.default;\n  }\n});\nObject.defineProperty(exports, \"toComputedKey\", {\n  enumerable: true,\n  get: function () {\n    return _toComputedKey.default;\n  }\n});\nObject.defineProperty(exports, \"toExpression\", {\n  enumerable: true,\n  get: function () {\n    return _toExpression.default;\n  }\n});\nObject.defineProperty(exports, \"toIdentifier\", {\n  enumerable: true,\n  get: function () {\n    return _toIdentifier.default;\n  }\n});\nObject.defineProperty(exports, \"toKeyAlias\", {\n  enumerable: true,\n  get: function () {\n    return _toKeyAlias.default;\n  }\n});\nObject.defineProperty(exports, \"toSequenceExpression\", {\n  enumerable: true,\n  get: function () {\n    return _toSequenceExpression.default;\n  }\n});\nObject.defineProperty(exports, \"toStatement\", {\n  enumerable: true,\n  get: function () {\n    return _toStatement.default;\n  }\n});\nObject.defineProperty(exports, \"valueToNode\", {\n  enumerable: true,\n  get: function () {\n    return _valueToNode.default;\n  }\n});\nObject.defineProperty(exports, \"appendToMemberExpression\", {\n  enumerable: true,\n  get: function () {\n    return _appendToMemberExpression.default;\n  }\n});\nObject.defineProperty(exports, \"inherits\", {\n  enumerable: true,\n  get: function () {\n    return _inherits.default;\n  }\n});\nObject.defineProperty(exports, \"prependToMemberExpression\", {\n  enumerable: true,\n  get: function () {\n    return _prependToMemberExpression.default;\n  }\n});\nObject.defineProperty(exports, \"removeProperties\", {\n  enumerable: true,\n  get: function () {\n    return _removeProperties.default;\n  }\n});\nObject.defineProperty(exports, \"removePropertiesDeep\", {\n  enumerable: true,\n  get: function () {\n    return _removePropertiesDeep.default;\n  }\n});\nObject.defineProperty(exports, \"removeTypeDuplicates\", {\n  enumerable: true,\n  get: function () {\n    return _removeTypeDuplicates.default;\n  }\n});\nObject.defineProperty(exports, \"getBindingIdentifiers\", {\n  enumerable: true,\n  get: function () {\n    return _getBindingIdentifiers.default;\n  }\n});\nObject.defineProperty(exports, \"getOuterBindingIdentifiers\", {\n  enumerable: true,\n  get: function () {\n    return _getOuterBindingIdentifiers.default;\n  }\n});\nObject.defineProperty(exports, \"traverse\", {\n  enumerable: true,\n  get: function () {\n    return _traverse.default;\n  }\n});\nObject.defineProperty(exports, \"traverseFast\", {\n  enumerable: true,\n  get: function () {\n    return _traverseFast.default;\n  }\n});\nObject.defineProperty(exports, \"shallowEqual\", {\n  enumerable: true,\n  get: function () {\n    return _shallowEqual.default;\n  }\n});\nObject.defineProperty(exports, \"is\", {\n  enumerable: true,\n  get: function () {\n    return _is.default;\n  }\n});\nObject.defineProperty(exports, \"isBinding\", {\n  enumerable: true,\n  get: function () {\n    return _isBinding.default;\n  }\n});\nObject.defineProperty(exports, \"isBlockScoped\", {\n  enumerable: true,\n  get: function () {\n    return _isBlockScoped.default;\n  }\n});\nObject.defineProperty(exports, \"isImmutable\", {\n  enumerable: true,\n  get: function () {\n    return _isImmutable.default;\n  }\n});\nObject.defineProperty(exports, \"isLet\", {\n  enumerable: true,\n  get: function () {\n    return _isLet.default;\n  }\n});\nObject.defineProperty(exports, \"isNode\", {\n  enumerable: true,\n  get: function () {\n    return _isNode.default;\n  }\n});\nObject.defineProperty(exports, \"isNodesEquivalent\", {\n  enumerable: true,\n  get: function () {\n    return _isNodesEquivalent.default;\n  }\n});\nObject.defineProperty(exports, \"isPlaceholderType\", {\n  enumerable: true,\n  get: function () {\n    return _isPlaceholderType.default;\n  }\n});\nObject.defineProperty(exports, \"isReferenced\", {\n  enumerable: true,\n  get: function () {\n    return _isReferenced.default;\n  }\n});\nObject.defineProperty(exports, \"isScope\", {\n  enumerable: true,\n  get: function () {\n    return _isScope.default;\n  }\n});\nObject.defineProperty(exports, \"isSpecifierDefault\", {\n  enumerable: true,\n  get: function () {\n    return _isSpecifierDefault.default;\n  }\n});\nObject.defineProperty(exports, \"isType\", {\n  enumerable: true,\n  get: function () {\n    return _isType.default;\n  }\n});\nObject.defineProperty(exports, \"isValidES3Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _isValidES3Identifier.default;\n  }\n});\nObject.defineProperty(exports, \"isValidIdentifier\", {\n  enumerable: true,\n  get: function () {\n    return _isValidIdentifier.default;\n  }\n});\nObject.defineProperty(exports, \"isVar\", {\n  enumerable: true,\n  get: function () {\n    return _isVar.default;\n  }\n});\nObject.defineProperty(exports, \"matchesPattern\", {\n  enumerable: true,\n  get: function () {\n    return _matchesPattern.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"buildMatchMemberExpression\", {\n  enumerable: true,\n  get: function () {\n    return _buildMatchMemberExpression.default;\n  }\n});\nexports.react = void 0;\n\nvar _isReactComponent = require(\"./validators/react/isReactComponent\");\n\nvar _isCompatTag = require(\"./validators/react/isCompatTag\");\n\nvar _buildChildren = require(\"./builders/react/buildChildren\");\n\nvar _assertNode = require(\"./asserts/assertNode\");\n\nvar _generated = require(\"./asserts/generated\");\n\nObject.keys(_generated).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _generated[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _generated[key];\n    }\n  });\n});\n\nvar _createTypeAnnotationBasedOnTypeof = require(\"./builders/flow/createTypeAnnotationBasedOnTypeof\");\n\nvar _createFlowUnionType = require(\"./builders/flow/createFlowUnionType\");\n\nvar _createTSUnionType = require(\"./builders/typescript/createTSUnionType\");\n\nvar _generated2 = require(\"./builders/generated\");\n\nObject.keys(_generated2).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _generated2[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _generated2[key];\n    }\n  });\n});\n\nvar _uppercase = require(\"./builders/generated/uppercase\");\n\nObject.keys(_uppercase).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _uppercase[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _uppercase[key];\n    }\n  });\n});\n\nvar _cloneNode = require(\"./clone/cloneNode\");\n\nvar _clone = require(\"./clone/clone\");\n\nvar _cloneDeep = require(\"./clone/cloneDeep\");\n\nvar _cloneDeepWithoutLoc = require(\"./clone/cloneDeepWithoutLoc\");\n\nvar _cloneWithoutLoc = require(\"./clone/cloneWithoutLoc\");\n\nvar _addComment = require(\"./comments/addComment\");\n\nvar _addComments = require(\"./comments/addComments\");\n\nvar _inheritInnerComments = require(\"./comments/inheritInnerComments\");\n\nvar _inheritLeadingComments = require(\"./comments/inheritLeadingComments\");\n\nvar _inheritsComments = require(\"./comments/inheritsComments\");\n\nvar _inheritTrailingComments = require(\"./comments/inheritTrailingComments\");\n\nvar _removeComments = require(\"./comments/removeComments\");\n\nvar _generated3 = require(\"./constants/generated\");\n\nObject.keys(_generated3).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _generated3[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _generated3[key];\n    }\n  });\n});\n\nvar _constants = require(\"./constants\");\n\nObject.keys(_constants).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _constants[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _constants[key];\n    }\n  });\n});\n\nvar _ensureBlock = require(\"./converters/ensureBlock\");\n\nvar _toBindingIdentifierName = require(\"./converters/toBindingIdentifierName\");\n\nvar _toBlock = require(\"./converters/toBlock\");\n\nvar _toComputedKey = require(\"./converters/toComputedKey\");\n\nvar _toExpression = require(\"./converters/toExpression\");\n\nvar _toIdentifier = require(\"./converters/toIdentifier\");\n\nvar _toKeyAlias = require(\"./converters/toKeyAlias\");\n\nvar _toSequenceExpression = require(\"./converters/toSequenceExpression\");\n\nvar _toStatement = require(\"./converters/toStatement\");\n\nvar _valueToNode = require(\"./converters/valueToNode\");\n\nvar _definitions = require(\"./definitions\");\n\nObject.keys(_definitions).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _definitions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _definitions[key];\n    }\n  });\n});\n\nvar _appendToMemberExpression = require(\"./modifications/appendToMemberExpression\");\n\nvar _inherits = require(\"./modifications/inherits\");\n\nvar _prependToMemberExpression = require(\"./modifications/prependToMemberExpression\");\n\nvar _removeProperties = require(\"./modifications/removeProperties\");\n\nvar _removePropertiesDeep = require(\"./modifications/removePropertiesDeep\");\n\nvar _removeTypeDuplicates = require(\"./modifications/flow/removeTypeDuplicates\");\n\nvar _getBindingIdentifiers = require(\"./retrievers/getBindingIdentifiers\");\n\nvar _getOuterBindingIdentifiers = require(\"./retrievers/getOuterBindingIdentifiers\");\n\nvar _traverse = require(\"./traverse/traverse\");\n\nObject.keys(_traverse).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _traverse[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _traverse[key];\n    }\n  });\n});\n\nvar _traverseFast = require(\"./traverse/traverseFast\");\n\nvar _shallowEqual = require(\"./utils/shallowEqual\");\n\nvar _is = require(\"./validators/is\");\n\nvar _isBinding = require(\"./validators/isBinding\");\n\nvar _isBlockScoped = require(\"./validators/isBlockScoped\");\n\nvar _isImmutable = require(\"./validators/isImmutable\");\n\nvar _isLet = require(\"./validators/isLet\");\n\nvar _isNode = require(\"./validators/isNode\");\n\nvar _isNodesEquivalent = require(\"./validators/isNodesEquivalent\");\n\nvar _isPlaceholderType = require(\"./validators/isPlaceholderType\");\n\nvar _isReferenced = require(\"./validators/isReferenced\");\n\nvar _isScope = require(\"./validators/isScope\");\n\nvar _isSpecifierDefault = require(\"./validators/isSpecifierDefault\");\n\nvar _isType = require(\"./validators/isType\");\n\nvar _isValidES3Identifier = require(\"./validators/isValidES3Identifier\");\n\nvar _isValidIdentifier = require(\"./validators/isValidIdentifier\");\n\nvar _isVar = require(\"./validators/isVar\");\n\nvar _matchesPattern = require(\"./validators/matchesPattern\");\n\nvar _validate = require(\"./validators/validate\");\n\nvar _buildMatchMemberExpression = require(\"./validators/buildMatchMemberExpression\");\n\nvar _generated4 = require(\"./validators/generated\");\n\nObject.keys(_generated4).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _generated4[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _generated4[key];\n    }\n  });\n});\n\nvar _generated5 = require(\"./ast-types/generated\");\n\nObject.keys(_generated5).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _generated5[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _generated5[key];\n    }\n  });\n});\nconst react = {\n  isReactComponent: _isReactComponent.default,\n  isCompatTag: _isCompatTag.default,\n  buildChildren: _buildChildren.default\n};\nexports.react = react;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = appendToMemberExpression;\n\nvar _generated = require(\"../builders/generated\");\n\nfunction appendToMemberExpression(member, append, computed = false) {\n  member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);\n  member.property = append;\n  member.computed = !!computed;\n  return member;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\n\nvar _generated = require(\"../../validators/generated\");\n\nfunction getQualifiedName(node) {\n  return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\n\nfunction removeTypeDuplicates(nodes) {\n  const generics = {};\n  const bases = {};\n  const typeGroups = new Set();\n  const types = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isFlowBaseAnnotation)(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    if ((0, _generated.isUnionTypeAnnotation)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes = nodes.concat(node.types);\n        typeGroups.add(node.types);\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isGenericTypeAnnotation)(node)) {\n      const name = getQualifiedName(node.id);\n\n      if (generics[name]) {\n        let existing = generics[name];\n\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (const type of Object.keys(bases)) {\n    types.push(bases[type]);\n  }\n\n  for (const name of Object.keys(generics)) {\n    types.push(generics[name]);\n  }\n\n  return types;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inherits;\n\nvar _constants = require(\"../constants\");\n\nvar _inheritsComments = require(\"../comments/inheritsComments\");\n\nfunction inherits(child, parent) {\n  if (!child || !parent) return child;\n\n  for (const key of _constants.INHERIT_KEYS.optional) {\n    if (child[key] == null) {\n      child[key] = parent[key];\n    }\n  }\n\n  for (const key of Object.keys(parent)) {\n    if (key[0] === \"_\" && key !== \"__clone\") child[key] = parent[key];\n  }\n\n  for (const key of _constants.INHERIT_KEYS.force) {\n    child[key] = parent[key];\n  }\n\n  (0, _inheritsComments.default)(child, parent);\n  return child;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = prependToMemberExpression;\n\nvar _generated = require(\"../builders/generated\");\n\nfunction prependToMemberExpression(member, prepend) {\n  member.object = (0, _generated.memberExpression)(prepend, member.object);\n  return member;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeProperties;\n\nvar _constants = require(\"../constants\");\n\nconst CLEAR_KEYS = [\"tokens\", \"start\", \"end\", \"loc\", \"raw\", \"rawValue\"];\n\nconst CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat([\"comments\"]).concat(CLEAR_KEYS);\n\nfunction removeProperties(node, opts = {}) {\n  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n\n  for (const key of map) {\n    if (node[key] != null) node[key] = undefined;\n  }\n\n  for (const key of Object.keys(node)) {\n    if (key[0] === \"_\" && node[key] != null) node[key] = undefined;\n  }\n\n  const symbols = Object.getOwnPropertySymbols(node);\n\n  for (const sym of symbols) {\n    node[sym] = null;\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removePropertiesDeep;\n\nvar _traverseFast = require(\"../traverse/traverseFast\");\n\nvar _removeProperties = require(\"./removeProperties\");\n\nfunction removePropertiesDeep(tree, opts) {\n  (0, _traverseFast.default)(tree, _removeProperties.default, opts);\n  return tree;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\n\nvar _generated = require(\"../../validators/generated\");\n\nfunction removeTypeDuplicates(nodes) {\n  const generics = {};\n  const bases = {};\n  const typeGroups = new Set();\n  const types = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isTSAnyKeyword)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isTSBaseType)(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    if ((0, _generated.isTSUnionType)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (const type of Object.keys(bases)) {\n    types.push(bases[type]);\n  }\n\n  for (const name of Object.keys(generics)) {\n    types.push(generics[name]);\n  }\n\n  return types;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getBindingIdentifiers;\n\nvar _generated = require(\"../validators/generated\");\n\nfunction getBindingIdentifiers(node, duplicates, outerOnly) {\n  let search = [].concat(node);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    const keys = getBindingIdentifiers.keys[id.type];\n\n    if ((0, _generated.isIdentifier)(id)) {\n      if (duplicates) {\n        const _ids = ids[id.name] = ids[id.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {\n      if ((0, _generated.isDeclaration)(id.declaration)) {\n        search.push(id.declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if ((0, _generated.isFunctionDeclaration)(id)) {\n        search.push(id.id);\n        continue;\n      }\n\n      if ((0, _generated.isFunctionExpression)(id)) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (id[key]) {\n          search = search.concat(id[key]);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\ngetBindingIdentifiers.keys = {\n  DeclareClass: [\"id\"],\n  DeclareFunction: [\"id\"],\n  DeclareModule: [\"id\"],\n  DeclareVariable: [\"id\"],\n  DeclareInterface: [\"id\"],\n  DeclareTypeAlias: [\"id\"],\n  DeclareOpaqueType: [\"id\"],\n  InterfaceDeclaration: [\"id\"],\n  TypeAlias: [\"id\"],\n  OpaqueType: [\"id\"],\n  CatchClause: [\"param\"],\n  LabeledStatement: [\"label\"],\n  UnaryExpression: [\"argument\"],\n  AssignmentExpression: [\"left\"],\n  ImportSpecifier: [\"local\"],\n  ImportNamespaceSpecifier: [\"local\"],\n  ImportDefaultSpecifier: [\"local\"],\n  ImportDeclaration: [\"specifiers\"],\n  ExportSpecifier: [\"exported\"],\n  ExportNamespaceSpecifier: [\"exported\"],\n  ExportDefaultSpecifier: [\"exported\"],\n  FunctionDeclaration: [\"id\", \"params\"],\n  FunctionExpression: [\"id\", \"params\"],\n  ArrowFunctionExpression: [\"params\"],\n  ObjectMethod: [\"params\"],\n  ClassMethod: [\"params\"],\n  ClassPrivateMethod: [\"params\"],\n  ForInStatement: [\"left\"],\n  ForOfStatement: [\"left\"],\n  ClassDeclaration: [\"id\"],\n  ClassExpression: [\"id\"],\n  RestElement: [\"argument\"],\n  UpdateExpression: [\"argument\"],\n  ObjectProperty: [\"value\"],\n  AssignmentPattern: [\"left\"],\n  ArrayPattern: [\"elements\"],\n  ObjectPattern: [\"properties\"],\n  VariableDeclaration: [\"declarations\"],\n  VariableDeclarator: [\"id\"]\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _getBindingIdentifiers = require(\"./getBindingIdentifiers\");\n\nvar _default = getOuterBindingIdentifiers;\nexports.default = _default;\n\nfunction getOuterBindingIdentifiers(node, duplicates) {\n  return (0, _getBindingIdentifiers.default)(node, duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverse;\n\nvar _definitions = require(\"../definitions\");\n\nfunction traverse(node, handlers, state) {\n  if (typeof handlers === \"function\") {\n    handlers = {\n      enter: handlers\n    };\n  }\n\n  const {\n    enter,\n    exit\n  } = handlers;\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\n\nfunction traverseSimpleImpl(node, enter, exit, state, ancestors) {\n  const keys = _definitions.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  if (enter) enter(node, ancestors, state);\n\n  for (const key of keys) {\n    const subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        if (!child) continue;\n        ancestors.push({\n          node,\n          key,\n          index: i\n        });\n        traverseSimpleImpl(child, enter, exit, state, ancestors);\n        ancestors.pop();\n      }\n    } else if (subNode) {\n      ancestors.push({\n        node,\n        key\n      });\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n      ancestors.pop();\n    }\n  }\n\n  if (exit) exit(node, ancestors, state);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverseFast;\n\nvar _definitions = require(\"../definitions\");\n\nfunction traverseFast(node, enter, opts) {\n  if (!node) return;\n  const keys = _definitions.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  opts = opts || {};\n  enter(node, opts);\n\n  for (const key of keys) {\n    const subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (const node of subNode) {\n        traverseFast(node, enter, opts);\n      }\n    } else {\n      traverseFast(subNode, enter, opts);\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inherit;\n\nfunction inherit(key, child, parent) {\n  if (child && parent) {\n    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cleanJSXElementLiteralChild;\n\nvar _generated = require(\"../../builders/generated\");\n\nfunction cleanJSXElementLiteralChild(child, args) {\n  const lines = child.value.split(/\\r\\n|\\n|\\r/);\n  let lastNonEmptyLine = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].match(/[^ \\t]/)) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  let str = \"\";\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const isFirstLine = i === 0;\n    const isLastLine = i === lines.length - 1;\n    const isLastNonEmptyLine = i === lastNonEmptyLine;\n    let trimmedLine = line.replace(/\\t/g, \" \");\n\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^[ ]+/, \"\");\n    }\n\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/[ ]+$/, \"\");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) args.push((0, _generated.stringLiteral)(str));\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = shallowEqual;\n\nfunction shallowEqual(actual, expected) {\n  const keys = Object.keys(expected);\n\n  for (const key of keys) {\n    if (actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = buildMatchMemberExpression;\n\nvar _matchesPattern = require(\"./matchesPattern\");\n\nfunction buildMatchMemberExpression(match, allowPartial) {\n  const parts = match.split(\".\");\n  return member => (0, _matchesPattern.default)(member, parts, allowPartial);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isArrayExpression = isArrayExpression;\nexports.isAssignmentExpression = isAssignmentExpression;\nexports.isBinaryExpression = isBinaryExpression;\nexports.isInterpreterDirective = isInterpreterDirective;\nexports.isDirective = isDirective;\nexports.isDirectiveLiteral = isDirectiveLiteral;\nexports.isBlockStatement = isBlockStatement;\nexports.isBreakStatement = isBreakStatement;\nexports.isCallExpression = isCallExpression;\nexports.isCatchClause = isCatchClause;\nexports.isConditionalExpression = isConditionalExpression;\nexports.isContinueStatement = isContinueStatement;\nexports.isDebuggerStatement = isDebuggerStatement;\nexports.isDoWhileStatement = isDoWhileStatement;\nexports.isEmptyStatement = isEmptyStatement;\nexports.isExpressionStatement = isExpressionStatement;\nexports.isFile = isFile;\nexports.isForInStatement = isForInStatement;\nexports.isForStatement = isForStatement;\nexports.isFunctionDeclaration = isFunctionDeclaration;\nexports.isFunctionExpression = isFunctionExpression;\nexports.isIdentifier = isIdentifier;\nexports.isIfStatement = isIfStatement;\nexports.isLabeledStatement = isLabeledStatement;\nexports.isStringLiteral = isStringLiteral;\nexports.isNumericLiteral = isNumericLiteral;\nexports.isNullLiteral = isNullLiteral;\nexports.isBooleanLiteral = isBooleanLiteral;\nexports.isRegExpLiteral = isRegExpLiteral;\nexports.isLogicalExpression = isLogicalExpression;\nexports.isMemberExpression = isMemberExpression;\nexports.isNewExpression = isNewExpression;\nexports.isProgram = isProgram;\nexports.isObjectExpression = isObjectExpression;\nexports.isObjectMethod = isObjectMethod;\nexports.isObjectProperty = isObjectProperty;\nexports.isRestElement = isRestElement;\nexports.isReturnStatement = isReturnStatement;\nexports.isSequenceExpression = isSequenceExpression;\nexports.isParenthesizedExpression = isParenthesizedExpression;\nexports.isSwitchCase = isSwitchCase;\nexports.isSwitchStatement = isSwitchStatement;\nexports.isThisExpression = isThisExpression;\nexports.isThrowStatement = isThrowStatement;\nexports.isTryStatement = isTryStatement;\nexports.isUnaryExpression = isUnaryExpression;\nexports.isUpdateExpression = isUpdateExpression;\nexports.isVariableDeclaration = isVariableDeclaration;\nexports.isVariableDeclarator = isVariableDeclarator;\nexports.isWhileStatement = isWhileStatement;\nexports.isWithStatement = isWithStatement;\nexports.isAssignmentPattern = isAssignmentPattern;\nexports.isArrayPattern = isArrayPattern;\nexports.isArrowFunctionExpression = isArrowFunctionExpression;\nexports.isClassBody = isClassBody;\nexports.isClassExpression = isClassExpression;\nexports.isClassDeclaration = isClassDeclaration;\nexports.isExportAllDeclaration = isExportAllDeclaration;\nexports.isExportDefaultDeclaration = isExportDefaultDeclaration;\nexports.isExportNamedDeclaration = isExportNamedDeclaration;\nexports.isExportSpecifier = isExportSpecifier;\nexports.isForOfStatement = isForOfStatement;\nexports.isImportDeclaration = isImportDeclaration;\nexports.isImportDefaultSpecifier = isImportDefaultSpecifier;\nexports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;\nexports.isImportSpecifier = isImportSpecifier;\nexports.isMetaProperty = isMetaProperty;\nexports.isClassMethod = isClassMethod;\nexports.isObjectPattern = isObjectPattern;\nexports.isSpreadElement = isSpreadElement;\nexports.isSuper = isSuper;\nexports.isTaggedTemplateExpression = isTaggedTemplateExpression;\nexports.isTemplateElement = isTemplateElement;\nexports.isTemplateLiteral = isTemplateLiteral;\nexports.isYieldExpression = isYieldExpression;\nexports.isAwaitExpression = isAwaitExpression;\nexports.isImport = isImport;\nexports.isBigIntLiteral = isBigIntLiteral;\nexports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;\nexports.isOptionalMemberExpression = isOptionalMemberExpression;\nexports.isOptionalCallExpression = isOptionalCallExpression;\nexports.isClassProperty = isClassProperty;\nexports.isClassPrivateProperty = isClassPrivateProperty;\nexports.isClassPrivateMethod = isClassPrivateMethod;\nexports.isPrivateName = isPrivateName;\nexports.isAnyTypeAnnotation = isAnyTypeAnnotation;\nexports.isArrayTypeAnnotation = isArrayTypeAnnotation;\nexports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;\nexports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;\nexports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;\nexports.isClassImplements = isClassImplements;\nexports.isDeclareClass = isDeclareClass;\nexports.isDeclareFunction = isDeclareFunction;\nexports.isDeclareInterface = isDeclareInterface;\nexports.isDeclareModule = isDeclareModule;\nexports.isDeclareModuleExports = isDeclareModuleExports;\nexports.isDeclareTypeAlias = isDeclareTypeAlias;\nexports.isDeclareOpaqueType = isDeclareOpaqueType;\nexports.isDeclareVariable = isDeclareVariable;\nexports.isDeclareExportDeclaration = isDeclareExportDeclaration;\nexports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;\nexports.isDeclaredPredicate = isDeclaredPredicate;\nexports.isExistsTypeAnnotation = isExistsTypeAnnotation;\nexports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;\nexports.isFunctionTypeParam = isFunctionTypeParam;\nexports.isGenericTypeAnnotation = isGenericTypeAnnotation;\nexports.isInferredPredicate = isInferredPredicate;\nexports.isInterfaceExtends = isInterfaceExtends;\nexports.isInterfaceDeclaration = isInterfaceDeclaration;\nexports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;\nexports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;\nexports.isMixedTypeAnnotation = isMixedTypeAnnotation;\nexports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;\nexports.isNullableTypeAnnotation = isNullableTypeAnnotation;\nexports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;\nexports.isNumberTypeAnnotation = isNumberTypeAnnotation;\nexports.isObjectTypeAnnotation = isObjectTypeAnnotation;\nexports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;\nexports.isObjectTypeCallProperty = isObjectTypeCallProperty;\nexports.isObjectTypeIndexer = isObjectTypeIndexer;\nexports.isObjectTypeProperty = isObjectTypeProperty;\nexports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;\nexports.isOpaqueType = isOpaqueType;\nexports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;\nexports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;\nexports.isStringTypeAnnotation = isStringTypeAnnotation;\nexports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;\nexports.isThisTypeAnnotation = isThisTypeAnnotation;\nexports.isTupleTypeAnnotation = isTupleTypeAnnotation;\nexports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;\nexports.isTypeAlias = isTypeAlias;\nexports.isTypeAnnotation = isTypeAnnotation;\nexports.isTypeCastExpression = isTypeCastExpression;\nexports.isTypeParameter = isTypeParameter;\nexports.isTypeParameterDeclaration = isTypeParameterDeclaration;\nexports.isTypeParameterInstantiation = isTypeParameterInstantiation;\nexports.isUnionTypeAnnotation = isUnionTypeAnnotation;\nexports.isVariance = isVariance;\nexports.isVoidTypeAnnotation = isVoidTypeAnnotation;\nexports.isEnumDeclaration = isEnumDeclaration;\nexports.isEnumBooleanBody = isEnumBooleanBody;\nexports.isEnumNumberBody = isEnumNumberBody;\nexports.isEnumStringBody = isEnumStringBody;\nexports.isEnumSymbolBody = isEnumSymbolBody;\nexports.isEnumBooleanMember = isEnumBooleanMember;\nexports.isEnumNumberMember = isEnumNumberMember;\nexports.isEnumStringMember = isEnumStringMember;\nexports.isEnumDefaultedMember = isEnumDefaultedMember;\nexports.isIndexedAccessType = isIndexedAccessType;\nexports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;\nexports.isJSXAttribute = isJSXAttribute;\nexports.isJSXClosingElement = isJSXClosingElement;\nexports.isJSXElement = isJSXElement;\nexports.isJSXEmptyExpression = isJSXEmptyExpression;\nexports.isJSXExpressionContainer = isJSXExpressionContainer;\nexports.isJSXSpreadChild = isJSXSpreadChild;\nexports.isJSXIdentifier = isJSXIdentifier;\nexports.isJSXMemberExpression = isJSXMemberExpression;\nexports.isJSXNamespacedName = isJSXNamespacedName;\nexports.isJSXOpeningElement = isJSXOpeningElement;\nexports.isJSXSpreadAttribute = isJSXSpreadAttribute;\nexports.isJSXText = isJSXText;\nexports.isJSXFragment = isJSXFragment;\nexports.isJSXOpeningFragment = isJSXOpeningFragment;\nexports.isJSXClosingFragment = isJSXClosingFragment;\nexports.isNoop = isNoop;\nexports.isPlaceholder = isPlaceholder;\nexports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;\nexports.isArgumentPlaceholder = isArgumentPlaceholder;\nexports.isBindExpression = isBindExpression;\nexports.isImportAttribute = isImportAttribute;\nexports.isDecorator = isDecorator;\nexports.isDoExpression = isDoExpression;\nexports.isExportDefaultSpecifier = isExportDefaultSpecifier;\nexports.isRecordExpression = isRecordExpression;\nexports.isTupleExpression = isTupleExpression;\nexports.isDecimalLiteral = isDecimalLiteral;\nexports.isStaticBlock = isStaticBlock;\nexports.isModuleExpression = isModuleExpression;\nexports.isTopicReference = isTopicReference;\nexports.isPipelineTopicExpression = isPipelineTopicExpression;\nexports.isPipelineBareFunction = isPipelineBareFunction;\nexports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;\nexports.isTSParameterProperty = isTSParameterProperty;\nexports.isTSDeclareFunction = isTSDeclareFunction;\nexports.isTSDeclareMethod = isTSDeclareMethod;\nexports.isTSQualifiedName = isTSQualifiedName;\nexports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;\nexports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;\nexports.isTSPropertySignature = isTSPropertySignature;\nexports.isTSMethodSignature = isTSMethodSignature;\nexports.isTSIndexSignature = isTSIndexSignature;\nexports.isTSAnyKeyword = isTSAnyKeyword;\nexports.isTSBooleanKeyword = isTSBooleanKeyword;\nexports.isTSBigIntKeyword = isTSBigIntKeyword;\nexports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;\nexports.isTSNeverKeyword = isTSNeverKeyword;\nexports.isTSNullKeyword = isTSNullKeyword;\nexports.isTSNumberKeyword = isTSNumberKeyword;\nexports.isTSObjectKeyword = isTSObjectKeyword;\nexports.isTSStringKeyword = isTSStringKeyword;\nexports.isTSSymbolKeyword = isTSSymbolKeyword;\nexports.isTSUndefinedKeyword = isTSUndefinedKeyword;\nexports.isTSUnknownKeyword = isTSUnknownKeyword;\nexports.isTSVoidKeyword = isTSVoidKeyword;\nexports.isTSThisType = isTSThisType;\nexports.isTSFunctionType = isTSFunctionType;\nexports.isTSConstructorType = isTSConstructorType;\nexports.isTSTypeReference = isTSTypeReference;\nexports.isTSTypePredicate = isTSTypePredicate;\nexports.isTSTypeQuery = isTSTypeQuery;\nexports.isTSTypeLiteral = isTSTypeLiteral;\nexports.isTSArrayType = isTSArrayType;\nexports.isTSTupleType = isTSTupleType;\nexports.isTSOptionalType = isTSOptionalType;\nexports.isTSRestType = isTSRestType;\nexports.isTSNamedTupleMember = isTSNamedTupleMember;\nexports.isTSUnionType = isTSUnionType;\nexports.isTSIntersectionType = isTSIntersectionType;\nexports.isTSConditionalType = isTSConditionalType;\nexports.isTSInferType = isTSInferType;\nexports.isTSParenthesizedType = isTSParenthesizedType;\nexports.isTSTypeOperator = isTSTypeOperator;\nexports.isTSIndexedAccessType = isTSIndexedAccessType;\nexports.isTSMappedType = isTSMappedType;\nexports.isTSLiteralType = isTSLiteralType;\nexports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;\nexports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;\nexports.isTSInterfaceBody = isTSInterfaceBody;\nexports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;\nexports.isTSAsExpression = isTSAsExpression;\nexports.isTSTypeAssertion = isTSTypeAssertion;\nexports.isTSEnumDeclaration = isTSEnumDeclaration;\nexports.isTSEnumMember = isTSEnumMember;\nexports.isTSModuleDeclaration = isTSModuleDeclaration;\nexports.isTSModuleBlock = isTSModuleBlock;\nexports.isTSImportType = isTSImportType;\nexports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;\nexports.isTSExternalModuleReference = isTSExternalModuleReference;\nexports.isTSNonNullExpression = isTSNonNullExpression;\nexports.isTSExportAssignment = isTSExportAssignment;\nexports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;\nexports.isTSTypeAnnotation = isTSTypeAnnotation;\nexports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;\nexports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;\nexports.isTSTypeParameter = isTSTypeParameter;\nexports.isExpression = isExpression;\nexports.isBinary = isBinary;\nexports.isScopable = isScopable;\nexports.isBlockParent = isBlockParent;\nexports.isBlock = isBlock;\nexports.isStatement = isStatement;\nexports.isTerminatorless = isTerminatorless;\nexports.isCompletionStatement = isCompletionStatement;\nexports.isConditional = isConditional;\nexports.isLoop = isLoop;\nexports.isWhile = isWhile;\nexports.isExpressionWrapper = isExpressionWrapper;\nexports.isFor = isFor;\nexports.isForXStatement = isForXStatement;\nexports.isFunction = isFunction;\nexports.isFunctionParent = isFunctionParent;\nexports.isPureish = isPureish;\nexports.isDeclaration = isDeclaration;\nexports.isPatternLike = isPatternLike;\nexports.isLVal = isLVal;\nexports.isTSEntityName = isTSEntityName;\nexports.isLiteral = isLiteral;\nexports.isImmutable = isImmutable;\nexports.isUserWhitespacable = isUserWhitespacable;\nexports.isMethod = isMethod;\nexports.isObjectMember = isObjectMember;\nexports.isProperty = isProperty;\nexports.isUnaryLike = isUnaryLike;\nexports.isPattern = isPattern;\nexports.isClass = isClass;\nexports.isModuleDeclaration = isModuleDeclaration;\nexports.isExportDeclaration = isExportDeclaration;\nexports.isModuleSpecifier = isModuleSpecifier;\nexports.isPrivate = isPrivate;\nexports.isFlow = isFlow;\nexports.isFlowType = isFlowType;\nexports.isFlowBaseAnnotation = isFlowBaseAnnotation;\nexports.isFlowDeclaration = isFlowDeclaration;\nexports.isFlowPredicate = isFlowPredicate;\nexports.isEnumBody = isEnumBody;\nexports.isEnumMember = isEnumMember;\nexports.isJSX = isJSX;\nexports.isTSTypeElement = isTSTypeElement;\nexports.isTSType = isTSType;\nexports.isTSBaseType = isTSBaseType;\nexports.isNumberLiteral = isNumberLiteral;\nexports.isRegexLiteral = isRegexLiteral;\nexports.isRestProperty = isRestProperty;\nexports.isSpreadProperty = isSpreadProperty;\n\nvar _shallowEqual = require(\"../../utils/shallowEqual\");\n\nfunction isArrayExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ArrayExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isAssignmentExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"AssignmentExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBinaryExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"BinaryExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isInterpreterDirective(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"InterpreterDirective\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDirective(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"Directive\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDirectiveLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DirectiveLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBlockStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"BlockStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBreakStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"BreakStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isCallExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"CallExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isCatchClause(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"CatchClause\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isConditionalExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ConditionalExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isContinueStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ContinueStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDebuggerStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DebuggerStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDoWhileStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DoWhileStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEmptyStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EmptyStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExpressionStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ExpressionStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFile(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"File\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isForInStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ForInStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isForStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ForStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"FunctionDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"FunctionExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"Identifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isIfStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"IfStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isLabeledStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"LabeledStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isStringLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"StringLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNumericLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"NumericLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNullLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"NullLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBooleanLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"BooleanLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isRegExpLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"RegExpLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isLogicalExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"LogicalExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isMemberExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"MemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNewExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"NewExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isProgram(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"Program\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ObjectExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ObjectMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ObjectProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isRestElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"RestElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isReturnStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ReturnStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSequenceExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"SequenceExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isParenthesizedExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ParenthesizedExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSwitchCase(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"SwitchCase\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSwitchStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"SwitchStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isThisExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ThisExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isThrowStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ThrowStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTryStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TryStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isUnaryExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"UnaryExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isUpdateExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"UpdateExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isVariableDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"VariableDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isVariableDeclarator(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"VariableDeclarator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isWhileStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"WhileStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isWithStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"WithStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isAssignmentPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"AssignmentPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isArrayPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ArrayPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isArrowFunctionExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ArrowFunctionExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ClassBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ClassExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ClassDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ExportAllDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportDefaultDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ExportDefaultDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportNamedDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ExportNamedDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ExportSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isForOfStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ForOfStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ImportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ImportDefaultSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ImportNamespaceSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImportSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ImportSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isMetaProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"MetaProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ClassMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ObjectPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSpreadElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"SpreadElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSuper(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"Super\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTaggedTemplateExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TaggedTemplateExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTemplateElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TemplateElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTemplateLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TemplateLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isYieldExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"YieldExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isAwaitExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"AwaitExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImport(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"Import\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBigIntLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"BigIntLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ExportNamespaceSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isOptionalMemberExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"OptionalMemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isOptionalCallExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"OptionalCallExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ClassProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassPrivateProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ClassPrivateProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassPrivateMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ClassPrivateMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPrivateName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"PrivateName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isAnyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"AnyTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isArrayTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ArrayTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBooleanTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"BooleanTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBooleanLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"BooleanLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNullLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"NullLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClassImplements(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ClassImplements\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareClass(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclareClass\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareInterface(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclareInterface\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareModule(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclareModule\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareModuleExports(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclareModuleExports\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareTypeAlias(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclareTypeAlias\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareOpaqueType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclareOpaqueType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareVariable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclareVariable\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareExportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclareExportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclareExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclareExportAllDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclaredPredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DeclaredPredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExistsTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ExistsTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"FunctionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionTypeParam(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"FunctionTypeParam\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isGenericTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"GenericTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isInferredPredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"InferredPredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isInterfaceExtends(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"InterfaceExtends\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"InterfaceDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isInterfaceTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"InterfaceTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isIntersectionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"IntersectionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isMixedTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"MixedTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEmptyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EmptyTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNullableTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"NullableTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNumberLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"NumberLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNumberTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"NumberTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ObjectTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeInternalSlot(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ObjectTypeInternalSlot\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeCallProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ObjectTypeCallProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeIndexer(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ObjectTypeIndexer\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ObjectTypeProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectTypeSpreadProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ObjectTypeSpreadProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isOpaqueType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"OpaqueType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isQualifiedTypeIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"QualifiedTypeIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isStringLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"StringLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isStringTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"StringTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSymbolTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"SymbolTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isThisTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ThisTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTupleTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TupleTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeofTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TypeofTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeAlias(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TypeAlias\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeCastExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TypeCastExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeParameter(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TypeParameter\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TypeParameterDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TypeParameterInstantiation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isUnionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"UnionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isVariance(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"Variance\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isVoidTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"VoidTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EnumDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumBooleanBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EnumBooleanBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumNumberBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EnumNumberBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumStringBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EnumStringBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumSymbolBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EnumSymbolBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumBooleanMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EnumBooleanMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumNumberMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EnumNumberMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumStringMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EnumStringMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumDefaultedMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"EnumDefaultedMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isIndexedAccessType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"IndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isOptionalIndexedAccessType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"OptionalIndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXAttribute(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXClosingElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXClosingElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXEmptyExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXEmptyExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXExpressionContainer(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXExpressionContainer\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXSpreadChild(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXSpreadChild\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXMemberExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXMemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXNamespacedName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXNamespacedName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXOpeningElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXOpeningElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXSpreadAttribute(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXSpreadAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXText(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXText\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXFragment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXOpeningFragment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXOpeningFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSXClosingFragment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"JSXClosingFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNoop(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"Noop\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPlaceholder(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"Placeholder\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isV8IntrinsicIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"V8IntrinsicIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isArgumentPlaceholder(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ArgumentPlaceholder\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBindExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"BindExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImportAttribute(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ImportAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDecorator(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"Decorator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDoExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DoExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ExportDefaultSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isRecordExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"RecordExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTupleExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TupleExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDecimalLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"DecimalLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isStaticBlock(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"StaticBlock\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isModuleExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"ModuleExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTopicReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TopicReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPipelineTopicExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"PipelineTopicExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPipelineBareFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"PipelineBareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPipelinePrimaryTopicReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"PipelinePrimaryTopicReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSParameterProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSParameterProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSDeclareFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSDeclareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSDeclareMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSDeclareMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSQualifiedName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSQualifiedName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSCallSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSCallSignatureDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSConstructSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSConstructSignatureDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSPropertySignature(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSPropertySignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSMethodSignature(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSMethodSignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSIndexSignature(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSIndexSignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSAnyKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSAnyKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSBooleanKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSBooleanKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSBigIntKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSBigIntKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSIntrinsicKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSIntrinsicKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNeverKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSNeverKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNullKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSNullKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNumberKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSNumberKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSObjectKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSObjectKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSStringKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSStringKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSSymbolKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSSymbolKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSUndefinedKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSUndefinedKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSUnknownKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSUnknownKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSVoidKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSVoidKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSThisType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSThisType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSFunctionType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSFunctionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSConstructorType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSConstructorType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypeReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypePredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypePredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeQuery(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypeQuery\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypeLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSArrayType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSArrayType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTupleType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTupleType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSOptionalType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSOptionalType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSRestType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSRestType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNamedTupleMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSNamedTupleMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSUnionType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSUnionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSIntersectionType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSIntersectionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSConditionalType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSConditionalType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSInferType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSInferType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSParenthesizedType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSParenthesizedType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeOperator(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypeOperator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSIndexedAccessType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSIndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSMappedType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSMappedType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSLiteralType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSLiteralType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSExpressionWithTypeArguments(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSExpressionWithTypeArguments\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSInterfaceDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSInterfaceBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSInterfaceBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeAliasDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypeAliasDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSAsExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSAsExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeAssertion(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypeAssertion\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSEnumDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSEnumDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSEnumMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSEnumMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSModuleDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSModuleDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSModuleBlock(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSModuleBlock\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSImportType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSImportType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSImportEqualsDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSImportEqualsDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSExternalModuleReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSExternalModuleReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNonNullExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSNonNullExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSExportAssignment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSExportAssignment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSNamespaceExportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSNamespaceExportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypeParameterInstantiation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypeParameterDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeParameter(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"TSTypeParameter\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ArrayExpression\" === nodeType || \"AssignmentExpression\" === nodeType || \"BinaryExpression\" === nodeType || \"CallExpression\" === nodeType || \"ConditionalExpression\" === nodeType || \"FunctionExpression\" === nodeType || \"Identifier\" === nodeType || \"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"RegExpLiteral\" === nodeType || \"LogicalExpression\" === nodeType || \"MemberExpression\" === nodeType || \"NewExpression\" === nodeType || \"ObjectExpression\" === nodeType || \"SequenceExpression\" === nodeType || \"ParenthesizedExpression\" === nodeType || \"ThisExpression\" === nodeType || \"UnaryExpression\" === nodeType || \"UpdateExpression\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassExpression\" === nodeType || \"MetaProperty\" === nodeType || \"Super\" === nodeType || \"TaggedTemplateExpression\" === nodeType || \"TemplateLiteral\" === nodeType || \"YieldExpression\" === nodeType || \"AwaitExpression\" === nodeType || \"Import\" === nodeType || \"BigIntLiteral\" === nodeType || \"OptionalMemberExpression\" === nodeType || \"OptionalCallExpression\" === nodeType || \"TypeCastExpression\" === nodeType || \"JSXElement\" === nodeType || \"JSXFragment\" === nodeType || \"BindExpression\" === nodeType || \"DoExpression\" === nodeType || \"RecordExpression\" === nodeType || \"TupleExpression\" === nodeType || \"DecimalLiteral\" === nodeType || \"ModuleExpression\" === nodeType || \"TopicReference\" === nodeType || \"PipelineTopicExpression\" === nodeType || \"PipelineBareFunction\" === nodeType || \"PipelinePrimaryTopicReference\" === nodeType || \"TSAsExpression\" === nodeType || \"TSTypeAssertion\" === nodeType || \"TSNonNullExpression\" === nodeType || nodeType === \"Placeholder\" && (\"Expression\" === node.expectedNode || \"Identifier\" === node.expectedNode || \"StringLiteral\" === node.expectedNode)) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBinary(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"BinaryExpression\" === nodeType || \"LogicalExpression\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isScopable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"BlockStatement\" === nodeType || \"CatchClause\" === nodeType || \"DoWhileStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"Program\" === nodeType || \"ObjectMethod\" === nodeType || \"SwitchStatement\" === nodeType || \"WhileStatement\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassExpression\" === nodeType || \"ClassDeclaration\" === nodeType || \"ForOfStatement\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"StaticBlock\" === nodeType || \"TSModuleBlock\" === nodeType || nodeType === \"Placeholder\" && \"BlockStatement\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBlockParent(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"BlockStatement\" === nodeType || \"CatchClause\" === nodeType || \"DoWhileStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"Program\" === nodeType || \"ObjectMethod\" === nodeType || \"SwitchStatement\" === nodeType || \"WhileStatement\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ForOfStatement\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"StaticBlock\" === nodeType || \"TSModuleBlock\" === nodeType || nodeType === \"Placeholder\" && \"BlockStatement\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isBlock(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"BlockStatement\" === nodeType || \"Program\" === nodeType || \"TSModuleBlock\" === nodeType || nodeType === \"Placeholder\" && \"BlockStatement\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"BlockStatement\" === nodeType || \"BreakStatement\" === nodeType || \"ContinueStatement\" === nodeType || \"DebuggerStatement\" === nodeType || \"DoWhileStatement\" === nodeType || \"EmptyStatement\" === nodeType || \"ExpressionStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"FunctionDeclaration\" === nodeType || \"IfStatement\" === nodeType || \"LabeledStatement\" === nodeType || \"ReturnStatement\" === nodeType || \"SwitchStatement\" === nodeType || \"ThrowStatement\" === nodeType || \"TryStatement\" === nodeType || \"VariableDeclaration\" === nodeType || \"WhileStatement\" === nodeType || \"WithStatement\" === nodeType || \"ClassDeclaration\" === nodeType || \"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType || \"ForOfStatement\" === nodeType || \"ImportDeclaration\" === nodeType || \"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"OpaqueType\" === nodeType || \"TypeAlias\" === nodeType || \"EnumDeclaration\" === nodeType || \"TSDeclareFunction\" === nodeType || \"TSInterfaceDeclaration\" === nodeType || \"TSTypeAliasDeclaration\" === nodeType || \"TSEnumDeclaration\" === nodeType || \"TSModuleDeclaration\" === nodeType || \"TSImportEqualsDeclaration\" === nodeType || \"TSExportAssignment\" === nodeType || \"TSNamespaceExportDeclaration\" === nodeType || nodeType === \"Placeholder\" && (\"Statement\" === node.expectedNode || \"Declaration\" === node.expectedNode || \"BlockStatement\" === node.expectedNode)) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTerminatorless(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"BreakStatement\" === nodeType || \"ContinueStatement\" === nodeType || \"ReturnStatement\" === nodeType || \"ThrowStatement\" === nodeType || \"YieldExpression\" === nodeType || \"AwaitExpression\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isCompletionStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"BreakStatement\" === nodeType || \"ContinueStatement\" === nodeType || \"ReturnStatement\" === nodeType || \"ThrowStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isConditional(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ConditionalExpression\" === nodeType || \"IfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isLoop(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"DoWhileStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"WhileStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isWhile(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"DoWhileStatement\" === nodeType || \"WhileStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExpressionWrapper(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ExpressionStatement\" === nodeType || \"ParenthesizedExpression\" === nodeType || \"TypeCastExpression\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFor(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isForXStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ForInStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"ObjectMethod\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionParent(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"ObjectMethod\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPureish(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"RegExpLiteral\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"BigIntLiteral\" === nodeType || \"DecimalLiteral\" === nodeType || nodeType === \"Placeholder\" && \"StringLiteral\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"FunctionDeclaration\" === nodeType || \"VariableDeclaration\" === nodeType || \"ClassDeclaration\" === nodeType || \"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType || \"ImportDeclaration\" === nodeType || \"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"OpaqueType\" === nodeType || \"TypeAlias\" === nodeType || \"EnumDeclaration\" === nodeType || \"TSDeclareFunction\" === nodeType || \"TSInterfaceDeclaration\" === nodeType || \"TSTypeAliasDeclaration\" === nodeType || \"TSEnumDeclaration\" === nodeType || \"TSModuleDeclaration\" === nodeType || nodeType === \"Placeholder\" && \"Declaration\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPatternLike(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"Identifier\" === nodeType || \"RestElement\" === nodeType || \"AssignmentPattern\" === nodeType || \"ArrayPattern\" === nodeType || \"ObjectPattern\" === nodeType || nodeType === \"Placeholder\" && (\"Pattern\" === node.expectedNode || \"Identifier\" === node.expectedNode)) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isLVal(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"Identifier\" === nodeType || \"MemberExpression\" === nodeType || \"RestElement\" === nodeType || \"AssignmentPattern\" === nodeType || \"ArrayPattern\" === nodeType || \"ObjectPattern\" === nodeType || \"TSParameterProperty\" === nodeType || nodeType === \"Placeholder\" && (\"Pattern\" === node.expectedNode || \"Identifier\" === node.expectedNode)) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSEntityName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"Identifier\" === nodeType || \"TSQualifiedName\" === nodeType || nodeType === \"Placeholder\" && \"Identifier\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"RegExpLiteral\" === nodeType || \"TemplateLiteral\" === nodeType || \"BigIntLiteral\" === nodeType || \"DecimalLiteral\" === nodeType || nodeType === \"Placeholder\" && \"StringLiteral\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isImmutable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"BigIntLiteral\" === nodeType || \"JSXAttribute\" === nodeType || \"JSXClosingElement\" === nodeType || \"JSXElement\" === nodeType || \"JSXExpressionContainer\" === nodeType || \"JSXSpreadChild\" === nodeType || \"JSXOpeningElement\" === nodeType || \"JSXText\" === nodeType || \"JSXFragment\" === nodeType || \"JSXOpeningFragment\" === nodeType || \"JSXClosingFragment\" === nodeType || \"DecimalLiteral\" === nodeType || nodeType === \"Placeholder\" && \"StringLiteral\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isUserWhitespacable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ObjectMethod\" === nodeType || \"ObjectProperty\" === nodeType || \"ObjectTypeInternalSlot\" === nodeType || \"ObjectTypeCallProperty\" === nodeType || \"ObjectTypeIndexer\" === nodeType || \"ObjectTypeProperty\" === nodeType || \"ObjectTypeSpreadProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ObjectMethod\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isObjectMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ObjectMethod\" === nodeType || \"ObjectProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ObjectProperty\" === nodeType || \"ClassProperty\" === nodeType || \"ClassPrivateProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isUnaryLike(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"UnaryExpression\" === nodeType || \"SpreadElement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"AssignmentPattern\" === nodeType || \"ArrayPattern\" === nodeType || \"ObjectPattern\" === nodeType || nodeType === \"Placeholder\" && \"Pattern\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isClass(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ClassExpression\" === nodeType || \"ClassDeclaration\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isModuleDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType || \"ImportDeclaration\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isExportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isModuleSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ExportSpecifier\" === nodeType || \"ImportDefaultSpecifier\" === nodeType || \"ImportNamespaceSpecifier\" === nodeType || \"ImportSpecifier\" === nodeType || \"ExportNamespaceSpecifier\" === nodeType || \"ExportDefaultSpecifier\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isPrivate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"ClassPrivateProperty\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"PrivateName\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFlow(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"AnyTypeAnnotation\" === nodeType || \"ArrayTypeAnnotation\" === nodeType || \"BooleanTypeAnnotation\" === nodeType || \"BooleanLiteralTypeAnnotation\" === nodeType || \"NullLiteralTypeAnnotation\" === nodeType || \"ClassImplements\" === nodeType || \"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"DeclaredPredicate\" === nodeType || \"ExistsTypeAnnotation\" === nodeType || \"FunctionTypeAnnotation\" === nodeType || \"FunctionTypeParam\" === nodeType || \"GenericTypeAnnotation\" === nodeType || \"InferredPredicate\" === nodeType || \"InterfaceExtends\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"InterfaceTypeAnnotation\" === nodeType || \"IntersectionTypeAnnotation\" === nodeType || \"MixedTypeAnnotation\" === nodeType || \"EmptyTypeAnnotation\" === nodeType || \"NullableTypeAnnotation\" === nodeType || \"NumberLiteralTypeAnnotation\" === nodeType || \"NumberTypeAnnotation\" === nodeType || \"ObjectTypeAnnotation\" === nodeType || \"ObjectTypeInternalSlot\" === nodeType || \"ObjectTypeCallProperty\" === nodeType || \"ObjectTypeIndexer\" === nodeType || \"ObjectTypeProperty\" === nodeType || \"ObjectTypeSpreadProperty\" === nodeType || \"OpaqueType\" === nodeType || \"QualifiedTypeIdentifier\" === nodeType || \"StringLiteralTypeAnnotation\" === nodeType || \"StringTypeAnnotation\" === nodeType || \"SymbolTypeAnnotation\" === nodeType || \"ThisTypeAnnotation\" === nodeType || \"TupleTypeAnnotation\" === nodeType || \"TypeofTypeAnnotation\" === nodeType || \"TypeAlias\" === nodeType || \"TypeAnnotation\" === nodeType || \"TypeCastExpression\" === nodeType || \"TypeParameter\" === nodeType || \"TypeParameterDeclaration\" === nodeType || \"TypeParameterInstantiation\" === nodeType || \"UnionTypeAnnotation\" === nodeType || \"Variance\" === nodeType || \"VoidTypeAnnotation\" === nodeType || \"IndexedAccessType\" === nodeType || \"OptionalIndexedAccessType\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFlowType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"AnyTypeAnnotation\" === nodeType || \"ArrayTypeAnnotation\" === nodeType || \"BooleanTypeAnnotation\" === nodeType || \"BooleanLiteralTypeAnnotation\" === nodeType || \"NullLiteralTypeAnnotation\" === nodeType || \"ExistsTypeAnnotation\" === nodeType || \"FunctionTypeAnnotation\" === nodeType || \"GenericTypeAnnotation\" === nodeType || \"InterfaceTypeAnnotation\" === nodeType || \"IntersectionTypeAnnotation\" === nodeType || \"MixedTypeAnnotation\" === nodeType || \"EmptyTypeAnnotation\" === nodeType || \"NullableTypeAnnotation\" === nodeType || \"NumberLiteralTypeAnnotation\" === nodeType || \"NumberTypeAnnotation\" === nodeType || \"ObjectTypeAnnotation\" === nodeType || \"StringLiteralTypeAnnotation\" === nodeType || \"StringTypeAnnotation\" === nodeType || \"SymbolTypeAnnotation\" === nodeType || \"ThisTypeAnnotation\" === nodeType || \"TupleTypeAnnotation\" === nodeType || \"TypeofTypeAnnotation\" === nodeType || \"UnionTypeAnnotation\" === nodeType || \"VoidTypeAnnotation\" === nodeType || \"IndexedAccessType\" === nodeType || \"OptionalIndexedAccessType\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFlowBaseAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"AnyTypeAnnotation\" === nodeType || \"BooleanTypeAnnotation\" === nodeType || \"NullLiteralTypeAnnotation\" === nodeType || \"MixedTypeAnnotation\" === nodeType || \"EmptyTypeAnnotation\" === nodeType || \"NumberTypeAnnotation\" === nodeType || \"StringTypeAnnotation\" === nodeType || \"SymbolTypeAnnotation\" === nodeType || \"ThisTypeAnnotation\" === nodeType || \"VoidTypeAnnotation\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFlowDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"OpaqueType\" === nodeType || \"TypeAlias\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isFlowPredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"DeclaredPredicate\" === nodeType || \"InferredPredicate\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"EnumBooleanBody\" === nodeType || \"EnumNumberBody\" === nodeType || \"EnumStringBody\" === nodeType || \"EnumSymbolBody\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isEnumMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"EnumBooleanMember\" === nodeType || \"EnumNumberMember\" === nodeType || \"EnumStringMember\" === nodeType || \"EnumDefaultedMember\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isJSX(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"JSXAttribute\" === nodeType || \"JSXClosingElement\" === nodeType || \"JSXElement\" === nodeType || \"JSXEmptyExpression\" === nodeType || \"JSXExpressionContainer\" === nodeType || \"JSXSpreadChild\" === nodeType || \"JSXIdentifier\" === nodeType || \"JSXMemberExpression\" === nodeType || \"JSXNamespacedName\" === nodeType || \"JSXOpeningElement\" === nodeType || \"JSXSpreadAttribute\" === nodeType || \"JSXText\" === nodeType || \"JSXFragment\" === nodeType || \"JSXOpeningFragment\" === nodeType || \"JSXClosingFragment\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSTypeElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"TSCallSignatureDeclaration\" === nodeType || \"TSConstructSignatureDeclaration\" === nodeType || \"TSPropertySignature\" === nodeType || \"TSMethodSignature\" === nodeType || \"TSIndexSignature\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"TSAnyKeyword\" === nodeType || \"TSBooleanKeyword\" === nodeType || \"TSBigIntKeyword\" === nodeType || \"TSIntrinsicKeyword\" === nodeType || \"TSNeverKeyword\" === nodeType || \"TSNullKeyword\" === nodeType || \"TSNumberKeyword\" === nodeType || \"TSObjectKeyword\" === nodeType || \"TSStringKeyword\" === nodeType || \"TSSymbolKeyword\" === nodeType || \"TSUndefinedKeyword\" === nodeType || \"TSUnknownKeyword\" === nodeType || \"TSVoidKeyword\" === nodeType || \"TSThisType\" === nodeType || \"TSFunctionType\" === nodeType || \"TSConstructorType\" === nodeType || \"TSTypeReference\" === nodeType || \"TSTypePredicate\" === nodeType || \"TSTypeQuery\" === nodeType || \"TSTypeLiteral\" === nodeType || \"TSArrayType\" === nodeType || \"TSTupleType\" === nodeType || \"TSOptionalType\" === nodeType || \"TSRestType\" === nodeType || \"TSUnionType\" === nodeType || \"TSIntersectionType\" === nodeType || \"TSConditionalType\" === nodeType || \"TSInferType\" === nodeType || \"TSParenthesizedType\" === nodeType || \"TSTypeOperator\" === nodeType || \"TSIndexedAccessType\" === nodeType || \"TSMappedType\" === nodeType || \"TSLiteralType\" === nodeType || \"TSExpressionWithTypeArguments\" === nodeType || \"TSImportType\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isTSBaseType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (\"TSAnyKeyword\" === nodeType || \"TSBooleanKeyword\" === nodeType || \"TSBigIntKeyword\" === nodeType || \"TSIntrinsicKeyword\" === nodeType || \"TSNeverKeyword\" === nodeType || \"TSNullKeyword\" === nodeType || \"TSNumberKeyword\" === nodeType || \"TSObjectKeyword\" === nodeType || \"TSStringKeyword\" === nodeType || \"TSSymbolKeyword\" === nodeType || \"TSUndefinedKeyword\" === nodeType || \"TSUnknownKeyword\" === nodeType || \"TSVoidKeyword\" === nodeType || \"TSThisType\" === nodeType || \"TSLiteralType\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isNumberLiteral(node, opts) {\n  console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"NumberLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isRegexLiteral(node, opts) {\n  console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"RegexLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isRestProperty(node, opts) {\n  console.trace(\"The node type RestProperty has been renamed to RestElement\");\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"RestProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n\nfunction isSpreadProperty(node, opts) {\n  console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"SpreadProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = is;\n\nvar _shallowEqual = require(\"../utils/shallowEqual\");\n\nvar _isType = require(\"./isType\");\n\nvar _isPlaceholderType = require(\"./isPlaceholderType\");\n\nvar _definitions = require(\"../definitions\");\n\nfunction is(type, node, opts) {\n  if (!node) return false;\n  const matches = (0, _isType.default)(node.type, type);\n\n  if (!matches) {\n    if (!opts && node.type === \"Placeholder\" && type in _definitions.FLIPPED_ALIAS_KEYS) {\n      return (0, _isPlaceholderType.default)(node.expectedNode, type);\n    }\n\n    return false;\n  }\n\n  if (typeof opts === \"undefined\") {\n    return true;\n  } else {\n    return (0, _shallowEqual.default)(node, opts);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBinding;\n\nvar _getBindingIdentifiers = require(\"../retrievers/getBindingIdentifiers\");\n\nfunction isBinding(node, parent, grandparent) {\n  if (grandparent && node.type === \"Identifier\" && parent.type === \"ObjectProperty\" && grandparent.type === \"ObjectExpression\") {\n    return false;\n  }\n\n  const keys = _getBindingIdentifiers.default.keys[parent.type];\n\n  if (keys) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val = parent[key];\n\n      if (Array.isArray(val)) {\n        if (val.indexOf(node) >= 0) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBlockScoped;\n\nvar _generated = require(\"./generated\");\n\nvar _isLet = require(\"./isLet\");\n\nfunction isBlockScoped(node) {\n  return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isImmutable;\n\nvar _isType = require(\"./isType\");\n\nvar _generated = require(\"./generated\");\n\nfunction isImmutable(node) {\n  if ((0, _isType.default)(node.type, \"Immutable\")) return true;\n\n  if ((0, _generated.isIdentifier)(node)) {\n    if (node.name === \"undefined\") {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isLet;\n\nvar _generated = require(\"./generated\");\n\nvar _constants = require(\"../constants\");\n\nfunction isLet(node) {\n  return (0, _generated.isVariableDeclaration)(node) && (node.kind !== \"var\" || node[_constants.BLOCK_SCOPED_SYMBOL]);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isNode;\n\nvar _definitions = require(\"../definitions\");\n\nfunction isNode(node) {\n  return !!(node && _definitions.VISITOR_KEYS[node.type]);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isNodesEquivalent;\n\nvar _definitions = require(\"../definitions\");\n\nfunction isNodesEquivalent(a, b) {\n  if (typeof a !== \"object\" || typeof b !== \"object\" || a == null || b == null) {\n    return a === b;\n  }\n\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);\n  const visitorKeys = _definitions.VISITOR_KEYS[a.type];\n\n  for (const field of fields) {\n    if (typeof a[field] !== typeof b[field]) {\n      return false;\n    }\n\n    if (a[field] == null && b[field] == null) {\n      continue;\n    } else if (a[field] == null || b[field] == null) {\n      return false;\n    }\n\n    if (Array.isArray(a[field])) {\n      if (!Array.isArray(b[field])) {\n        return false;\n      }\n\n      if (a[field].length !== b[field].length) {\n        return false;\n      }\n\n      for (let i = 0; i < a[field].length; i++) {\n        if (!isNodesEquivalent(a[field][i], b[field][i])) {\n          return false;\n        }\n      }\n\n      continue;\n    }\n\n    if (typeof a[field] === \"object\" && !(visitorKeys != null && visitorKeys.includes(field))) {\n      for (const key of Object.keys(a[field])) {\n        if (a[field][key] !== b[field][key]) {\n          return false;\n        }\n      }\n\n      continue;\n    }\n\n    if (!isNodesEquivalent(a[field], b[field])) {\n      return false;\n    }\n  }\n\n  return true;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isPlaceholderType;\n\nvar _definitions = require(\"../definitions\");\n\nfunction isPlaceholderType(placeholderType, targetType) {\n  if (placeholderType === targetType) return true;\n  const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];\n\n  if (aliases) {\n    for (const alias of aliases) {\n      if (targetType === alias) return true;\n    }\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isReferenced;\n\nfunction isReferenced(node, parent, grandparent) {\n  switch (parent.type) {\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n      if (parent.property === node) {\n        return !!parent.computed;\n      }\n\n      return parent.object === node;\n\n    case \"JSXMemberExpression\":\n      return parent.object === node;\n\n    case \"VariableDeclarator\":\n      return parent.init === node;\n\n    case \"ArrowFunctionExpression\":\n      return parent.body === node;\n\n    case \"PrivateName\":\n      return false;\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"ObjectMethod\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n\n      return false;\n\n    case \"ObjectProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n\n      return !grandparent || grandparent.type !== \"ObjectPattern\";\n\n    case \"ClassProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n\n      return true;\n\n    case \"ClassPrivateProperty\":\n      return parent.key !== node;\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.superClass === node;\n\n    case \"AssignmentExpression\":\n      return parent.right === node;\n\n    case \"AssignmentPattern\":\n      return parent.right === node;\n\n    case \"LabeledStatement\":\n      return false;\n\n    case \"CatchClause\":\n      return false;\n\n    case \"RestElement\":\n      return false;\n\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n      return false;\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      return false;\n\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return false;\n\n    case \"ExportSpecifier\":\n      if (grandparent != null && grandparent.source) {\n        return false;\n      }\n\n      return parent.local === node;\n\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n\n    case \"ImportAttribute\":\n      return false;\n\n    case \"JSXAttribute\":\n      return false;\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n\n    case \"MetaProperty\":\n      return false;\n\n    case \"ObjectTypeProperty\":\n      return parent.key !== node;\n\n    case \"TSEnumMember\":\n      return parent.id !== node;\n\n    case \"TSPropertySignature\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n\n      return true;\n  }\n\n  return true;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isScope;\n\nvar _generated = require(\"./generated\");\n\nfunction isScope(node, parent) {\n  if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {\n    return false;\n  }\n\n  if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) {\n    return true;\n  }\n\n  return (0, _generated.isScopable)(node);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isSpecifierDefault;\n\nvar _generated = require(\"./generated\");\n\nfunction isSpecifierDefault(specifier) {\n  return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {\n    name: \"default\"\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isType;\n\nvar _definitions = require(\"../definitions\");\n\nfunction isType(nodeType, targetType) {\n  if (nodeType === targetType) return true;\n  if (_definitions.ALIAS_KEYS[targetType]) return false;\n  const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];\n\n  if (aliases) {\n    if (aliases[0] === nodeType) return true;\n\n    for (const alias of aliases) {\n      if (nodeType === alias) return true;\n    }\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isValidES3Identifier;\n\nvar _isValidIdentifier = require(\"./isValidIdentifier\");\n\nconst RESERVED_WORDS_ES3_ONLY = new Set([\"abstract\", \"boolean\", \"byte\", \"char\", \"double\", \"enum\", \"final\", \"float\", \"goto\", \"implements\", \"int\", \"interface\", \"long\", \"native\", \"package\", \"private\", \"protected\", \"public\", \"short\", \"static\", \"synchronized\", \"throws\", \"transient\", \"volatile\"]);\n\nfunction isValidES3Identifier(name) {\n  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isValidIdentifier;\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nfunction isValidIdentifier(name, reserved = true) {\n  if (typeof name !== \"string\") return false;\n\n  if (reserved) {\n    if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {\n      return false;\n    }\n  }\n\n  return (0, _helperValidatorIdentifier.isIdentifierName)(name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isVar;\n\nvar _generated = require(\"./generated\");\n\nvar _constants = require(\"../constants\");\n\nfunction isVar(node) {\n  return (0, _generated.isVariableDeclaration)(node, {\n    kind: \"var\"\n  }) && !node[_constants.BLOCK_SCOPED_SYMBOL];\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = matchesPattern;\n\nvar _generated = require(\"./generated\");\n\nfunction matchesPattern(member, match, allowPartial) {\n  if (!(0, _generated.isMemberExpression)(member)) return false;\n  const parts = Array.isArray(match) ? match : match.split(\".\");\n  const nodes = [];\n  let node;\n\n  for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {\n    nodes.push(node.property);\n  }\n\n  nodes.push(node);\n  if (nodes.length < parts.length) return false;\n  if (!allowPartial && nodes.length > parts.length) return false;\n\n  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {\n    const node = nodes[j];\n    let value;\n\n    if ((0, _generated.isIdentifier)(node)) {\n      value = node.name;\n    } else if ((0, _generated.isStringLiteral)(node)) {\n      value = node.value;\n    } else if ((0, _generated.isThisExpression)(node)) {\n      value = \"this\";\n    } else {\n      return false;\n    }\n\n    if (parts[i] !== value) return false;\n  }\n\n  return true;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isCompatTag;\n\nfunction isCompatTag(tagName) {\n  return !!tagName && /^[a-z]/.test(tagName);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buildMatchMemberExpression = require(\"../buildMatchMemberExpression\");\n\nconst isReactComponent = (0, _buildMatchMemberExpression.default)(\"React.Component\");\nvar _default = isReactComponent;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = validate;\nexports.validateField = validateField;\nexports.validateChild = validateChild;\n\nvar _definitions = require(\"../definitions\");\n\nfunction validate(node, key, val) {\n  if (!node) return;\n  const fields = _definitions.NODE_FIELDS[node.type];\n  if (!fields) return;\n  const field = fields[key];\n  validateField(node, key, val, field);\n  validateChild(node, key, val);\n}\n\nfunction validateField(node, key, val, field) {\n  if (!(field != null && field.validate)) return;\n  if (field.optional && val == null) return;\n  field.validate(node, key, val);\n}\n\nfunction validateChild(node, key, val) {\n  if (val == null) return;\n  const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];\n  if (!validate) return;\n  validate(node, key, val);\n}","'use strict';\n\nlet fastProto = null;\n\n// Creates an object with permanently fast properties in V8. See Toon Verwaest's\n// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62\n// for more details. Use %HasFastProperties(object) and the Node.js flag\n// --allow-natives-syntax to check whether an object has fast properties.\nfunction FastObject(o) {\n\t// A prototype object will have \"fast properties\" enabled once it is checked\n\t// against the inline property cache of a function, e.g. fastProto.property:\n\t// https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63\n\tif (fastProto !== null && typeof fastProto.property) {\n\t\tconst result = fastProto;\n\t\tfastProto = FastObject.prototype = null;\n\t\treturn result;\n\t}\n\tfastProto = FastObject.prototype = o == null ? Object.create(null) : o;\n\treturn new FastObject;\n}\n\n// Initialize the inline property cache of FastObject\nFastObject();\n\nmodule.exports = function toFastproperties(o) {\n\treturn FastObject(o);\n};\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst t = __importStar(require(\"@babel/types\"));\nif (!(Array.isArray(t.TYPES) &&\n    t.TYPES.every((t) => typeof t === 'string'))) {\n    throw new Error('@babel/types TYPES does not match the expected type.');\n}\nconst FLIPPED_ALIAS_KEYS = t\n    .FLIPPED_ALIAS_KEYS;\nconst TYPES = new Set(t.TYPES);\nif (!(FLIPPED_ALIAS_KEYS &&\n    // tslint:disable-next-line: strict-type-predicates\n    typeof FLIPPED_ALIAS_KEYS === 'object' &&\n    Object.keys(FLIPPED_ALIAS_KEYS).every((key) => Array.isArray(FLIPPED_ALIAS_KEYS[key]) &&\n        // tslint:disable-next-line: strict-type-predicates\n        FLIPPED_ALIAS_KEYS[key].every((v) => typeof v === 'string')))) {\n    throw new Error('@babel/types FLIPPED_ALIAS_KEYS does not match the expected type.');\n}\n/**\n * This serves thre functions:\n *\n * 1. Take any \"aliases\" and explode them to refecence the concrete types\n * 2. Normalize all handlers to have an `{enter, exit}` pair, rather than raw functions\n * 3. make the enter and exit handlers arrays, so that multiple handlers can be merged\n */\nfunction explode(input) {\n    const results = {};\n    for (const key in input) {\n        const aliases = FLIPPED_ALIAS_KEYS[key];\n        if (aliases) {\n            for (const concreteKey of aliases) {\n                if (concreteKey in results) {\n                    if (typeof input[key] === 'function') {\n                        results[concreteKey].enter.push(input[key]);\n                    }\n                    else {\n                        if (input[key].enter)\n                            results[concreteKey].enter.push(input[key].enter);\n                        if (input[key].exit)\n                            results[concreteKey].exit.push(input[key].exit);\n                    }\n                }\n                else {\n                    if (typeof input[key] === 'function') {\n                        results[concreteKey] = {\n                            enter: [input[key]],\n                            exit: [],\n                        };\n                    }\n                    else {\n                        results[concreteKey] = {\n                            enter: input[key].enter ? [input[key].enter] : [],\n                            exit: input[key].exit ? [input[key].exit] : [],\n                        };\n                    }\n                }\n            }\n        }\n        else if (TYPES.has(key)) {\n            if (key in results) {\n                if (typeof input[key] === 'function') {\n                    results[key].enter.push(input[key]);\n                }\n                else {\n                    if (input[key].enter)\n                        results[key].enter.push(input[key].enter);\n                    if (input[key].exit)\n                        results[key].exit.push(input[key].exit);\n                }\n            }\n            else {\n                if (typeof input[key] === 'function') {\n                    results[key] = {\n                        enter: [input[key]],\n                        exit: [],\n                    };\n                }\n                else {\n                    results[key] = {\n                        enter: input[key].enter ? [input[key].enter] : [],\n                        exit: input[key].exit ? [input[key].exit] : [],\n                    };\n                }\n            }\n        }\n    }\n    return results;\n}\nexports.default = explode;\n//# sourceMappingURL=explode.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.recursive = exports.ancestor = exports.simple = void 0;\nconst t = __importStar(require(\"@babel/types\"));\nconst explode_1 = __importDefault(require(\"./explode\"));\nconst VISITOR_KEYS = t.VISITOR_KEYS;\nif (!(VISITOR_KEYS &&\n    // tslint:disable-next-line: strict-type-predicates\n    typeof VISITOR_KEYS === 'object' &&\n    Object.keys(VISITOR_KEYS).every((key) => Array.isArray(VISITOR_KEYS[key]) &&\n        // tslint:disable-next-line: strict-type-predicates\n        VISITOR_KEYS[key].every((v) => typeof v === 'string')))) {\n    throw new Error('@babel/types VISITOR_KEYS does not match the expected type.');\n}\nfunction simple(visitors) {\n    const vis = explode_1.default(visitors);\n    return (node, state) => {\n        (function recurse(node) {\n            if (!node)\n                return;\n            const visitor = vis[node.type];\n            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {\n                for (const v of visitor.enter) {\n                    v(node, state);\n                }\n            }\n            for (const key of VISITOR_KEYS[node.type] || []) {\n                const subNode = node[key];\n                if (Array.isArray(subNode)) {\n                    for (const subSubNode of subNode) {\n                        recurse(subSubNode);\n                    }\n                }\n                else {\n                    recurse(subNode);\n                }\n            }\n            if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) {\n                for (const v of visitor.exit) {\n                    v(node, state);\n                }\n            }\n        })(node);\n    };\n}\nexports.simple = simple;\nfunction ancestor(visitors) {\n    const vis = explode_1.default(visitors);\n    return (node, state) => {\n        const ancestors = [];\n        (function recurse(node) {\n            if (!node)\n                return;\n            const visitor = vis[node.type];\n            const isNew = node !== ancestors[ancestors.length - 1];\n            if (isNew)\n                ancestors.push(node);\n            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {\n                for (const v of visitor.enter) {\n                    v(node, state, ancestors);\n                }\n            }\n            for (const key of VISITOR_KEYS[node.type] || []) {\n                const subNode = node[key];\n                if (Array.isArray(subNode)) {\n                    for (const subSubNode of subNode) {\n                        recurse(subSubNode);\n                    }\n                }\n                else {\n                    recurse(subNode);\n                }\n            }\n            if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) {\n                for (const v of visitor.exit) {\n                    v(node, state, ancestors);\n                }\n            }\n            if (isNew)\n                ancestors.pop();\n        })(node);\n    };\n}\nexports.ancestor = ancestor;\nfunction recursive(visitors) {\n    const vis = explode_1.default(visitors);\n    return (node, state) => {\n        (function recurse(node) {\n            if (!node)\n                return;\n            const visitor = vis[node.type];\n            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {\n                for (const v of visitor.enter) {\n                    v(node, state, recurse);\n                }\n            }\n            else {\n                for (const key of VISITOR_KEYS[node.type] || []) {\n                    const subNode = node[key];\n                    if (Array.isArray(subNode)) {\n                        for (const subSubNode of subNode) {\n                            recurse(subSubNode);\n                        }\n                    }\n                    else {\n                        recurse(subNode);\n                    }\n                }\n            }\n        })(node);\n    };\n}\nexports.recursive = recursive;\n//# sourceMappingURL=index.js.map","/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\r\n\r\n/** This file is dynamically loaded so the initial bundle can be smaller */\r\n\r\nimport { parse } from \"@babel/parser\";\r\nimport { simple } from \"babel-walk\";\r\n\r\n/**\r\n * Precompile takes a cell's code as a string, parses it and transforms it.\r\n * In particular it wraps everything in an async function, handles the var->global magic,\r\n * and its output can be used to set $_ to the last statement.\r\n */\r\nexport async function precompileJavascriptCode(content: string): Promise<string> {\r\n  let wrapped = \"(async () => {\" + content + \"\\n})()\";\r\n  const root = parse(wrapped, { ecmaVersion: 8 } as any);\r\n  const body = (root.program.body[0] as any).expression.callee.body;\r\n\r\n  const isTopLevel = (node: any) => {\r\n    return (body.body as Array<any>).indexOf(node) !== -1;\r\n  };\r\n\r\n  const changes: any[] = [];\r\n\r\n  const visitors = {\r\n    ClassDeclaration(node: any) {\r\n      if (isTopLevel(node)) {\r\n        changes.push({\r\n          text: node.id.name + \"=\",\r\n          start: node.start,\r\n          end: node.start,\r\n        });\r\n      }\r\n    },\r\n    FunctionDeclaration(node: any) {\r\n      changes.push({\r\n        text: node.id.name + \"=\",\r\n        start: node.start,\r\n        end: node.start,\r\n      });\r\n      return node;\r\n    },\r\n    VariableDeclaration(node: any) {\r\n      if (node.kind !== \"var\" || !isTopLevel(node)) return;\r\n      const onlyOneDeclaration = node.declarations.length === 1;\r\n      changes.push({\r\n        text: onlyOneDeclaration ? \"void\" : \"void (\",\r\n        start: node.start,\r\n        end: node.start + node.kind.length,\r\n      });\r\n      for (const declaration of node.declarations) {\r\n        if (!declaration.init) {\r\n          changes.push({\r\n            text: \"(\",\r\n            start: declaration.start,\r\n            end: declaration.start,\r\n          });\r\n          changes.push({\r\n            text: \"=undefined)\",\r\n            start: declaration.end,\r\n            end: declaration.end,\r\n          });\r\n          continue;\r\n        }\r\n        changes.push({\r\n          text: \"(\",\r\n          start: declaration.start,\r\n          end: declaration.start,\r\n        });\r\n        changes.push({\r\n          text: \")\",\r\n          start: declaration.end,\r\n          end: declaration.end,\r\n        });\r\n      }\r\n      if (!onlyOneDeclaration) {\r\n        const last = node.declarations[node.declarations.length - 1];\r\n        changes.push({ text: \")\", start: last.end, end: last.end });\r\n      }\r\n    },\r\n  };\r\n\r\n  const walk = simple(visitors);\r\n  walk(root, undefined);\r\n\r\n  const last = body.body[body.body.length - 1];\r\n  if (last === undefined) {\r\n    return content;\r\n  }\r\n\r\n  if (last.type === \"ExpressionStatement\" && !content.match(/;\\s*$/)) {\r\n    changes.push({\r\n      text: \"return {returnValue: (\",\r\n      start: last.start,\r\n      end: last.start,\r\n    });\r\n    if (wrapped[last.end - 1] !== \";\") {\r\n      changes.push({ text: \")}\", start: last.end, end: last.end });\r\n    } else changes.push({ text: \")}\", start: last.end - 1, end: last.end - 1 });\r\n\r\n    // We need to offset changes in the final expression with 22, the length of\r\n    // `return {returnValue: (`\r\n    changes.forEach((change, i) => {\r\n      if (i >= changes.length - 2) return;\r\n      if (change.start >= last.start && change.start < last.end) {\r\n        change.start += 22;\r\n        change.end += 22;\r\n      }\r\n    });\r\n  }\r\n\r\n  while (changes.length) {\r\n    const change = changes.pop() as any;\r\n    wrapped = wrapped.substr(0, change.start) + change.text + wrapped.substr(change.end);\r\n  }\r\n\r\n  // console.log(\"Cell code\\n\", wrapped);\r\n  return wrapped;\r\n}\r\n"],"sourceRoot":""}