var css = "@font-face{font-family:PyodideIcons;src:url(\"data:application/x-font-ttf;charset=utf-8;base64,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\") format('truetype');font-weight:400;font-style:normal;font-display:block}.fa{font-family:PyodideIcons;font-style:normal;font-weight:400;font-variant:normal;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-search-plus:before{content:\"\\f00e\"}.fa-home:before{content:\"\\f015\"}.fa-download:before{content:\"\\f019\"}.fa-arrows:before{content:\"\\f047\"}.fa-arrow-left:before{content:\"\\f060\"}.fa-arrow-right:before{content:\"\\f061\"}.rendered_html{overflow:auto;max-height:30em;color:#000}.rendered_html em{font-style:italic}.rendered_html strong{font-weight:700}.rendered_html :link,.rendered_html :visited,.rendered_html u{text-decoration:underline}.rendered_html h1{font-size:185.7%;margin:1.08em 0 0;font-weight:700;line-height:1}.rendered_html h2{font-size:157.1%;margin:1.27em 0 0;font-weight:700;line-height:1}.rendered_html h3{font-size:128.6%;margin:1.55em 0 0;font-weight:700;line-height:1}.rendered_html h4{font-size:100%;margin:2em 0 0;font-weight:700;line-height:1}.rendered_html h5,.rendered_html h6{font-size:100%;margin:2em 0 0;font-weight:700;line-height:1;font-style:italic}.rendered_html h1:first-child{margin-top:.538em}.rendered_html h2:first-child{margin-top:.636em}.rendered_html h3:first-child{margin-top:.777em}.rendered_html h4:first-child,.rendered_html h5:first-child,.rendered_html h6:first-child{margin-top:1em}.rendered_html ol:not(.list-inline),.rendered_html ul:not(.list-inline){padding-left:2em}.rendered_html ul{list-style:disc}.rendered_html ul ul{list-style:square;margin-top:0}.rendered_html ul ul ul{list-style:circle}.rendered_html ol{list-style:decimal}.rendered_html ol ol{list-style:upper-alpha;margin-top:0}.rendered_html ol ol ol{list-style:lower-alpha}.rendered_html ol ol ol ol{list-style:lower-roman}.rendered_html ol ol ol ol ol{list-style:decimal}.rendered_html *+ol,.rendered_html *+ul{margin-top:1em}.rendered_html hr{color:#000;background-color:#000}.rendered_html pre{margin:1em 2em;padding:0;background-color:#fff}.rendered_html code{background-color:#eff0f1}.rendered_html p code{padding:1px 5px}.rendered_html pre code{background-color:#fff}.rendered_html code,.rendered_html pre{border:0;color:#000;font-size:100%}.rendered_html blockquote{margin:1em 2em}.rendered_html table{margin-left:auto;margin-right:auto;border:none;border-collapse:collapse;border-spacing:0;color:#000;font-size:12px;table-layout:fixed}.rendered_html thead{border-bottom:1px solid #000;vertical-align:bottom}.rendered_html td,.rendered_html th,.rendered_html tr{text-align:right;vertical-align:middle;padding:.5em;line-height:normal;white-space:normal;max-width:none;border:none}.rendered_html th{font-weight:700}.rendered_html tbody tr:nth-child(odd){background:#f5f5f5}.rendered_html tbody tr:hover{background:rgba(66,165,245,.2)}.rendered_html *+table{margin-top:1em}.rendered_html p{text-align:left}.rendered_html *+p{margin-top:1em}.rendered_html img{display:block;margin-left:auto;margin-right:auto}.rendered_html *+img{margin-top:1em}.rendered_html img,.rendered_html svg{max-width:100%;height:auto}.rendered_html img.unconfined,.rendered_html svg.unconfined{max-width:none}.rendered_html .alert{margin-bottom:initial}.rendered_html *+.alert{margin-top:1em}[dir=rtl] .rendered_html p{text-align:right}";

// Global singleton
let pluginOpts = {};
function getPluginOpts() {
    return pluginOpts;
}
function setPluginOpts(opts) {
    pluginOpts = opts;
}
/**
 * Overwrite present options
 */
function updatePluginOptions(opts) {
    pluginOpts = {
        ...pluginOpts,
        ...opts,
    };
}

// This file replaces `index.js` in bundlers like webpack or Rollup,

let nanoid = (size = 21) => {
  let id = '';
  let bytes = crypto.getRandomValues(new Uint8Array(size));

  // A compact alternative for `for (var i = 0; i < step; i++)`.
  while (size--) {
    // It is incorrect to use bytes exceeding the alphabet size.
    // The following mask reduces the random byte in the 0-255 value
    // range to the 0-63 value range. Therefore, adding hacks, such
    // as empty string fallback or magic numbers, is unneccessary because
    // the bitmask trims bytes down to the alphabet size.
    let byte = bytes[size] & 63;
    if (byte < 36) {
      // `0-9a-z`
      id += byte.toString(36);
    } else if (byte < 62) {
      // `A-Z`
      id += (byte - 26).toString(36).toUpperCase();
    } else if (byte < 63) {
      id += '_';
    } else {
      id += '-';
    }
  }
  return id
};

function assertUnreachable(_x) {
    throw new Error("This case should have never been reached");
}

/**
 * One-way memory, can block a web worker until data from the main thread arrives.
 *
 * Web Worker Usage:
 * 1. Lock "web worker"
 * 2. Set "shared memory signal"
 * 3. Notify main thread (Main thread does stuff)
 * 4. Wait for "shared memory signal"
 * 5. Read size buffer
 * 6. Read shared memory
 * 7. If the size buffer was bigger than the read memory size
 * 7.1. Set "shared memory signal"
 * 7.2. Notify main thread (Main thread writes remaining data to shared memory)
 * 7.3. Wait for "shared memory signal"
 * 7.4. Read shared memory
 * 7.5. Go back to step 7. (loop)
 * 8. Unlock "web worker"
 *
 * Main Thread Usage:
 * 1. Get notification
 * 2. Do operations
 * 3. Serialize data
 * 4. Write size into the size buffer
 * 5. Write partial data into shared memory
 * 6. Unlock "shared memory signal" (Worker does stuff)
 * 7. If not everything has been written to the shared memory yet
 * 7.1. Get notification
 * 7.2. Write partial data into shared memory
 * 7.3. Unlock "shared memory signal" (Worker does stuff)
 * 7.4. Go back to step 7. (loop)
 */
class AsyncMemory {
    constructor(sharedLock, sharedMemory) {
        this.sharedLock = sharedLock ?? new SharedArrayBuffer(8 * Int32Array.BYTES_PER_ELEMENT);
        this.lockAndSize = new Int32Array(this.sharedLock);
        if (this.lockAndSize.length < 8) {
            throw new Error("Expected an sharedLock with at least 8x32 bytes");
        }
        this.sharedMemory = sharedMemory ?? new SharedArrayBuffer(1024);
        this.memory = new Uint8Array(this.sharedMemory);
        if (this.sharedMemory.byteLength < 1024) {
            throw new Error("Expected an sharedMemory with at least 1024 bytes");
        }
    }
    /**
     * Should be called from the worker thread
     */
    lockWorker() {
        const oldValue = Atomics.compareExchange(this.lockAndSize, AsyncMemory.LOCK_WORKER_INDEX, AsyncMemory.UNLOCKED, // old value
        AsyncMemory.LOCKED // new value
        );
        if (oldValue !== AsyncMemory.UNLOCKED) {
            throw new Error(`Cannot lock worker, the worker has to be unlocked ${AsyncMemory.UNLOCKED} !== ${oldValue}`);
        }
    }
    /**
     * Should be called from the worker thread
     */
    lockSize() {
        const oldValue = Atomics.compareExchange(this.lockAndSize, AsyncMemory.LOCK_SIZE_INDEX, AsyncMemory.UNLOCKED, // old value
        AsyncMemory.LOCKED // new value
        );
        if (oldValue !== AsyncMemory.UNLOCKED) {
            throw new Error(`Cannot set size flag, the size has to be unlocked ${AsyncMemory.UNLOCKED} !== ${oldValue}`);
        }
    }
    /**
     * Only legal if the worker is locked
     */
    waitForSize() {
        Atomics.wait(this.lockAndSize, AsyncMemory.LOCK_SIZE_INDEX, AsyncMemory.LOCKED);
    }
    /**
     * Should be called from the main thread!
     * Only legal if the worker is locked and the size is locked
     */
    writeSize(value) {
        return Atomics.store(this.lockAndSize, AsyncMemory.SIZE_INDEX, value);
    }
    /**
     * Only legal if the worker is locked but the size is not
     */
    readSize() {
        return Atomics.load(this.lockAndSize, AsyncMemory.SIZE_INDEX);
    }
    /**
     * Should be called from the main thread!
     */
    unlockSize() {
        const oldValue = Atomics.compareExchange(this.lockAndSize, AsyncMemory.LOCK_SIZE_INDEX, AsyncMemory.LOCKED, // old value
        AsyncMemory.UNLOCKED // new value
        );
        if (oldValue != AsyncMemory.LOCKED) {
            throw new Error("Tried to unlock, but was already unlocked");
        }
        Atomics.notify(this.lockAndSize, AsyncMemory.LOCK_SIZE_INDEX);
    }
    /**
     * Ensures that the size gets unlocked
     */
    forceUnlockSize() {
        const oldValue = Atomics.compareExchange(this.lockAndSize, AsyncMemory.LOCK_SIZE_INDEX, AsyncMemory.LOCKED, // old value
        AsyncMemory.UNLOCKED // new value
        );
        if (oldValue != AsyncMemory.LOCKED) {
            // And force unlock it
            Atomics.store(this.lockAndSize, AsyncMemory.LOCK_SIZE_INDEX, AsyncMemory.UNLOCKED);
        }
        Atomics.notify(this.lockAndSize, AsyncMemory.LOCK_SIZE_INDEX);
    }
    /**
     * Should be called from the worker thread!
     */
    unlockWorker() {
        const oldValue = Atomics.compareExchange(this.lockAndSize, AsyncMemory.LOCK_WORKER_INDEX, AsyncMemory.LOCKED, // old value
        AsyncMemory.UNLOCKED // new value
        );
        if (oldValue != AsyncMemory.LOCKED) {
            throw new Error("Tried to unlock, but was already unlocked");
        }
        Atomics.notify(this.lockAndSize, AsyncMemory.LOCK_WORKER_INDEX);
    }
}
// Reference: https://v8.dev/features/atomics
AsyncMemory.LOCK_WORKER_INDEX = 0;
AsyncMemory.LOCK_SIZE_INDEX = 2;
AsyncMemory.SIZE_INDEX = 4;
AsyncMemory.UNLOCKED = 0;
AsyncMemory.LOCKED = 1;

const SERIALIZATION = {
    UNDEFINED: 0,
    NULL: 1,
    FALSE: 2,
    TRUE: 3,
    NUMBER: 4,
    DATE: 5,
    KNOWN_SYMBOL: 6,
    STRING: 10,
    BIGINT: 11,
    OBJECT: 255,
};
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol
const KNOWN_SYMBOLS = [
    Symbol.asyncIterator,
    Symbol.hasInstance,
    Symbol.isConcatSpreadable,
    Symbol.iterator,
    Symbol.match,
    Symbol.matchAll,
    Symbol.replace,
    Symbol.search,
    Symbol.species,
    Symbol.split,
    Symbol.toPrimitive,
    Symbol.toStringTag,
    Symbol.unscopables,
];
const textEncoder = new TextEncoder();
new TextDecoder("utf-8");
const encodeFloat = useFloatEncoder();
function useFloatEncoder() {
    // https://stackoverflow.com/a/14379836/3492994
    const temp = new ArrayBuffer(8);
    const tempFloat64 = new Float64Array(temp);
    const tempUint8 = new Uint8Array(temp);
    return function (value) {
        tempFloat64[0] = value;
        return tempUint8;
    };
}
/**
 * Lets one other thread access the objects on this thread.
 * Usually runs on the main thread.
 */
class ObjectProxyHost {
    constructor(memory) {
        this.rootReferences = new Map();
        this.temporaryReferences = new Map();
        this.memory = memory;
    }
    /** Creates a valid, random id for a given object */
    getId(value) {
        return nanoid() + "-" + (typeof value === "function" ? "f" : "o");
    }
    registerRootObject(value) {
        const id = this.getId(value);
        this.rootReferences.set(id, value);
        return id;
    }
    registerTempObject(value) {
        const id = this.getId(value);
        this.temporaryReferences.set(id, value);
        return id;
    }
    clearTemporary() {
        this.temporaryReferences.clear();
    }
    getObject(id) {
        return this.rootReferences.get(id) ?? this.temporaryReferences.get(id);
    }
    // A serializePostMessage isn't needed here, because all we're ever going to pass to the worker are ids
    serializeMemory(value, memory) {
        // Format:
        // [1 byte][n bytes ]
        // [type  ][data    ]
        memory.writeSize(8); // Anything that fits into 8 bytes is fine
        // Simple primitives. Guaranteed to fit into the shared memory.
        if (value === undefined) {
            memory.memory[0] = SERIALIZATION.UNDEFINED;
            memory.unlockSize();
        }
        else if (value === null) {
            memory.memory[0] = SERIALIZATION.NULL;
            memory.unlockSize();
        }
        else if (value === false) {
            memory.memory[0] = SERIALIZATION.FALSE;
            memory.unlockSize();
        }
        else if (value === true) {
            memory.memory[0] = SERIALIZATION.TRUE;
            memory.unlockSize();
        }
        else if (typeof value === "number") {
            memory.memory[0] = SERIALIZATION.NUMBER;
            memory.memory.set(encodeFloat(value), 1);
            memory.unlockSize();
        }
        else if (value instanceof Date) {
            memory.memory[0] = SERIALIZATION.DATE;
            const time = value.getTime();
            memory.memory.set(encodeFloat(time), 1);
            memory.unlockSize();
        }
        else if (typeof value === "symbol" && KNOWN_SYMBOLS.includes(value)) {
            memory.memory[0] = SERIALIZATION.KNOWN_SYMBOL;
            memory.memory[1] = KNOWN_SYMBOLS.indexOf(value);
            memory.unlockSize();
        }
        // Variable length primitives. Not guaranteed to fit into the shared memory, but we know their size.
        else if (typeof value === "string") {
            memory.memory[0] = SERIALIZATION.STRING;
            // A string encoded in utf-8 uses at most 4 bytes per character
            if (value.length * 4 <= memory.memory.byteLength) {
                const data = textEncoder.encode(value);
                memory.memory.set(data, 1);
                memory.writeSize(data.byteLength);
                memory.unlockSize();
            }
            else {
                // Longer strings need to be sent piece by piece
                const bytes = textEncoder.encode(value);
                const memorySize = memory.memory.byteLength;
                let offset = 0;
                let remainingBytes = bytes.byteLength;
                memory.memory.set(bytes.subarray(offset, memorySize - 1), 1);
                offset += memorySize - 1;
                remainingBytes -= memorySize - 1;
                this.writeMemoryContinuation = () => {
                    if (remainingBytes > 0) {
                        memory.memory.set(bytes.subarray(offset, memorySize), 0);
                        offset += memorySize;
                        remainingBytes -= memorySize;
                    }
                    else {
                        this.writeMemoryContinuation = undefined;
                    }
                    memory.unlockSize();
                };
                memory.writeSize(bytes.byteLength);
                memory.unlockSize();
            }
        }
        else if (typeof value === "bigint") {
            memory.memory[0] = SERIALIZATION.BIGINT;
            value.toString();
            // TODO: Implement this (just like the text ^)
            console.warn("Bigint support is not implemented");
            memory.unlockSize();
        }
        // Object. Serialized as ID, guaranteed to fit into shared memory
        else {
            memory.memory[0] = SERIALIZATION.OBJECT;
            const id = this.registerTempObject(value);
            const data = textEncoder.encode(id);
            memory.memory.set(data, 1);
            memory.writeSize(data.byteLength);
            memory.unlockSize();
        }
    }
    /**
     * Deserializes an object that was sent through postMessage
     */
    deserializePostMessage(value) {
        if (typeof value === "object" && value !== null) {
            // Special cases
            if (value.id)
                return this.getObject(value.id);
            if (value.value)
                return value.value;
            if (value.symbol)
                return KNOWN_SYMBOLS[value.symbol];
        }
        // It's a primitive
        return value;
    }
    handleProxyMessage(message, memory) {
        if (message.type === "proxy_reflect") {
            try {
                if (message.method === "apply") {
                    const method = Reflect[message.method];
                    const args = (message.args ?? []).map((v) => this.deserializePostMessage(v));
                    const result = method(this.getObject(message.target), this.getObject(message.thisArg), args);
                    // Write result to shared memory
                    this.serializeMemory(result, memory);
                }
                else {
                    const method = Reflect[message.method];
                    const args = (message.args ?? []).map((v) => this.deserializePostMessage(v));
                    const result = method(this.getObject(message.target), ...args);
                    // Write result to shared memory
                    this.serializeMemory(result, memory);
                }
            }
            catch (e) {
                console.error(message);
                throw e;
            }
        }
        else if (message.type === "proxy_shared_memory") {
            // Write remaining data to shared memory
            if (this.writeMemoryContinuation === undefined) {
                console.warn("No more data to write to shared memory");
            }
            else {
                this.writeMemoryContinuation();
            }
        }
        else if (message.type === "proxy_print_object") {
            console.log("Object with id", message.target, "is", this.getObject(message.target));
        }
        else if (message.type === "proxy_promise") {
            const promiseObject = this.getObject(message.target);
            if (message.method === "then") {
                promiseObject[message.method]((value) => {
                    const result = { value: value };
                    this.serializeMemory(result, memory);
                }, (err) => {
                    const result = { error: err };
                    this.serializeMemory(result, memory);
                });
            }
            else {
                console.error("Unknown proxy promise method", message);
            }
        }
        else {
            console.warn("Unknown proxy message", message);
        }
    }
}
const ObjectId = Symbol.for("id");

async function mainThreadPyodide(opts, drawCanvas) {
    const pyodideWorkerOptions = opts.options;
    pyodideWorkerOptions.globalThisId = "";
    pyodideWorkerOptions.drawCanvasId = "";
    pyodideWorkerOptions.isMainThread = true;
    const fakeKernel = {
        proxy: undefined,
        postMessage(message) { },
        syncFs: undefined,
        input: () => {
            return prompt() || "";
        },
        kernels: new Map(),
        log(kernel, ...args) {
            console.log(...args);
        },
        logWarning(kernel, ...args) {
            console.warn(...args);
        },
        logError(kernel, ...args) {
            console.error(...args);
        },
        [ObjectId]: "",
    };
    globalThis.manager = fakeKernel;
    const kernel = await new Promise((resolve, reject) => {
        try {
            const script = document.createElement("script");
            const onLoad = () => {
                const KernelClass = globalThis[opts.className];
                if (!opts.options.id) {
                    opts.options.id = opts.kernelId;
                }
                const kernel = new KernelClass(pyodideWorkerOptions);
                kernel.init().then(() => {
                    resolve(kernel);
                });
            };
            if (opts.source.type === "url") {
                script.addEventListener("load", onLoad);
                script.src = opts.source.url;
                document.head.appendChild(script);
            }
            else {
                script.text = opts.source.code;
                document.head.appendChild(script);
                onLoad();
            }
        }
        catch (e) {
            reject(e);
        }
    });
    // Not quite as elegant as it could be, but whatevs
    kernel.proxiedDrawCanvas = drawCanvas;
    async function run(code) {
        const result = await kernel.runCode(code);
        return result;
    }
    return run;
}

var kernelWorkerScriptSource = "class AsyncMemory{constructor(sharedLock,sharedMemory){this.sharedLock=sharedLock??new SharedArrayBuffer(8*Int32Array.BYTES_PER_ELEMENT);this.lockAndSize=new Int32Array(this.sharedLock);if(this.lockAndSize.length<8)throw new Error(\"Expected an sharedLock with at least 8x32 bytes\");this.sharedMemory=sharedMemory??new SharedArrayBuffer(1024);this.memory=new Uint8Array(this.sharedMemory);if(this.sharedMemory.byteLength<1024)throw new Error(\"Expected an sharedMemory with at least 1024 bytes\")}lockWorker(){const oldValue=Atomics.compareExchange(this.lockAndSize,AsyncMemory.LOCK_WORKER_INDEX,AsyncMemory.UNLOCKED,AsyncMemory.LOCKED);if(oldValue!==AsyncMemory.UNLOCKED)throw new Error(`Cannot lock worker, the worker has to be unlocked ${AsyncMemory.UNLOCKED} !== ${oldValue}`)}lockSize(){const oldValue=Atomics.compareExchange(this.lockAndSize,AsyncMemory.LOCK_SIZE_INDEX,AsyncMemory.UNLOCKED,AsyncMemory.LOCKED);if(oldValue!==AsyncMemory.UNLOCKED)throw new Error(`Cannot set size flag, the size has to be unlocked ${AsyncMemory.UNLOCKED} !== ${oldValue}`)}waitForSize(){Atomics.wait(this.lockAndSize,AsyncMemory.LOCK_SIZE_INDEX,AsyncMemory.LOCKED)}writeSize(value){return Atomics.store(this.lockAndSize,AsyncMemory.SIZE_INDEX,value)}readSize(){return Atomics.load(this.lockAndSize,AsyncMemory.SIZE_INDEX)}unlockSize(){const oldValue=Atomics.compareExchange(this.lockAndSize,AsyncMemory.LOCK_SIZE_INDEX,AsyncMemory.LOCKED,AsyncMemory.UNLOCKED);if(oldValue!=AsyncMemory.LOCKED)throw new Error(\"Tried to unlock, but was already unlocked\");Atomics.notify(this.lockAndSize,AsyncMemory.LOCK_SIZE_INDEX)}forceUnlockSize(){const oldValue=Atomics.compareExchange(this.lockAndSize,AsyncMemory.LOCK_SIZE_INDEX,AsyncMemory.LOCKED,AsyncMemory.UNLOCKED);if(oldValue!=AsyncMemory.LOCKED)Atomics.store(this.lockAndSize,AsyncMemory.LOCK_SIZE_INDEX,AsyncMemory.UNLOCKED);Atomics.notify(this.lockAndSize,AsyncMemory.LOCK_SIZE_INDEX)}unlockWorker(){const oldValue=Atomics.compareExchange(this.lockAndSize,AsyncMemory.LOCK_WORKER_INDEX,AsyncMemory.LOCKED,AsyncMemory.UNLOCKED);if(oldValue!=AsyncMemory.LOCKED)throw new Error(\"Tried to unlock, but was already unlocked\");Atomics.notify(this.lockAndSize,AsyncMemory.LOCK_WORKER_INDEX)}}AsyncMemory.LOCK_WORKER_INDEX=0;AsyncMemory.LOCK_SIZE_INDEX=2;AsyncMemory.SIZE_INDEX=4;AsyncMemory.UNLOCKED=0;AsyncMemory.LOCKED=1;const SERIALIZATION={UNDEFINED:0,NULL:1,FALSE:2,TRUE:3,NUMBER:4,DATE:5,KNOWN_SYMBOL:6,STRING:10,BIGINT:11,OBJECT:255};const KNOWN_SYMBOLS=[Symbol.asyncIterator,Symbol.hasInstance,Symbol.isConcatSpreadable,Symbol.iterator,Symbol.match,Symbol.matchAll,Symbol.replace,Symbol.search,Symbol.species,Symbol.split,Symbol.toPrimitive,Symbol.toStringTag,Symbol.unscopables];new TextEncoder;const textDecoder=new TextDecoder(\"utf-8\");const decodeFloat=useFloatDecoder();function useFloatDecoder(){const temp=new ArrayBuffer(8);const tempFloat64=new Float64Array(temp);const tempUint8=new Uint8Array(temp);return function(value){tempUint8.set(value);return tempFloat64[0]}}const ObjectId=Symbol.for(\"id\");class ObjectProxyClient{constructor(memory,postMessage){this.memory=memory;this.postMessage=postMessage}serializePostMessage(value){if(isSimplePrimitive(value))return value;else if(isSymbolPrimitive(value))return{symbol:KNOWN_SYMBOLS.indexOf(value)};else if(isVariableLengthPrimitive(value))return value;else if(void 0!==value[ObjectId])return{id:value[ObjectId]};else return{value}}deserializeMemory(memory){const numberOfBytes=memory.readSize();let resultBytes;if(numberOfBytes<=memory.sharedMemory.byteLength)resultBytes=memory.memory;else{const memorySize=memory.sharedMemory.byteLength;let offset=0;let remainingBytes=numberOfBytes;resultBytes=new Uint8Array(numberOfBytes);while(remainingBytes>=memorySize){resultBytes.set(memory.memory,offset);offset+=memorySize;remainingBytes-=memorySize;memory.lockSize();this.postMessage({type:\"proxy_shared_memory\"});memory.waitForSize()}if(remainingBytes>0)resultBytes.set(memory.memory.subarray(0,remainingBytes),offset)}if(resultBytes[0]===SERIALIZATION.UNDEFINED)return;else if(resultBytes[0]===SERIALIZATION.NULL)return null;else if(resultBytes[0]===SERIALIZATION.FALSE)return!1;else if(resultBytes[0]===SERIALIZATION.TRUE)return!0;else if(resultBytes[0]===SERIALIZATION.NUMBER)return decodeFloat(resultBytes.subarray(1,9));else if(resultBytes[0]===SERIALIZATION.DATE){const date=new Date;date.setTime(decodeFloat(resultBytes.subarray(1,9)));return date}else if(resultBytes[0]===SERIALIZATION.KNOWN_SYMBOL){const symbol=KNOWN_SYMBOLS[resultBytes[1]];return symbol}else if(resultBytes[0]===SERIALIZATION.STRING)return textDecoder.decode(resultBytes.slice(1,numberOfBytes+1));else if(resultBytes[0]===SERIALIZATION.BIGINT)return BigInt(textDecoder.decode(resultBytes.slice(1,numberOfBytes+1)));else if(resultBytes[0]===SERIALIZATION.OBJECT){const id=textDecoder.decode(resultBytes.slice(1,numberOfBytes+1));return this.getObjectProxy(id)}else{console.warn(\"Unknown type\",resultBytes[0]);return null}}proxyReflect(method,targetId,args){let value;try{this.memory.lockWorker();this.memory.lockSize();this.memory.writeSize(0);if(\"apply\"===method)this.postMessage({type:\"proxy_reflect\",method,target:targetId,thisArg:args[0],args:args[1].map((v=>this.serializePostMessage(v)))});else this.postMessage({type:\"proxy_reflect\",method,target:targetId,args:args.map((v=>this.serializePostMessage(v)))});this.memory.waitForSize();value=this.deserializeMemory(this.memory)}catch(e){console.error({method,targetId,args});console.error(e);this.postMessage({type:\"proxy_print_object\",target:targetId})}finally{this.memory.forceUnlockSize();this.memory.unlockWorker()}return value}proxyPromise(method,targetId){let value;try{this.memory.lockWorker();this.memory.lockSize();this.memory.writeSize(0);this.postMessage({type:\"proxy_promise\",method,target:targetId});this.memory.waitForSize();value=this.deserializeMemory(this.memory)}catch(e){console.error({method,targetId});console.error(e);this.postMessage({type:\"proxy_print_object\",target:targetId})}finally{this.memory.forceUnlockSize();this.memory.unlockWorker()}return value}isFunction(id){return id.endsWith(\"-f\")}getObjectProxy(id){const client=this;return new Proxy(this.isFunction(id)?function(){}:{},{get(target,prop,receiver){if(prop===ObjectId)return id;const value=client.proxyReflect(\"get\",id,[prop,receiver]);if(\"function\"!==typeof value)return value;return new Proxy(value,{apply(_,thisArg,argumentsList){const calledWithProxy=thisArg===receiver;const functionReturnValue=client.proxyReflect(\"apply\",value[ObjectId],[calledWithProxy?id:thisArg[ObjectId],argumentsList]);return functionReturnValue}})},set(target,prop,value,receiver){return client.proxyReflect(\"set\",id,[prop,value,receiver])},ownKeys(target){return client.proxyReflect(\"ownKeys\",id,[])},has(target,prop){return client.proxyReflect(\"has\",id,[prop])},defineProperty(target,prop,attributes){return client.proxyReflect(\"defineProperty\",id,[prop,attributes])},deleteProperty(target,prop){return client.proxyReflect(\"deleteProperty\",id,[prop])},apply(target,thisArg,argumentsList){return client.proxyReflect(\"apply\",id,[thisArg[ObjectId],argumentsList])},construct(target,argumentsList,newTarget){return client.proxyReflect(\"construct\",id,[argumentsList,newTarget])}})}wrapExcluderProxy(obj,underlyingObject,exclude){return new Proxy(obj,{get(target,prop,receiver){if(exclude.has(prop))target=underlyingObject;const value=Reflect.get(target,prop,receiver);if(\"function\"!==typeof value)return value;return new Proxy(value,{apply(_,thisArg,args){const calledWithProxy=thisArg===receiver;return Reflect.apply(value,calledWithProxy?target:thisArg,args)}})},has(target,prop){if(exclude.has(prop))target=underlyingObject;return Reflect.has(target,prop)}})}thenSync(obj){const objectId=obj[ObjectId];if(!objectId)throw new Error(\"Not a proxy object\");const result=this.proxyPromise(\"then\",objectId);if(result.error)throw result.error;return result.value}}function isSimplePrimitive(value){if(void 0===value)return!0;else if(null===value)return!0;else if(!1===value)return!0;else if(!0===value)return!0;else if(\"number\"===typeof value)return!0;else if(value instanceof Date)return!0;else return!1}function isSymbolPrimitive(value){if(\"symbol\"===typeof value&&KNOWN_SYMBOLS.includes(value))return!0;return!1}function isVariableLengthPrimitive(value){if(\"string\"===typeof value)return!0;else if(\"bigint\"===typeof value)return!0}var _a;function assertUnreachable(_x){throw new Error(\"This case should have never been reached\")}class KernelManager{constructor(){this.kernels=new Map;this.input=()=>\"\\n\";this[_a]=\"\";self.addEventListener(\"message\",(async e=>{if(!e.data){console.warn(\"Kernel worker received unexpected message:\",e);return}const data=e.data;switch(data.type){case\"initialize\":if(data.asyncMemory){const asyncMemory=new AsyncMemory(data.asyncMemory.lockBuffer,data.asyncMemory.dataBuffer);this.proxy=new ObjectProxyClient(asyncMemory,(message=>{this.postMessage(message)}));if(data.getInputId)this.input=this.proxy.getObjectProxy(data.getInputId);if(data.filesystemId){const proxy=this.proxy;const asyncFs=this.proxy.getObjectProxy(data.filesystemId);this.syncFs={get(opts){return proxy.thenSync(asyncFs.get(opts))},put(opts){return proxy.thenSync(asyncFs.put(opts))},delete(opts){return proxy.thenSync(asyncFs.delete(opts))},move(opts){return proxy.thenSync(asyncFs.move(opts))},listDirectory(opts){return proxy.thenSync(asyncFs.listDirectory(opts))}}}}else console.warn(\"Missing async memory, accessing objects from the main thread will not work. Please make sure that COOP/COEP is enabled.\");break;case\"import_kernel\":try{if(\"url\"===data.source.type)importScripts(data.source.url);else{const blob=new Blob([data.source.code],{type:\"text/javascript\"});importScripts(URL.createObjectURL(blob))}const KernelClass=globalThis[data.className];if(!data.options.id)data.options.id=data.kernelId;const kernel=new KernelClass(data.options);this.kernels.set(kernel.kernelId,kernel);kernel.init().then((()=>{this.postMessage({type:\"kernel_initialized\",kernelId:kernel.kernelId})}))}catch(e){this.postMessage({type:\"error\",kernelId:data.kernelId,id:\"\",error:e+\"\"})}break;case\"run\":try{const kernel=this.kernels.get(data.kernelId);if(!kernel)throw new Error(\"Failed to find kernel with id \"+data.kernelId);const result=await kernel.runCode(data.code);this.postMessage({type:\"result\",kernelId:kernel.kernelId,id:data.id,value:result})}catch(e){this.postMessage({type:\"error\",kernelId:data.kernelId,id:data.id,error:e+\"\"})}break;case\"custom\":{const kernel=this.kernels.get(data.kernelId);if(kernel)kernel.customMessage(data.message);else console.warn(\"Custom message was sent to an nonexistent kernel\",data);break}default:assertUnreachable();break}}))}postMessage(message){self.postMessage(message)}log(kernel,...args){this.postMessage({kernelId:kernel.kernelId,type:\"console\",method:\"log\",data:args})}logWarning(kernel,...args){this.postMessage({kernelId:kernel.kernelId,type:\"console\",method:\"warn\",data:args})}logError(kernel,...args){this.postMessage({kernelId:kernel.kernelId,type:\"console\",method:\"error\",data:args})}}_a=ObjectId;globalThis.manager=new KernelManager;\n";

var pyodideWorkerScriptSource = "function patchMatplotlib(module){module.runPythonSimple(`import os\\nos.environ[\"MPLBACKEND\"] = \"AGG\"`);module.runPythonSimple(`import matplotlib\\nimport matplotlib.pyplot\\nfrom pyodide import create_proxy\\nfrom js import drawPyodideCanvas\\n\\ndef show():\\n  canvas = matplotlib.pyplot.gcf().canvas\\n  canvas.draw()\\n  pixels = canvas.buffer_rgba().tobytes()\\n  width, height = canvas.get_width_height()\\n  drawPyodideCanvas(pixels, width, height)\\n  return None\\n\\n# This is probably the better approach, but the object passing stuff doesn't support typed arrays yet\\ndef showUint8():\\n  pixels_proxy = None\\n  pixels_buf = None\\n  try:\\n    canvas = matplotlib.pyplot.gcf().canvas\\n    canvas.draw()\\n    pixels = canvas.buffer_rgba().tobytes()\\n    pixels_proxy = create_proxy(pixels)\\n    pixels_buf = pixels_proxy.getBuffer(\"u8clamped\")\\n    drawPyodideCanvas(pixels)\\n  finally:\\n    if pixels_proxy:\\n      pixels_proxy.destroy()\\n    if pixels_buf:\\n      pixels_buf.release()\\n\\nmatplotlib.pyplot.show = show\\n`)}globalThis.pyodide={};globalThis.loadPyodide=async function(config={}){if(globalThis.__pyodideLoading)throw new Error(\"Pyodide is already loading.\");globalThis.__pyodideLoading=!0;let Module={};let baseURL=config.indexURL;if(baseURL.endsWith(\".js\"))baseURL=baseURL.substr(0,baseURL.lastIndexOf(\"/\"));if(!baseURL.endsWith(\"/\"))baseURL+=\"/\";if(config.stdin)Module.preRun=[function(){Module.FS.init(config.stdin,null,null)}];if(config.print)Module.print=config.print;if(config.printErr)Module.printErr=config.printErr;const DEFAULT_CHANNEL=\"default channel\";const package_uri_regexp=/^.*?([^\\/]*)\\.js$/;function _uri_to_package_name(package_uri){let match=package_uri_regexp.exec(package_uri);if(match)return match[1]}let loadScript;if(self.document)loadScript=url=>new Promise(((res,rej)=>{const script=self.document.createElement(\"script\");script.src=url;script.onload=res;script.onerror=rej;self.document.head.appendChild(script)}));else if(self.importScripts)loadScript=async url=>{self.importScripts(url)};else throw new Error(\"Cannot determine runtime environment\");function recursiveDependencies(names,_messageCallback,errorCallback,sharedLibsOnly){const packages=Module.packages.dependencies;const loadedPackages=Module.loadedPackages;const sharedLibraries=Module.packages.shared_library;const toLoad=new Map;const addPackage=pkg=>{if(toLoad.has(pkg))return;toLoad.set(pkg,DEFAULT_CHANNEL);if(void 0!==loadedPackages[pkg])return;for(let dep of packages[pkg])addPackage(dep)};for(let name of names){const pkgname=_uri_to_package_name(name);if(void 0!==pkgname){if(toLoad.has(pkgname)&&toLoad.get(pkgname)!==name){errorCallback(`Loading same package ${pkgname} from ${name} and ${toLoad.get(pkgname)}`);continue}toLoad.set(pkgname,name)}else if(name in packages)addPackage(name);else errorCallback(`Skipping unknown package '${name}'`)}if(sharedLibsOnly){let onlySharedLibs=new Map;for(let c of toLoad)if(c[0]in sharedLibraries)onlySharedLibs.set(c[0],toLoad.get(c[0]));return onlySharedLibs}return toLoad}async function _loadPackage(names,messageCallback,errorCallback){let toLoad=recursiveDependencies(names,messageCallback,errorCallback);Module.locateFile=path=>{let pkg=path.replace(/\\.data$/,\"\");if(toLoad.has(pkg)){let package_uri=toLoad.get(pkg);if(package_uri!=DEFAULT_CHANNEL)return package_uri.replace(/\\.js$/,\".data\")}return baseURL+path};if(0===toLoad.size)return Promise.resolve(\"No new packages to load\");else{let packageNames=Array.from(toLoad.keys()).join(\", \");messageCallback(`Loading ${packageNames}`)}let windowErrorHandler;let windowErrorPromise;if(self.document)windowErrorPromise=new Promise(((_res,rej)=>{windowErrorHandler=e=>{errorCallback(\"Unhandled error. We don't know what it is or whether it is related to 'loadPackage' but out of an abundance of caution we will assume that loading failed.\");errorCallback(e);rej(e.message)};self.addEventListener(\"error\",windowErrorHandler)}));else windowErrorPromise=new Promise((()=>{}));let scriptPromises=[];for(let[pkg,uri]of toLoad){let loaded=Module.loadedPackages[pkg];if(void 0!==loaded)if(loaded===uri||uri===DEFAULT_CHANNEL){messageCallback(`${pkg} already loaded from ${loaded}`);continue}else{errorCallback(`URI mismatch, attempting to load package ${pkg} from ${uri} `+`while it is already loaded from ${loaded}. To override a dependency, `+`load the custom package first.`);continue}let scriptSrc=uri===DEFAULT_CHANNEL?`${baseURL}${pkg}.js`:uri;messageCallback(`Loading ${pkg} from ${scriptSrc}`);scriptPromises.push(loadScript(scriptSrc).catch((()=>{errorCallback(`Couldn't load package from URL ${scriptSrc}`);toLoad.delete(pkg)})))}function waitRunDependency(){const promise=new Promise((r=>{Module.monitorRunDependencies=n=>{if(0===n)r()}}));Module.addRunDependency(\"dummy\");Module.removeRunDependency(\"dummy\");return promise}let successPromise=Promise.all(scriptPromises).then(waitRunDependency);try{await Promise.race([successPromise,windowErrorPromise])}finally{delete Module.monitorRunDependencies;if(windowErrorHandler)self.removeEventListener(\"error\",windowErrorHandler)}let packageList=[];for(let[pkg,uri]of toLoad){Module.loadedPackages[pkg]=uri;packageList.push(pkg)}let resolveMsg;if(packageList.length>0){let packageNames=packageList.join(\", \");resolveMsg=`Loaded ${packageNames}`}else resolveMsg=\"No packages loaded\";Module.reportUndefinedSymbols();messageCallback(resolveMsg);Module.runPythonSimple(\"import importlib\\n\"+\"importlib.invalidate_caches()\\n\");if(packageList.length>0&&-1!==packageList.indexOf(\"matplotlib\"))patchMatplotlib(Module)}let loadPackageChain=Promise.resolve();Module.loadedPackages={};Module.loadPackage=async function(names,messageCallback,errorCallback){if(Module.isPyProxy(names)){let temp;try{temp=names.toJs()}finally{names.destroy()}names=temp}if(!Array.isArray(names))names=[names];let sharedLibraryNames=[];try{let sharedLibraryPackagesToLoad=recursiveDependencies(names,messageCallback,errorCallback,!0);for(let pkg of sharedLibraryPackagesToLoad)sharedLibraryNames.push(pkg[0])}catch(e){}let oldPlugin;for(let p in Module.preloadPlugins)if(Module.preloadPlugins[p].canHandle(\"test.so\")){oldPlugin=Module.preloadPlugins[p];break}let dynamicLoadHandler={get:function(obj,prop){if(\"handle\"===prop)return function(bytes,name){obj[prop].apply(obj,arguments);this[\"asyncWasmLoadPromise\"]=this[\"asyncWasmLoadPromise\"].then((function(){Module.loadDynamicLibrary(name,{global:!0,nodelete:!0})}))};else return obj[prop]}};var loadPluginOverride=new Proxy(oldPlugin,dynamicLoadHandler);Module.preloadPlugins.unshift(loadPluginOverride);let promise=loadPackageChain.then((()=>_loadPackage(sharedLibraryNames,messageCallback||console.log,errorCallback||console.error)));loadPackageChain=loadPackageChain.then((()=>promise.catch((()=>{}))));await promise;Module.preloadPlugins.shift(loadPluginOverride);promise=loadPackageChain.then((()=>_loadPackage(names,messageCallback||console.log,errorCallback||console.error)));loadPackageChain=loadPackageChain.then((()=>promise.catch((()=>{}))));await promise};function fixRecursionLimit(pyodide){let depth=0;function recurse(){depth+=1;recurse()}try{recurse()}catch(err){}let recursionLimit=depth/50;if(recursionLimit>1e3)recursionLimit=1e3;pyodide.runPythonSimple(`import sys; sys.setrecursionlimit(int(${recursionLimit}))`)}let PUBLIC_API=[\"globals\",\"pyodide_py\",\"version\",\"loadPackage\",\"loadPackagesFromImports\",\"loadedPackages\",\"isPyProxy\",\"pyimport\",\"runPython\",\"runPythonAsync\",\"registerJsModule\",\"unregisterJsModule\",\"setInterruptBuffer\",\"toPy\",\"PythonError\"];function makePublicAPI(module,public_api){let namespace={_module:module};module.public_api=namespace;for(let name of public_api)namespace[name]=module[name];return namespace}Module.noImageDecoding=!0;Module.noAudioDecoding=!0;Module.noWasmDecoding=!1;Module.preloadedWasm={};let fatal_error_occurred=!1;Module.fatal_error=function(e){if(fatal_error_occurred){console.error(\"Recursive call to fatal_error. Inner error was:\");console.error(e);return}fatal_error_occurred=!0;console.error(\"Pyodide has suffered a fatal error. \"+\"Please report this to the Pyodide maintainers.\");console.error(\"The cause of the fatal error was:\");console.error(e);try{let fd_stdout=1;Module.__Py_DumpTraceback(fd_stdout,Module._PyGILState_GetThisThreadState());for(let key of PUBLIC_API){if(\"version\"===key)continue;Object.defineProperty(Module.public_api,key,{enumerable:!0,configurable:!0,get:()=>{throw new Error(\"Pyodide already fatally failed and can no longer be used.\")}})}if(Module.on_fatal)Module.on_fatal(e)}catch(e){console.error(\"Another error occurred while handling the fatal error:\");console.error(e)}throw e};Module.pyodide_py={};Module.globals={};Module.PythonError=class PythonError{constructor(){this.message}};Module.version=\"\";Module.runPythonSimple=function(code){let code_c_string=Module.stringToNewUTF8(code);let errcode;try{errcode=Module._run_python_simple_inner(code_c_string)}catch(e){Module.fatal_error(e)}finally{Module._free(code_c_string)}if(-1===errcode)Module._pythonexc2js()};Module.runPython=function(code,globals=Module.globals){return Module.pyodide_py.eval_code(code,globals)};Module.loadPackagesFromImports=async function(code,messageCallback,errorCallback){let imports=Module.pyodide_py.find_imports(code).toJs();if(0===imports.length)return;let packageNames=Module.packages.import_name_to_package_name;let packages=new Set;for(let name of imports)if(name in packageNames)packages.add(packageNames[name]);if(packages.size)await Module.loadPackage(Array.from(packages.keys()),messageCallback,errorCallback)};Module.pyimport=name=>{console.warn(\"Access to the Python global namespace via pyodide.pyimport is deprecated and \"+\"will be removed in version 0.18.0. Use pyodide.globals.get('key') instead.\");return Module.globals.get(name)};Module.runPythonAsync=async function(code,messageCallback,errorCallback){await Module.loadPackagesFromImports(code,messageCallback,errorCallback);let coroutine=Module.pyodide_py.eval_code_async(code,Module.globals);try{let result=await coroutine;return result}finally{coroutine.destroy()}};Module.registerJsModule=function(name,module){Module.pyodide_py.register_js_module(name,module)};Module.unregisterJsModule=function(name){Module.pyodide_py.unregister_js_module(name)};Module.toPy=function(obj,depth=-1){switch(typeof obj){case\"string\":case\"number\":case\"boolean\":case\"bigint\":case\"undefined\":return obj}if(!obj||Module.isPyProxy(obj))return obj;let obj_id=0;let py_result=0;let result=0;try{obj_id=Module.hiwire.new_value(obj);py_result=Module.__js2python_convert(obj_id,new Map,depth);if(0===py_result)Module._pythonexc2js();if(Module._JsProxy_Check(py_result))return obj;result=Module._python2js(py_result);if(0===result)Module._pythonexc2js()}finally{Module.hiwire.decref(obj_id);Module._Py_DecRef(py_result)}return Module.hiwire.pop_value(result)};Module.isPyProxy=function(jsobj){return!!jsobj&&void 0!==jsobj.$$&&\"PyProxy\"===jsobj.$$.type};Module.locateFile=path=>baseURL+path;let moduleLoaded=new Promise((r=>Module.postRun=r));const scriptSrc=`${baseURL}pyodide.asm.js`;await loadScript(scriptSrc);await _createPyodideModule(Module);await moduleLoaded;Module.runPythonSimple(`def temp(Module):\\n  import pyodide\\n  import __main__\\n  import builtins\\n\\n  globals = __main__.__dict__\\n  globals.update(builtins.__dict__)\\n\\n  Module.version = pyodide.__version__\\n  Module.globals = globals\\n  Module.builtins = builtins.__dict__\\n  Module.pyodide_py = pyodide\\n`);Module.saveState=()=>Module.pyodide_py._state.save_state();Module.restoreState=state=>Module.pyodide_py._state.restore_state(state);Module.init_dict.get(\"temp\")(Module);Module.globals=Module.wrapNamespace(Module.globals);let response=await fetch(`${baseURL}packages.json`);Module.packages=await response.json();fixRecursionLimit(Module);let pyodide=makePublicAPI(Module,PUBLIC_API);Module.registerJsModule(\"js\",globalThis);Module.registerJsModule(\"pyodide_js\",pyodide);globalThis.pyodide=pyodide;return pyodide};const DIR_MODE=16895;const FILE_MODE=33206;const SEEK_CUR=1;const SEEK_END=2;const encoder=new TextEncoder;const decoder=new TextDecoder(\"utf-8\");class EMFS{constructor(FS,ERRNO_CODES,CUSTOM_FS){this.node_ops={};this.stream_ops={};this.FS=FS;this.ERRNO_CODES=ERRNO_CODES;this.CUSTOM_FS=CUSTOM_FS;this.node_ops.getattr=node=>({dev:1,ino:node.id,mode:node.mode,nlink:1,uid:0,gid:0,rdev:void 0,size:0,atime:new Date(node.timestamp),mtime:new Date(node.timestamp),ctime:new Date(node.timestamp),blksize:4096,blocks:0});this.node_ops.setattr=(node,attr)=>{if(void 0!==attr.mode)node.mode=attr.mode;if(void 0!==attr.timestamp)node.timestamp=attr.timestamp};this.node_ops.lookup=(parent,name)=>{const path=realPath(parent,name);const result=this.CUSTOM_FS.get({path});if(!result.ok)throw this.FS.genericErrors[this.ERRNO_CODES[\"ENOENT\"]];return this.createNode(parent,name,null===result.data?DIR_MODE:FILE_MODE)};this.node_ops.mknod=(parent,name,mode,dev)=>{const node=this.createNode(parent,name,mode,dev);const path=realPath(node);if(this.FS.isDir(node.mode))this.convertSyncResult(this.CUSTOM_FS.put({path,value:null}));else this.convertSyncResult(this.CUSTOM_FS.put({path,value:\"\"}));return node};this.node_ops.rename=(oldNode,newDir,newName)=>{const oldPath=realPath(oldNode);const newPath=realPath(newDir,newName);this.convertSyncResult(this.CUSTOM_FS.move({path:oldPath,newPath}));oldNode.name=newName};this.node_ops.unlink=(parent,name)=>{const path=realPath(parent,name);this.convertSyncResult(this.CUSTOM_FS.delete({path}))};this.node_ops.rmdir=(parent,name)=>{const path=realPath(parent,name);this.convertSyncResult(this.CUSTOM_FS.delete({path}))};this.node_ops.readdir=node=>{const path=realPath(node);let result=this.convertSyncResult(this.CUSTOM_FS.listDirectory({path}));if(!result.includes(\".\"))result.push(\".\");if(!result.includes(\"..\"))result.push(\"..\");return result};this.node_ops.symlink=(parent,newName,oldPath)=>{throw new FS.ErrnoError(this.ERRNO_CODES[\"EPERM\"])};this.node_ops.readlink=node=>{throw new FS.ErrnoError(this.ERRNO_CODES[\"EPERM\"])};this.stream_ops.open=stream=>{const path=realPath(stream.node);if(FS.isFile(stream.node.mode)){const result=this.convertSyncResult(this.CUSTOM_FS.get({path}));if(null===result)return;stream.fileData=encoder.encode(result)}};this.stream_ops.close=stream=>{const path=realPath(stream.node);if(FS.isFile(stream.node.mode)&&stream.fileData){const text=decoder.decode(stream.fileData);stream.fileData=void 0;this.convertSyncResult(this.CUSTOM_FS.put({path,value:text}))}};this.stream_ops.read=(stream,buffer,offset,length,position)=>{if(length<=0)return 0;const size=Math.min((stream.fileData?.length??0)-position,length);try{buffer.set(stream.fileData.subarray(position,position+size),offset)}catch(e){throw new FS.ErrnoError(this.ERRNO_CODES[\"EPERM\"])}return size};this.stream_ops.write=(stream,buffer,offset,length,position)=>{if(length<=0)return 0;stream.node.timestamp=Date.now();try{if(position+length>(stream.fileData?.length??0)){const oldData=stream.fileData??new Uint8Array;stream.fileData=new Uint8Array(position+length);stream.fileData.set(oldData)}stream.fileData.set(buffer.subarray(offset,offset+length),position);return length}catch(e){throw new FS.ErrnoError(this.ERRNO_CODES[\"EPERM\"])}};this.stream_ops.llseek=(stream,offset,whence)=>{let position=offset;if(whence===SEEK_CUR)position+=stream.position;else if(whence===SEEK_END)if(this.FS.isFile(stream.node.mode))try{position+=stream.fileData.length}catch(e){throw new FS.ErrnoError(this.ERRNO_CODES[\"EPERM\"])}if(position<0)throw new FS.ErrnoError(this.ERRNO_CODES[\"EINVAL\"]);return position}}mount(mount){return this.createNode(null,\"/\",DIR_MODE,0)}createNode(parent,name,mode,dev){if(!this.FS.isDir(mode)&&!this.FS.isFile(mode))throw new this.FS.ErrnoError(this.ERRNO_CODES[\"EINVAL\"]);let node=this.FS.createNode(parent,name,mode);node.node_ops=this.node_ops;node.stream_ops=this.stream_ops;return node}convertSyncResult(result){if(result.ok)return result.data;else{let error;if(404===result.status)error=new this.FS.ErrnoError(this.ERRNO_CODES[\"ENOENT\"]);else if(400===result.status)error=new this.FS.ErrnoError(this.ERRNO_CODES[\"EINVAL\"]);else error=new this.FS.ErrnoError(this.ERRNO_CODES[\"EPERM\"]);error.cause=result.error;throw error}}}function realPath(node,fileName){const parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent}parts.push(node.mount.opts.root);parts.reverse();if(void 0!==fileName&&null!==fileName)parts.push(fileName);return parts.join(\"/\")}const manager=globalThis?.manager??globalThis.manager;const loadPyodide=self?.loadPyodide??globalThis.loadPyodide;class PyodideKernel{constructor(options){this.proxiedDrawCanvas=()=>{};this.pyodide=void 0;this.kernelId=options.id;this.options=options}async init(){this.proxiedGlobalThis=this.proxyGlobalThis(this.options.globalThisId);this.proxiedDrawCanvas=manager.proxy&&this.options.drawCanvasId?manager.proxy.getObjectProxy(this.options.drawCanvasId):()=>{};globalThis.drawPyodideCanvas=(pixels,width,height)=>{if(pixels.toJs)pixels=pixels.toJs();if(pixels instanceof Uint8ClampedArray||pixels instanceof Uint8Array)pixels=Array.from(pixels);this.proxiedDrawCanvas.apply({},[pixels,width,height])};let artifactsURL=this.options.artifactsUrl||\"https://cdn.jsdelivr.net/pyodide/v0.17.0/full/\";if(!artifactsURL.endsWith(\"/\"))artifactsURL+=\"/\";if(!manager.proxy&&!this.options.isMainThread)console.warn(\"Missing object proxy, some Pyodide functionality will be restricted\");this.pyodide=await loadPyodide({indexURL:artifactsURL,stdin:this.createStdin(),print:text=>{manager.log(this,text+\"\")},printErr:text=>{manager.logError(this,text+\"\")}});if(manager.syncFs){const FS=this.pyodide._module.FS;console.log(FS);try{FS.mkdir(\"/mnt\")}catch(e){console.warn(e)}try{FS.mkdir(\"/mnt/shared\")}catch(e){console.warn(e)}try{FS.mount(new EMFS(FS,this.pyodide._module.ERRNO_CODES,manager.syncFs),{},\"/mnt/shared\");this.pyodide.runPython('import os\\nos.chdir(\"/mnt/shared\")')}catch(e){console.warn(e)}}if(this.proxiedGlobalThis)this.pyodide.registerJsModule(\"js\",this.proxiedGlobalThis)}async runCode(code){if(!this.pyodide){console.warn(\"Worker has not yet been initialized\");return}let result=await this.pyodide.runPythonAsync(code).catch((error=>error));let displayType;if(this.pyodide.isPyProxy(result))if(void 0!==result._repr_html_){result=result._repr_html_();displayType=\"html\"}else if(void 0!==result._repr_latex_){result=result._repr_latex_();displayType=\"latex\"}else{const temp=result;result=result.toJs();this.destroyToJsResult(result);temp?.destroy()}else if(result instanceof this.pyodide.PythonError)result+=\"\";return{display:displayType,value:result}}customMessage(message){return}createStdin(){const encoder=new TextEncoder;let input=new Uint8Array;let inputIndex=-1;function stdin(){if(-1===inputIndex){const text=manager.input();input=encoder.encode(text+(text.endsWith(\"\\n\")?\"\":\"\\n\"));inputIndex=0}if(inputIndex<input.length){let character=input[inputIndex];inputIndex++;return character}else{inputIndex=-1;return null}}return stdin}proxyGlobalThis(id){const noProxy=new Set([\"location\",\"self\",\"importScripts\",\"addEventListener\",\"removeEventListener\",\"caches\",\"crypto\",\"indexedDB\",\"isSecureContext\",\"origin\",\"performance\",\"atob\",\"btoa\",\"clearInterval\",\"clearTimeout\",\"createImageBitmap\",\"fetch\",\"queueMicrotask\",\"setInterval\",\"setTimeout\",\"$$\",\"pyodide\",\"__name__\",\"__package__\",\"__path__\",\"__loader__\",\"stack\",\"get\",\"set\",\"has\",\"size\",\"length\",\"then\",\"includes\",\"next\",Symbol.iterator,\"drawPyodideCanvas\"]);return manager.proxy&&id?manager.proxy.wrapExcluderProxy(manager.proxy.getObjectProxy(id),globalThis,noProxy):globalThis}destroyToJsResult(x){if(!this.pyodide)return;if(!x)return;if(this.pyodide.isPyProxy(x)){x.destroy();return}if(x[Symbol.iterator])for(let k of x)this.destroyToJsResult(k)}}globalThis.PyodideKernel=PyodideKernel;\n";

// @ts-ignore
let setupStatus = "unstarted";
let loadingStatus = "unstarted";
let pyodideLoadSingleton = undefined;
let mainThreadPyodideRunner = undefined;
let kernelManager;
let objectProxyHost = null;
const runningCode = new Map();
// A global value that is the current HTML element to attach matplotlib figures to..
// perhaps this can be done in a cleaner way.
let CURRENT_HTML_OUTPUT_ELEMENT = undefined;
function setGlobalPythonOutputElement(el) {
    CURRENT_HTML_OUTPUT_ELEMENT = el;
}
function drawCanvas(pixels, width, height) {
    const elem = document.createElement("div");
    if (!CURRENT_HTML_OUTPUT_ELEMENT) {
        console.log("HTML output from pyodide but nowhere to put it, will append to body instead.");
        document.querySelector("body").appendChild(elem);
    }
    else {
        CURRENT_HTML_OUTPUT_ELEMENT.appendChild(elem);
    }
    const image = new ImageData(new Uint8ClampedArray(pixels), width, height);
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
        console.warn("Failed to aquire canvas context");
        return;
    }
    ctx.putImageData(image, 0, 0);
    CURRENT_HTML_OUTPUT_ELEMENT?.appendChild(canvas);
}
/**
 * Initial setup for Python support, this includes only the synchronous parts (such as adding a stylesheet used for the output).
 * @returns
 */
function setupPythonSupport() {
    if (setupStatus !== "unstarted") {
        return;
    }
    setupStatus = "started";
    /** Naughty matplotlib WASM backend captures and disables contextmenu globally.. hack to prevent that */
    window.addEventListener("contextmenu", function (event) {
        if (event.target instanceof HTMLElement &&
            event.target.id.startsWith("matplotlib_") &&
            event.target.tagName === "CANVAS") {
            return false;
        }
        event.stopPropagation();
    }, true);
    const styleSheet = document.createElement("style");
    styleSheet.id = "pyodide-styles";
    styleSheet.innerHTML = css;
    document.head.appendChild(styleSheet);
    setupStatus = "completed";
}
function getAsyncMemory() {
    if ("SharedArrayBuffer" in globalThis &&
        "Atomics" in globalThis &&
        globalThis["crossOriginIsolated"] !== false) {
        return new AsyncMemory();
    }
    else {
        return null;
    }
}
async function convertResult(data, runtime) {
    if (data.display === "default") {
        return data.value;
    }
    else if (data.display === "html") {
        let div = document.createElement("div");
        div.className = "rendered_html cell-output-html";
        div.appendChild(new DOMParser().parseFromString(data.value, "text/html").body.firstChild);
        return div;
    }
    else if (data.display === "latex" && runtime) {
        let div = document.createElement("div");
        div.className = "rendered_html cell-output-html";
        const value = data.value;
        const katex = await runtime.exports.libraries.async.KaTeX();
        katex.render(value.replace(/^(\$?\$?)([^]*)\1$/, "$2"), div, {
            throwOnError: false,
            errorColor: " #cc0000",
            displayMode: true,
        });
        return div;
    }
    else {
        return data.value;
    }
}
function loadKernelManager(runtime) {
    // TODO: This part should be moved to starboard
    let kernelUrl = undefined;
    if (kernelUrl === undefined) {
        const blob = new Blob([kernelWorkerScriptSource], { type: "text/javascript" });
        kernelUrl = URL.createObjectURL(blob);
    }
    const worker = new Worker(kernelUrl);
    // Since all kernels are running in the same worker, they might as well use the same async memory and object proxy
    const asyncMemory = getAsyncMemory();
    const objectProxyHost = asyncMemory ? new ObjectProxyHost(asyncMemory) : null;
    const getInputId = objectProxyHost?.registerRootObject(() => {
        return prompt();
    });
    // TODO: Remove 'as any' once the starboard typings get updated
    const filesystemId = runtime?.internal?.fs
        ? objectProxyHost?.registerRootObject(runtime?.internal?.fs)
        : undefined;
    worker.addEventListener("message", (ev) => {
        if (!ev.data) {
            console.warn("Unexpected message from kernel manager", ev);
            return;
        }
        const data = ev.data;
        if (data.type === "proxy_reflect" ||
            data.type === "proxy_shared_memory" ||
            data.type === "proxy_print_object" ||
            data.type === "proxy_promise") {
            if (asyncMemory && objectProxyHost) {
                objectProxyHost.handleProxyMessage(data, asyncMemory);
            }
        }
    });
    worker.postMessage({
        type: "initialize",
        asyncMemory: asyncMemory
            ? {
                lockBuffer: asyncMemory.sharedLock,
                dataBuffer: asyncMemory.sharedMemory,
            }
            : undefined,
        filesystemId: filesystemId,
        getInputId: getInputId,
    });
    return {
        kernelManager: worker,
        objectProxyHost: objectProxyHost,
    };
}
async function loadPyodide(runtime) {
    if (pyodideLoadSingleton)
        return pyodideLoadSingleton;
    const kernelManagerResult = loadKernelManager(runtime);
    kernelManager = kernelManagerResult.kernelManager;
    objectProxyHost = kernelManagerResult.objectProxyHost;
    const globalThisId = objectProxyHost?.registerRootObject(globalThis);
    const drawCanvasId = objectProxyHost?.registerRootObject(drawCanvas);
    // Pyodide worker loading
    loadingStatus = "loading";
    /** Pyodide Kernel id */
    const kernelId = nanoid();
    let kernelSource = getPluginOpts().workerSource;
    if (kernelSource === undefined) {
        kernelSource = {
            type: "code",
            code: pyodideWorkerScriptSource,
        };
    }
    const initOptions = {
        type: "import_kernel",
        className: "PyodideKernel",
        kernelId: kernelId,
        options: {
            artifactsUrl: getPluginOpts().artifactsUrl || window.pyodideArtifactsUrl,
            globalThisId: globalThisId,
            drawCanvasId: drawCanvasId,
        },
        source: kernelSource,
    };
    if (getPluginOpts().runInMainThread) {
        pyodideLoadSingleton = Promise.resolve("");
        mainThreadPyodideRunner = await mainThreadPyodide(initOptions, drawCanvas);
    }
    else {
        pyodideLoadSingleton = new Promise((resolve, reject) => {
            // Only the resolve case is handled for now
            function handleInitMessage(ev) {
                if (!ev.data)
                    return;
                const data = ev.data;
                if (data.type === "kernel_initialized" && data.kernelId === kernelId) {
                    kernelManager.removeEventListener("message", handleInitMessage);
                    resolve(kernelId);
                }
            }
            kernelManager.addEventListener("message", handleInitMessage);
        });
        kernelManager.addEventListener("message", (e) => {
            if (!e.data)
                return;
            const data = e.data;
            switch (data.type) {
                case "result": {
                    if (data.kernelId !== kernelId)
                        break;
                    const callback = runningCode.get(data.id);
                    if (!callback) {
                        console.warn("Missing Python callback");
                    }
                    else {
                        callback(data.value);
                    }
                    objectProxyHost?.clearTemporary();
                    break;
                }
                case "console": {
                    if (data.kernelId !== kernelId)
                        break;
                    console?.[data.method](...data.data);
                    break;
                }
                case "error": {
                    if (data.kernelId !== kernelId)
                        break;
                    console.error(data.error);
                }
                case "custom": {
                    if (data.kernelId !== kernelId)
                        break;
                    // No custom messages so far
                    break;
                }
                // Ignore
                case "kernel_initialized":
                case "proxy_reflect":
                case "proxy_shared_memory":
                case "proxy_print_object":
                case "proxy_promise": {
                    break;
                }
                default: {
                    assertUnreachable();
                }
            }
        });
        kernelManager.postMessage(initOptions);
    }
    await pyodideLoadSingleton;
    loadingStatus = "ready";
    return pyodideLoadSingleton;
}
function getPyodideLoadingStatus() {
    return loadingStatus;
}
async function runPythonAsync(code, runtime) {
    if (!pyodideLoadSingleton)
        return;
    if (getPluginOpts().runInMainThread) {
        if (mainThreadPyodideRunner) {
            const result = await mainThreadPyodideRunner(code);
            return await convertResult(result, runtime);
        }
        else {
            console.error("Missing main thread pyodide");
            return null;
        }
    }
    else {
        const kernelId = await pyodideLoadSingleton;
        const id = nanoid();
        return new Promise((resolve, reject) => {
            runningCode.set(id, (result) => {
                convertResult(result, runtime).then((v) => resolve(v));
                runningCode.delete(id);
            });
            try {
                kernelManager.postMessage({
                    type: "run",
                    kernelId: kernelId,
                    id: id,
                    code: code,
                });
            }
            catch (e) {
                console.warn(e, code);
                reject(e);
                runningCode.delete(id);
            }
        });
    }
}

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/**
 * Creates a promise with the resolve and reject function outside of it, useful for tasks that may complete at any time.
 * Based on MIT licensed https://github.com/arikw/flat-promise, with typings added by gzuidhof.
 * @param executor
 */
function flatPromise(executor) {
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
        // Is this any cast necessary?
        resolve = res;
        reject = rej;
    });
    if (executor) {
        // This is actually valid.. as in the spec the function above the Promise gets executed immediately.
        executor(resolve, reject);
    }
    return { promise, resolve, reject };
}

// This is used as a mutex to prevent double execution.
let pythonRunChain = Promise.resolve();
const isPyProxy = function (jsobj) {
    return !!jsobj && jsobj.$$ !== undefined && jsobj.$$.type === "PyProxy";
};
async function runStarboardPython(runtime, codeToRun, renderOutputIntoElement) {
    setupPythonSupport();
    const pyoPromise = loadPyodide(runtime);
    const done = flatPromise();
    const alreadyRunningPythonCodeDone = pythonRunChain.catch((_) => 0);
    pythonRunChain = pythonRunChain.finally(() => done.promise);
    // await any already executing python cells.
    await alreadyRunningPythonCodeDone;
    const outputElement = new runtime.exports.elements.ConsoleOutputElement();
    outputElement.hook(runtime.consoleCatcher);
    const htmlOutput = document.createElement("div");
    const lit = runtime.exports.libraries.lit;
    const html = lit.html;
    lit.render(html `${outputElement}${htmlOutput}`, renderOutputIntoElement);
    setGlobalPythonOutputElement(htmlOutput);
    await pyoPromise;
    let val = undefined;
    let error = undefined;
    try {
        pythonRunChain = runPythonAsync(codeToRun, runtime);
        val = await pythonRunChain;
        window.$_ = val;
        if (val !== undefined) {
            if (val instanceof HTMLElement) {
                htmlOutput.appendChild(val);
            }
            else if (isPyProxy(val)) {
                let hadHTMLOutput = false;
                if (val._repr_html_ !== undefined) {
                    let result = val._repr_html_();
                    if (typeof result === "string") {
                        let div = document.createElement("div");
                        div.className = "rendered_html cell-output-html";
                        div.appendChild(new DOMParser().parseFromString(result, "text/html").body.firstChild);
                        htmlOutput.appendChild(div);
                        hadHTMLOutput = true;
                    }
                }
                else if (val._repr_latex_ !== undefined) {
                    let result = val._repr_latex_();
                    if (typeof result === "string") {
                        let div = document.createElement("div");
                        div.className = "rendered_html cell-output-html";
                        const katex = await runtime.exports.libraries.async.KaTeX();
                        if (result.startsWith("$$")) {
                            result = result.substr(2, result.length - 3);
                            katex.render(result, div, {
                                throwOnError: false,
                                errorColor: " #cc0000",
                                displayMode: true,
                            });
                        }
                        else if (result.startsWith("$")) {
                            result = result.substr(1, result.length - 2);
                            katex.render(result, div, {
                                throwOnError: false,
                                errorColor: " #cc0000",
                                displayMode: false,
                            });
                        }
                        htmlOutput.appendChild(div);
                        hadHTMLOutput = true;
                    }
                }
                if (!hadHTMLOutput) {
                    outputElement.addEntry({
                        method: "result",
                        data: [val],
                    });
                }
            }
            else {
                outputElement.addEntry({
                    method: "result",
                    data: [val],
                });
            }
        }
    }
    catch (e) {
        error = e;
        outputElement.addEntry({
            method: "error",
            data: [`${e.name} ${e.message}`],
        });
    }
    // Not entirely sure this has to be awaited, is any output delayed by a tick from pyodide?
    await outputElement.unhookAfterOneTick(runtime.consoleCatcher);
    done.resolve();
    if (error !== undefined) {
        throw error;
    }
    return val;
}

function registerPython(runtime) {
    setupPythonSupport();
    /* These globals are exposed by Starboard Notebook. We can re-use them so we don't have to bundle them again. */
    const lit = runtime.exports.libraries.lit;
    const StarboardTextEditor = runtime.exports.elements.StarboardTextEditor;
    const cellControlsTemplate = runtime.exports.templates.cellControls;
    const PYTHON_CELL_TYPE_DEFINITION = {
        name: "Python",
        cellType: ["python", "python3", "ipython3", "pypy", "py"],
        createHandler: (cell, runtime) => new PythonCellHandler(cell, runtime),
    };
    class PythonCellHandler {
        constructor(cell, runtime) {
            this.lastRunId = 0;
            this.isCurrentlyRunning = false;
            this.isCurrentlyLoadingPyodide = false;
            this.cell = cell;
            this.runtime = runtime;
        }
        getControls() {
            const icon = this.isCurrentlyRunning ? "bi bi-hourglass" : "bi bi-play-circle";
            const tooltip = this.isCurrentlyRunning ? "Cell is running" : "Run Cell";
            const runButton = {
                icon,
                tooltip,
                callback: () => this.runtime.controls.runCell({ id: this.cell.id }),
            };
            let buttons = [runButton];
            if (this.isCurrentlyLoadingPyodide) {
                buttons = [
                    {
                        icon: "bi bi-cloud-arrow-down",
                        tooltip: "Downloading and initializing Pyodide",
                        callback: () => {
                            alert("Loading Python runtime. It's 5 to 15 MB in size, so it may take a while. It will be cached for next time.");
                        },
                    },
                    ...buttons,
                ];
            }
            return cellControlsTemplate({ buttons });
        }
        attach(params) {
            this.elements = params.elements;
            const topElement = this.elements.topElement;
            lit.render(this.getControls(), this.elements.topControlsElement);
            this.editor = new StarboardTextEditor(this.cell, this.runtime, { language: "python" });
            topElement.appendChild(this.editor);
        }
        async run() {
            const codeToRun = this.cell.textContent;
            this.lastRunId++;
            const currentRunId = this.lastRunId;
            this.isCurrentlyRunning = true;
            if (getPyodideLoadingStatus() !== "ready") {
                this.isCurrentlyLoadingPyodide = true;
            }
            lit.render(this.getControls(), this.elements.topControlsElement);
            try {
                const val = await runStarboardPython(this.runtime, codeToRun, this.elements.bottomElement);
                // TODO dedupe
                this.isCurrentlyLoadingPyodide = false;
                if (this.lastRunId === currentRunId) {
                    this.isCurrentlyRunning = false;
                    lit.render(this.getControls(), this.elements.topControlsElement);
                }
                return val;
            }
            catch (e) {
                // TODO dedupe
                this.isCurrentlyLoadingPyodide = false;
                if (this.lastRunId === currentRunId) {
                    this.isCurrentlyRunning = false;
                    lit.render(this.getControls(), this.elements.topControlsElement);
                }
                throw e;
            }
        }
        focusEditor() {
            this.editor.focus();
        }
        async dispose() {
            this.editor.remove();
        }
        clear() {
            const html = lit.html;
            lit.render(html ``, this.elements.bottomElement);
        }
    }
    runtime.definitions.cellTypes.register(PYTHON_CELL_TYPE_DEFINITION.cellType, PYTHON_CELL_TYPE_DEFINITION);
}
const plugin = {
    id: "starboard-python",
    metadata: {
        name: "Starboard Python",
    },
    exports: {
        getPyodideLoadingStatus: getPyodideLoadingStatus,
        runStarboardPython: runStarboardPython,
        setGlobalPythonOutputElement: setGlobalPythonOutputElement,
        loadPyodide: loadPyodide,
        updatePluginOptions: updatePluginOptions,
    },
    async register(runtime, opts = {}) {
        setPluginOpts(opts);
        registerPython(runtime);
    },
};

export { getPyodideLoadingStatus, loadPyodide, plugin, registerPython, runStarboardPython, setGlobalPythonOutputElement, setupPythonSupport };
