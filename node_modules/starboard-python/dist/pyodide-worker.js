function patchMatplotlib(module){module.runPythonSimple(`import os\nos.environ["MPLBACKEND"] = "AGG"`);module.runPythonSimple(`import matplotlib\nimport matplotlib.pyplot\nfrom pyodide import create_proxy\nfrom js import drawPyodideCanvas\n\ndef show():\n  canvas = matplotlib.pyplot.gcf().canvas\n  canvas.draw()\n  pixels = canvas.buffer_rgba().tobytes()\n  width, height = canvas.get_width_height()\n  drawPyodideCanvas(pixels, width, height)\n  return None\n\n# This is probably the better approach, but the object passing stuff doesn't support typed arrays yet\ndef showUint8():\n  pixels_proxy = None\n  pixels_buf = None\n  try:\n    canvas = matplotlib.pyplot.gcf().canvas\n    canvas.draw()\n    pixels = canvas.buffer_rgba().tobytes()\n    pixels_proxy = create_proxy(pixels)\n    pixels_buf = pixels_proxy.getBuffer("u8clamped")\n    drawPyodideCanvas(pixels)\n  finally:\n    if pixels_proxy:\n      pixels_proxy.destroy()\n    if pixels_buf:\n      pixels_buf.release()\n\nmatplotlib.pyplot.show = show\n`)}globalThis.pyodide={};globalThis.loadPyodide=async function(config={}){if(globalThis.__pyodideLoading)throw new Error("Pyodide is already loading.");globalThis.__pyodideLoading=!0;let Module={};let baseURL=config.indexURL;if(baseURL.endsWith(".js"))baseURL=baseURL.substr(0,baseURL.lastIndexOf("/"));if(!baseURL.endsWith("/"))baseURL+="/";if(config.stdin)Module.preRun=[function(){Module.FS.init(config.stdin,null,null)}];if(config.print)Module.print=config.print;if(config.printErr)Module.printErr=config.printErr;const DEFAULT_CHANNEL="default channel";const package_uri_regexp=/^.*?([^\/]*)\.js$/;function _uri_to_package_name(package_uri){let match=package_uri_regexp.exec(package_uri);if(match)return match[1]}let loadScript;if(self.document)loadScript=url=>new Promise(((res,rej)=>{const script=self.document.createElement("script");script.src=url;script.onload=res;script.onerror=rej;self.document.head.appendChild(script)}));else if(self.importScripts)loadScript=async url=>{self.importScripts(url)};else throw new Error("Cannot determine runtime environment");function recursiveDependencies(names,_messageCallback,errorCallback,sharedLibsOnly){const packages=Module.packages.dependencies;const loadedPackages=Module.loadedPackages;const sharedLibraries=Module.packages.shared_library;const toLoad=new Map;const addPackage=pkg=>{if(toLoad.has(pkg))return;toLoad.set(pkg,DEFAULT_CHANNEL);if(void 0!==loadedPackages[pkg])return;for(let dep of packages[pkg])addPackage(dep)};for(let name of names){const pkgname=_uri_to_package_name(name);if(void 0!==pkgname){if(toLoad.has(pkgname)&&toLoad.get(pkgname)!==name){errorCallback(`Loading same package ${pkgname} from ${name} and ${toLoad.get(pkgname)}`);continue}toLoad.set(pkgname,name)}else if(name in packages)addPackage(name);else errorCallback(`Skipping unknown package '${name}'`)}if(sharedLibsOnly){let onlySharedLibs=new Map;for(let c of toLoad)if(c[0]in sharedLibraries)onlySharedLibs.set(c[0],toLoad.get(c[0]));return onlySharedLibs}return toLoad}async function _loadPackage(names,messageCallback,errorCallback){let toLoad=recursiveDependencies(names,messageCallback,errorCallback);Module.locateFile=path=>{let pkg=path.replace(/\.data$/,"");if(toLoad.has(pkg)){let package_uri=toLoad.get(pkg);if(package_uri!=DEFAULT_CHANNEL)return package_uri.replace(/\.js$/,".data")}return baseURL+path};if(0===toLoad.size)return Promise.resolve("No new packages to load");else{let packageNames=Array.from(toLoad.keys()).join(", ");messageCallback(`Loading ${packageNames}`)}let windowErrorHandler;let windowErrorPromise;if(self.document)windowErrorPromise=new Promise(((_res,rej)=>{windowErrorHandler=e=>{errorCallback("Unhandled error. We don't know what it is or whether it is related to 'loadPackage' but out of an abundance of caution we will assume that loading failed.");errorCallback(e);rej(e.message)};self.addEventListener("error",windowErrorHandler)}));else windowErrorPromise=new Promise((()=>{}));let scriptPromises=[];for(let[pkg,uri]of toLoad){let loaded=Module.loadedPackages[pkg];if(void 0!==loaded)if(loaded===uri||uri===DEFAULT_CHANNEL){messageCallback(`${pkg} already loaded from ${loaded}`);continue}else{errorCallback(`URI mismatch, attempting to load package ${pkg} from ${uri} `+`while it is already loaded from ${loaded}. To override a dependency, `+`load the custom package first.`);continue}let scriptSrc=uri===DEFAULT_CHANNEL?`${baseURL}${pkg}.js`:uri;messageCallback(`Loading ${pkg} from ${scriptSrc}`);scriptPromises.push(loadScript(scriptSrc).catch((()=>{errorCallback(`Couldn't load package from URL ${scriptSrc}`);toLoad.delete(pkg)})))}function waitRunDependency(){const promise=new Promise((r=>{Module.monitorRunDependencies=n=>{if(0===n)r()}}));Module.addRunDependency("dummy");Module.removeRunDependency("dummy");return promise}let successPromise=Promise.all(scriptPromises).then(waitRunDependency);try{await Promise.race([successPromise,windowErrorPromise])}finally{delete Module.monitorRunDependencies;if(windowErrorHandler)self.removeEventListener("error",windowErrorHandler)}let packageList=[];for(let[pkg,uri]of toLoad){Module.loadedPackages[pkg]=uri;packageList.push(pkg)}let resolveMsg;if(packageList.length>0){let packageNames=packageList.join(", ");resolveMsg=`Loaded ${packageNames}`}else resolveMsg="No packages loaded";Module.reportUndefinedSymbols();messageCallback(resolveMsg);Module.runPythonSimple("import importlib\n"+"importlib.invalidate_caches()\n");if(packageList.length>0&&-1!==packageList.indexOf("matplotlib"))patchMatplotlib(Module)}let loadPackageChain=Promise.resolve();Module.loadedPackages={};Module.loadPackage=async function(names,messageCallback,errorCallback){if(Module.isPyProxy(names)){let temp;try{temp=names.toJs()}finally{names.destroy()}names=temp}if(!Array.isArray(names))names=[names];let sharedLibraryNames=[];try{let sharedLibraryPackagesToLoad=recursiveDependencies(names,messageCallback,errorCallback,!0);for(let pkg of sharedLibraryPackagesToLoad)sharedLibraryNames.push(pkg[0])}catch(e){}let oldPlugin;for(let p in Module.preloadPlugins)if(Module.preloadPlugins[p].canHandle("test.so")){oldPlugin=Module.preloadPlugins[p];break}let dynamicLoadHandler={get:function(obj,prop){if("handle"===prop)return function(bytes,name){obj[prop].apply(obj,arguments);this["asyncWasmLoadPromise"]=this["asyncWasmLoadPromise"].then((function(){Module.loadDynamicLibrary(name,{global:!0,nodelete:!0})}))};else return obj[prop]}};var loadPluginOverride=new Proxy(oldPlugin,dynamicLoadHandler);Module.preloadPlugins.unshift(loadPluginOverride);let promise=loadPackageChain.then((()=>_loadPackage(sharedLibraryNames,messageCallback||console.log,errorCallback||console.error)));loadPackageChain=loadPackageChain.then((()=>promise.catch((()=>{}))));await promise;Module.preloadPlugins.shift(loadPluginOverride);promise=loadPackageChain.then((()=>_loadPackage(names,messageCallback||console.log,errorCallback||console.error)));loadPackageChain=loadPackageChain.then((()=>promise.catch((()=>{}))));await promise};function fixRecursionLimit(pyodide){let depth=0;function recurse(){depth+=1;recurse()}try{recurse()}catch(err){}let recursionLimit=depth/50;if(recursionLimit>1e3)recursionLimit=1e3;pyodide.runPythonSimple(`import sys; sys.setrecursionlimit(int(${recursionLimit}))`)}let PUBLIC_API=["globals","pyodide_py","version","loadPackage","loadPackagesFromImports","loadedPackages","isPyProxy","pyimport","runPython","runPythonAsync","registerJsModule","unregisterJsModule","setInterruptBuffer","toPy","PythonError"];function makePublicAPI(module,public_api){let namespace={_module:module};module.public_api=namespace;for(let name of public_api)namespace[name]=module[name];return namespace}Module.noImageDecoding=!0;Module.noAudioDecoding=!0;Module.noWasmDecoding=!1;Module.preloadedWasm={};let fatal_error_occurred=!1;Module.fatal_error=function(e){if(fatal_error_occurred){console.error("Recursive call to fatal_error. Inner error was:");console.error(e);return}fatal_error_occurred=!0;console.error("Pyodide has suffered a fatal error. "+"Please report this to the Pyodide maintainers.");console.error("The cause of the fatal error was:");console.error(e);try{let fd_stdout=1;Module.__Py_DumpTraceback(fd_stdout,Module._PyGILState_GetThisThreadState());for(let key of PUBLIC_API){if("version"===key)continue;Object.defineProperty(Module.public_api,key,{enumerable:!0,configurable:!0,get:()=>{throw new Error("Pyodide already fatally failed and can no longer be used.")}})}if(Module.on_fatal)Module.on_fatal(e)}catch(e){console.error("Another error occurred while handling the fatal error:");console.error(e)}throw e};Module.pyodide_py={};Module.globals={};Module.PythonError=class PythonError{constructor(){this.message}};Module.version="";Module.runPythonSimple=function(code){let code_c_string=Module.stringToNewUTF8(code);let errcode;try{errcode=Module._run_python_simple_inner(code_c_string)}catch(e){Module.fatal_error(e)}finally{Module._free(code_c_string)}if(-1===errcode)Module._pythonexc2js()};Module.runPython=function(code,globals=Module.globals){return Module.pyodide_py.eval_code(code,globals)};Module.loadPackagesFromImports=async function(code,messageCallback,errorCallback){let imports=Module.pyodide_py.find_imports(code).toJs();if(0===imports.length)return;let packageNames=Module.packages.import_name_to_package_name;let packages=new Set;for(let name of imports)if(name in packageNames)packages.add(packageNames[name]);if(packages.size)await Module.loadPackage(Array.from(packages.keys()),messageCallback,errorCallback)};Module.pyimport=name=>{console.warn("Access to the Python global namespace via pyodide.pyimport is deprecated and "+"will be removed in version 0.18.0. Use pyodide.globals.get('key') instead.");return Module.globals.get(name)};Module.runPythonAsync=async function(code,messageCallback,errorCallback){await Module.loadPackagesFromImports(code,messageCallback,errorCallback);let coroutine=Module.pyodide_py.eval_code_async(code,Module.globals);try{let result=await coroutine;return result}finally{coroutine.destroy()}};Module.registerJsModule=function(name,module){Module.pyodide_py.register_js_module(name,module)};Module.unregisterJsModule=function(name){Module.pyodide_py.unregister_js_module(name)};Module.toPy=function(obj,depth=-1){switch(typeof obj){case"string":case"number":case"boolean":case"bigint":case"undefined":return obj}if(!obj||Module.isPyProxy(obj))return obj;let obj_id=0;let py_result=0;let result=0;try{obj_id=Module.hiwire.new_value(obj);py_result=Module.__js2python_convert(obj_id,new Map,depth);if(0===py_result)Module._pythonexc2js();if(Module._JsProxy_Check(py_result))return obj;result=Module._python2js(py_result);if(0===result)Module._pythonexc2js()}finally{Module.hiwire.decref(obj_id);Module._Py_DecRef(py_result)}return Module.hiwire.pop_value(result)};Module.isPyProxy=function(jsobj){return!!jsobj&&void 0!==jsobj.$$&&"PyProxy"===jsobj.$$.type};Module.locateFile=path=>baseURL+path;let moduleLoaded=new Promise((r=>Module.postRun=r));const scriptSrc=`${baseURL}pyodide.asm.js`;await loadScript(scriptSrc);await _createPyodideModule(Module);await moduleLoaded;Module.runPythonSimple(`def temp(Module):\n  import pyodide\n  import __main__\n  import builtins\n\n  globals = __main__.__dict__\n  globals.update(builtins.__dict__)\n\n  Module.version = pyodide.__version__\n  Module.globals = globals\n  Module.builtins = builtins.__dict__\n  Module.pyodide_py = pyodide\n`);Module.saveState=()=>Module.pyodide_py._state.save_state();Module.restoreState=state=>Module.pyodide_py._state.restore_state(state);Module.init_dict.get("temp")(Module);Module.globals=Module.wrapNamespace(Module.globals);let response=await fetch(`${baseURL}packages.json`);Module.packages=await response.json();fixRecursionLimit(Module);let pyodide=makePublicAPI(Module,PUBLIC_API);Module.registerJsModule("js",globalThis);Module.registerJsModule("pyodide_js",pyodide);globalThis.pyodide=pyodide;return pyodide};const DIR_MODE=16895;const FILE_MODE=33206;const SEEK_CUR=1;const SEEK_END=2;const encoder=new TextEncoder;const decoder=new TextDecoder("utf-8");class EMFS{constructor(FS,ERRNO_CODES,CUSTOM_FS){this.node_ops={};this.stream_ops={};this.FS=FS;this.ERRNO_CODES=ERRNO_CODES;this.CUSTOM_FS=CUSTOM_FS;this.node_ops.getattr=node=>({dev:1,ino:node.id,mode:node.mode,nlink:1,uid:0,gid:0,rdev:void 0,size:0,atime:new Date(node.timestamp),mtime:new Date(node.timestamp),ctime:new Date(node.timestamp),blksize:4096,blocks:0});this.node_ops.setattr=(node,attr)=>{if(void 0!==attr.mode)node.mode=attr.mode;if(void 0!==attr.timestamp)node.timestamp=attr.timestamp};this.node_ops.lookup=(parent,name)=>{const path=realPath(parent,name);const result=this.CUSTOM_FS.get({path});if(!result.ok)throw this.FS.genericErrors[this.ERRNO_CODES["ENOENT"]];return this.createNode(parent,name,null===result.data?DIR_MODE:FILE_MODE)};this.node_ops.mknod=(parent,name,mode,dev)=>{const node=this.createNode(parent,name,mode,dev);const path=realPath(node);if(this.FS.isDir(node.mode))this.convertSyncResult(this.CUSTOM_FS.put({path,value:null}));else this.convertSyncResult(this.CUSTOM_FS.put({path,value:""}));return node};this.node_ops.rename=(oldNode,newDir,newName)=>{const oldPath=realPath(oldNode);const newPath=realPath(newDir,newName);this.convertSyncResult(this.CUSTOM_FS.move({path:oldPath,newPath}));oldNode.name=newName};this.node_ops.unlink=(parent,name)=>{const path=realPath(parent,name);this.convertSyncResult(this.CUSTOM_FS.delete({path}))};this.node_ops.rmdir=(parent,name)=>{const path=realPath(parent,name);this.convertSyncResult(this.CUSTOM_FS.delete({path}))};this.node_ops.readdir=node=>{const path=realPath(node);let result=this.convertSyncResult(this.CUSTOM_FS.listDirectory({path}));if(!result.includes("."))result.push(".");if(!result.includes(".."))result.push("..");return result};this.node_ops.symlink=(parent,newName,oldPath)=>{throw new FS.ErrnoError(this.ERRNO_CODES["EPERM"])};this.node_ops.readlink=node=>{throw new FS.ErrnoError(this.ERRNO_CODES["EPERM"])};this.stream_ops.open=stream=>{const path=realPath(stream.node);if(FS.isFile(stream.node.mode)){const result=this.convertSyncResult(this.CUSTOM_FS.get({path}));if(null===result)return;stream.fileData=encoder.encode(result)}};this.stream_ops.close=stream=>{const path=realPath(stream.node);if(FS.isFile(stream.node.mode)&&stream.fileData){const text=decoder.decode(stream.fileData);stream.fileData=void 0;this.convertSyncResult(this.CUSTOM_FS.put({path,value:text}))}};this.stream_ops.read=(stream,buffer,offset,length,position)=>{if(length<=0)return 0;const size=Math.min((stream.fileData?.length??0)-position,length);try{buffer.set(stream.fileData.subarray(position,position+size),offset)}catch(e){throw new FS.ErrnoError(this.ERRNO_CODES["EPERM"])}return size};this.stream_ops.write=(stream,buffer,offset,length,position)=>{if(length<=0)return 0;stream.node.timestamp=Date.now();try{if(position+length>(stream.fileData?.length??0)){const oldData=stream.fileData??new Uint8Array;stream.fileData=new Uint8Array(position+length);stream.fileData.set(oldData)}stream.fileData.set(buffer.subarray(offset,offset+length),position);return length}catch(e){throw new FS.ErrnoError(this.ERRNO_CODES["EPERM"])}};this.stream_ops.llseek=(stream,offset,whence)=>{let position=offset;if(whence===SEEK_CUR)position+=stream.position;else if(whence===SEEK_END)if(this.FS.isFile(stream.node.mode))try{position+=stream.fileData.length}catch(e){throw new FS.ErrnoError(this.ERRNO_CODES["EPERM"])}if(position<0)throw new FS.ErrnoError(this.ERRNO_CODES["EINVAL"]);return position}}mount(mount){return this.createNode(null,"/",DIR_MODE,0)}createNode(parent,name,mode,dev){if(!this.FS.isDir(mode)&&!this.FS.isFile(mode))throw new this.FS.ErrnoError(this.ERRNO_CODES["EINVAL"]);let node=this.FS.createNode(parent,name,mode);node.node_ops=this.node_ops;node.stream_ops=this.stream_ops;return node}convertSyncResult(result){if(result.ok)return result.data;else{let error;if(404===result.status)error=new this.FS.ErrnoError(this.ERRNO_CODES["ENOENT"]);else if(400===result.status)error=new this.FS.ErrnoError(this.ERRNO_CODES["EINVAL"]);else error=new this.FS.ErrnoError(this.ERRNO_CODES["EPERM"]);error.cause=result.error;throw error}}}function realPath(node,fileName){const parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent}parts.push(node.mount.opts.root);parts.reverse();if(void 0!==fileName&&null!==fileName)parts.push(fileName);return parts.join("/")}const manager=globalThis?.manager??globalThis.manager;const loadPyodide=self?.loadPyodide??globalThis.loadPyodide;class PyodideKernel{constructor(options){this.proxiedDrawCanvas=()=>{};this.pyodide=void 0;this.kernelId=options.id;this.options=options}async init(){this.proxiedGlobalThis=this.proxyGlobalThis(this.options.globalThisId);this.proxiedDrawCanvas=manager.proxy&&this.options.drawCanvasId?manager.proxy.getObjectProxy(this.options.drawCanvasId):()=>{};globalThis.drawPyodideCanvas=(pixels,width,height)=>{if(pixels.toJs)pixels=pixels.toJs();if(pixels instanceof Uint8ClampedArray||pixels instanceof Uint8Array)pixels=Array.from(pixels);this.proxiedDrawCanvas.apply({},[pixels,width,height])};let artifactsURL=this.options.artifactsUrl||"https://cdn.jsdelivr.net/pyodide/v0.17.0/full/";if(!artifactsURL.endsWith("/"))artifactsURL+="/";if(!manager.proxy&&!this.options.isMainThread)console.warn("Missing object proxy, some Pyodide functionality will be restricted");this.pyodide=await loadPyodide({indexURL:artifactsURL,stdin:this.createStdin(),print:text=>{manager.log(this,text+"")},printErr:text=>{manager.logError(this,text+"")}});if(manager.syncFs){const FS=this.pyodide._module.FS;console.log(FS);try{FS.mkdir("/mnt")}catch(e){console.warn(e)}try{FS.mkdir("/mnt/shared")}catch(e){console.warn(e)}try{FS.mount(new EMFS(FS,this.pyodide._module.ERRNO_CODES,manager.syncFs),{},"/mnt/shared");this.pyodide.runPython('import os\nos.chdir("/mnt/shared")')}catch(e){console.warn(e)}}if(this.proxiedGlobalThis)this.pyodide.registerJsModule("js",this.proxiedGlobalThis)}async runCode(code){if(!this.pyodide){console.warn("Worker has not yet been initialized");return}let result=await this.pyodide.runPythonAsync(code).catch((error=>error));let displayType;if(this.pyodide.isPyProxy(result))if(void 0!==result._repr_html_){result=result._repr_html_();displayType="html"}else if(void 0!==result._repr_latex_){result=result._repr_latex_();displayType="latex"}else{const temp=result;result=result.toJs();this.destroyToJsResult(result);temp?.destroy()}else if(result instanceof this.pyodide.PythonError)result+="";return{display:displayType,value:result}}customMessage(message){return}createStdin(){const encoder=new TextEncoder;let input=new Uint8Array;let inputIndex=-1;function stdin(){if(-1===inputIndex){const text=manager.input();input=encoder.encode(text+(text.endsWith("\n")?"":"\n"));inputIndex=0}if(inputIndex<input.length){let character=input[inputIndex];inputIndex++;return character}else{inputIndex=-1;return null}}return stdin}proxyGlobalThis(id){const noProxy=new Set(["location","self","importScripts","addEventListener","removeEventListener","caches","crypto","indexedDB","isSecureContext","origin","performance","atob","btoa","clearInterval","clearTimeout","createImageBitmap","fetch","queueMicrotask","setInterval","setTimeout","$$","pyodide","__name__","__package__","__path__","__loader__","stack","get","set","has","size","length","then","includes","next",Symbol.iterator,"drawPyodideCanvas"]);return manager.proxy&&id?manager.proxy.wrapExcluderProxy(manager.proxy.getObjectProxy(id),globalThis,noProxy):globalThis}destroyToJsResult(x){if(!this.pyodide)return;if(!x)return;if(this.pyodide.isPyProxy(x)){x.destroy();return}if(x[Symbol.iterator])for(let k of x)this.destroyToJsResult(k)}}globalThis.PyodideKernel=PyodideKernel;
